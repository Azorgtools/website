{"ast":null,"code":"/* @flow */\nimport fs from 'fs';\nimport fsPath from 'path';\nimport invariant from 'assert';\nimport { PromiseQueue } from 'sb-promise-queue';\nexport const defaultFilesystem = {\n  join(pathA, pathB) {\n    return fsPath.join(pathA, pathB);\n  },\n  basename(path) {\n    return fsPath.basename(path);\n  },\n  stat(path) {\n    return new Promise((resolve, reject) => {\n      fs.stat(path, (err, res) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res);\n        }\n      });\n    });\n  },\n  readdir(path) {\n    return new Promise((resolve, reject) => {\n      fs.readdir(path, (err, res) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res);\n        }\n      });\n    });\n  }\n};\nasync function scanDirectoryInternal(_ref) {\n  let {\n    path,\n    recursive,\n    validate,\n    result,\n    fileSystem,\n    queue,\n    reject\n  } = _ref;\n  const itemStat = await fileSystem.stat(path);\n  if (itemStat.isFile()) {\n    result.files.push(path);\n  } else if (itemStat.isDirectory()) {\n    result.directories.push(path);\n  }\n  if (!itemStat.isDirectory() || recursive === 'none') {\n    return;\n  }\n  const contents = await fileSystem.readdir(path);\n  contents.forEach(item => {\n    const itemPath = fileSystem.join(path, item);\n    if (!validate(itemPath)) {\n      return;\n    }\n    queue.add(() => scanDirectoryInternal({\n      path: itemPath,\n      recursive: recursive === 'shallow' ? 'none' : 'deep',\n      validate,\n      result,\n      fileSystem,\n      queue,\n      reject\n    })).catch(reject);\n  });\n}\nasync function scanDirectory(path) {\n  let {\n    recursive = true,\n    validate = null,\n    concurrency = Infinity,\n    fileSystem = defaultFilesystem\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  invariant(path && typeof path === 'string', 'path must be a valid string');\n  invariant(typeof recursive === 'boolean', 'options.recursive must be a valid boolean');\n  invariant(validate === null || typeof validate === 'function', 'options.validate must be a valid function');\n  invariant(typeof concurrency === 'number', 'options.concurrency must be a valid number');\n  invariant(fileSystem !== null && typeof fileSystem === 'object', 'options.fileSystem must be a valid object');\n  const queue = new PromiseQueue({\n    concurrency\n  });\n  const result = {\n    files: [],\n    directories: []\n  };\n  const mergedFileSystem = {\n    ...defaultFilesystem,\n    ...fileSystem\n  };\n  await new Promise((resolve, reject) => {\n    scanDirectoryInternal({\n      path,\n      recursive: recursive ? 'deep' : 'shallow',\n      validate: validate != null ? validate : item => mergedFileSystem.basename(item).slice(0, 1) !== '.',\n      result,\n      fileSystem: mergedFileSystem,\n      queue,\n      reject\n    }).then(() => queue.waitTillIdle()).then(resolve, reject);\n  });\n  return result;\n}\nexport default scanDirectory;","map":{"version":3,"names":["fs","fsPath","invariant","PromiseQueue","defaultFilesystem","join","pathA","pathB","basename","path","stat","Promise","resolve","reject","err","res","readdir","scanDirectoryInternal","_ref","recursive","validate","result","fileSystem","queue","itemStat","isFile","files","push","isDirectory","directories","contents","forEach","item","itemPath","add","catch","scanDirectory","concurrency","Infinity","arguments","length","undefined","mergedFileSystem","slice","then","waitTillIdle"],"sources":["/home/user/node_modules/sb-scandir/lib/esm/index.mjs"],"sourcesContent":["/* @flow */\nimport fs from 'fs';\nimport fsPath from 'path';\nimport invariant from 'assert';\nimport { PromiseQueue } from 'sb-promise-queue';\nexport const defaultFilesystem = {\n    join(pathA, pathB) {\n        return fsPath.join(pathA, pathB);\n    },\n    basename(path) {\n        return fsPath.basename(path);\n    },\n    stat(path) {\n        return new Promise((resolve, reject) => {\n            fs.stat(path, (err, res) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(res);\n                }\n            });\n        });\n    },\n    readdir(path) {\n        return new Promise((resolve, reject) => {\n            fs.readdir(path, (err, res) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(res);\n                }\n            });\n        });\n    },\n};\nasync function scanDirectoryInternal({ path, recursive, validate, result, fileSystem, queue, reject, }) {\n    const itemStat = await fileSystem.stat(path);\n    if (itemStat.isFile()) {\n        result.files.push(path);\n    }\n    else if (itemStat.isDirectory()) {\n        result.directories.push(path);\n    }\n    if (!itemStat.isDirectory() || recursive === 'none') {\n        return;\n    }\n    const contents = await fileSystem.readdir(path);\n    contents.forEach((item) => {\n        const itemPath = fileSystem.join(path, item);\n        if (!validate(itemPath)) {\n            return;\n        }\n        queue\n            .add(() => scanDirectoryInternal({\n            path: itemPath,\n            recursive: recursive === 'shallow' ? 'none' : 'deep',\n            validate,\n            result,\n            fileSystem,\n            queue,\n            reject,\n        }))\n            .catch(reject);\n    });\n}\nasync function scanDirectory(path, { recursive = true, validate = null, concurrency = Infinity, fileSystem = defaultFilesystem, } = {}) {\n    invariant(path && typeof path === 'string', 'path must be a valid string');\n    invariant(typeof recursive === 'boolean', 'options.recursive must be a valid boolean');\n    invariant(validate === null || typeof validate === 'function', 'options.validate must be a valid function');\n    invariant(typeof concurrency === 'number', 'options.concurrency must be a valid number');\n    invariant(fileSystem !== null && typeof fileSystem === 'object', 'options.fileSystem must be a valid object');\n    const queue = new PromiseQueue({\n        concurrency,\n    });\n    const result = { files: [], directories: [] };\n    const mergedFileSystem = { ...defaultFilesystem, ...fileSystem };\n    await new Promise((resolve, reject) => {\n        scanDirectoryInternal({\n            path,\n            recursive: recursive ? 'deep' : 'shallow',\n            validate: validate != null ? validate : (item) => mergedFileSystem.basename(item).slice(0, 1) !== '.',\n            result,\n            fileSystem: mergedFileSystem,\n            queue,\n            reject,\n        })\n            .then(() => queue.waitTillIdle())\n            .then(resolve, reject);\n    });\n    return result;\n}\nexport default scanDirectory;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}