{"ast":null,"code":"class PromiseQueue {\n  constructor() {\n    let {\n      concurrency = 1\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.options = {\n      concurrency\n    };\n    this.running = 0;\n    this.queue = [];\n    this.idleCallbacks = [];\n  }\n  clear() {\n    this.queue = [];\n  }\n  onIdle(callback) {\n    this.idleCallbacks.push(callback);\n    return () => {\n      const index = this.idleCallbacks.indexOf(callback);\n      if (index !== -1) {\n        this.idleCallbacks.splice(index, 1);\n      }\n    };\n  }\n  waitTillIdle() {\n    return new Promise(resolve => {\n      if (this.running === 0) {\n        resolve();\n        return;\n      }\n      const dispose = this.onIdle(() => {\n        dispose();\n        resolve();\n      });\n    });\n  }\n  add(callback) {\n    return new Promise((resolve, reject) => {\n      const runCallback = () => {\n        this.running += 1;\n        try {\n          Promise.resolve(callback()).then(val => {\n            resolve(val);\n            this.processNext();\n          }, err => {\n            reject(err);\n            this.processNext();\n          });\n        } catch (err) {\n          reject(err);\n          this.processNext();\n        }\n      };\n      if (this.running >= this.options.concurrency) {\n        this.queue.push(runCallback);\n      } else {\n        runCallback();\n      }\n    });\n  }\n  // Internal function, don't use\n  processNext() {\n    this.running -= 1;\n    const callback = this.queue.shift();\n    if (callback) {\n      callback();\n    } else if (this.running === 0) {\n      this.idleCallbacks.forEach(item => item());\n    }\n  }\n}\nexport { PromiseQueue };","map":{"version":3,"names":["PromiseQueue","constructor","concurrency","arguments","length","undefined","options","running","queue","idleCallbacks","clear","onIdle","callback","push","index","indexOf","splice","waitTillIdle","Promise","resolve","dispose","add","reject","runCallback","then","val","processNext","err","shift","forEach","item"],"sources":["/home/user/node_modules/sb-promise-queue/lib/esm/index.mjs"],"sourcesContent":["class PromiseQueue {\n    constructor({ concurrency = 1 } = {}) {\n        this.options = { concurrency };\n        this.running = 0;\n        this.queue = [];\n        this.idleCallbacks = [];\n    }\n    clear() {\n        this.queue = [];\n    }\n    onIdle(callback) {\n        this.idleCallbacks.push(callback);\n        return () => {\n            const index = this.idleCallbacks.indexOf(callback);\n            if (index !== -1) {\n                this.idleCallbacks.splice(index, 1);\n            }\n        };\n    }\n    waitTillIdle() {\n        return new Promise(resolve => {\n            if (this.running === 0) {\n                resolve();\n                return;\n            }\n            const dispose = this.onIdle(() => {\n                dispose();\n                resolve();\n            });\n        });\n    }\n    add(callback) {\n        return new Promise((resolve, reject) => {\n            const runCallback = () => {\n                this.running += 1;\n                try {\n                    Promise.resolve(callback()).then(val => {\n                        resolve(val);\n                        this.processNext();\n                    }, err => {\n                        reject(err);\n                        this.processNext();\n                    });\n                }\n                catch (err) {\n                    reject(err);\n                    this.processNext();\n                }\n            };\n            if (this.running >= this.options.concurrency) {\n                this.queue.push(runCallback);\n            }\n            else {\n                runCallback();\n            }\n        });\n    }\n    // Internal function, don't use\n    processNext() {\n        this.running -= 1;\n        const callback = this.queue.shift();\n        if (callback) {\n            callback();\n        }\n        else if (this.running === 0) {\n            this.idleCallbacks.forEach(item => item());\n        }\n    }\n}\nexport { PromiseQueue };\n"],"mappings":"AAAA,MAAMA,YAAY,CAAC;EACfC,WAAWA,CAAA,EAA2B;IAAA,IAA1B;MAAEC,WAAW,GAAG;IAAE,CAAC,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IAChC,IAAI,CAACG,OAAO,GAAG;MAAEJ;IAAY,CAAC;IAC9B,IAAI,CAACK,OAAO,GAAG,CAAC;IAChB,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,aAAa,GAAG,EAAE;EAC3B;EACAC,KAAKA,CAAA,EAAG;IACJ,IAAI,CAACF,KAAK,GAAG,EAAE;EACnB;EACAG,MAAMA,CAACC,QAAQ,EAAE;IACb,IAAI,CAACH,aAAa,CAACI,IAAI,CAACD,QAAQ,CAAC;IACjC,OAAO,MAAM;MACT,MAAME,KAAK,GAAG,IAAI,CAACL,aAAa,CAACM,OAAO,CAACH,QAAQ,CAAC;MAClD,IAAIE,KAAK,KAAK,CAAC,CAAC,EAAE;QACd,IAAI,CAACL,aAAa,CAACO,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;MACvC;IACJ,CAAC;EACL;EACAG,YAAYA,CAAA,EAAG;IACX,OAAO,IAAIC,OAAO,CAACC,OAAO,IAAI;MAC1B,IAAI,IAAI,CAACZ,OAAO,KAAK,CAAC,EAAE;QACpBY,OAAO,EAAE;QACT;MACJ;MACA,MAAMC,OAAO,GAAG,IAAI,CAACT,MAAM,CAAC,MAAM;QAC9BS,OAAO,EAAE;QACTD,OAAO,EAAE;MACb,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EACAE,GAAGA,CAACT,QAAQ,EAAE;IACV,OAAO,IAAIM,OAAO,CAAC,CAACC,OAAO,EAAEG,MAAM,KAAK;MACpC,MAAMC,WAAW,GAAGA,CAAA,KAAM;QACtB,IAAI,CAAChB,OAAO,IAAI,CAAC;QACjB,IAAI;UACAW,OAAO,CAACC,OAAO,CAACP,QAAQ,EAAE,CAAC,CAACY,IAAI,CAACC,GAAG,IAAI;YACpCN,OAAO,CAACM,GAAG,CAAC;YACZ,IAAI,CAACC,WAAW,EAAE;UACtB,CAAC,EAAEC,GAAG,IAAI;YACNL,MAAM,CAACK,GAAG,CAAC;YACX,IAAI,CAACD,WAAW,EAAE;UACtB,CAAC,CAAC;QACN,CAAC,CACD,OAAOC,GAAG,EAAE;UACRL,MAAM,CAACK,GAAG,CAAC;UACX,IAAI,CAACD,WAAW,EAAE;QACtB;MACJ,CAAC;MACD,IAAI,IAAI,CAACnB,OAAO,IAAI,IAAI,CAACD,OAAO,CAACJ,WAAW,EAAE;QAC1C,IAAI,CAACM,KAAK,CAACK,IAAI,CAACU,WAAW,CAAC;MAChC,CAAC,MACI;QACDA,WAAW,EAAE;MACjB;IACJ,CAAC,CAAC;EACN;EACA;EACAG,WAAWA,CAAA,EAAG;IACV,IAAI,CAACnB,OAAO,IAAI,CAAC;IACjB,MAAMK,QAAQ,GAAG,IAAI,CAACJ,KAAK,CAACoB,KAAK,EAAE;IACnC,IAAIhB,QAAQ,EAAE;MACVA,QAAQ,EAAE;IACd,CAAC,MACI,IAAI,IAAI,CAACL,OAAO,KAAK,CAAC,EAAE;MACzB,IAAI,CAACE,aAAa,CAACoB,OAAO,CAACC,IAAI,IAAIA,IAAI,EAAE,CAAC;IAC9C;EACJ;AACJ;AACA,SAAS9B,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}