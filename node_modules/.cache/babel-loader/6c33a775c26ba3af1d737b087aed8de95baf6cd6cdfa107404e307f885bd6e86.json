{"ast":null,"code":"import fs from 'fs';\nimport fsPath from 'path';\nimport makeDir from 'make-dir';\nimport isStream from 'is-stream';\nimport shellEscape from 'shell-escape';\nimport scanDirectory from 'sb-scandir';\nimport { PromiseQueue } from 'sb-promise-queue';\nimport invariant, { AssertionError } from 'assert';\nimport SSH2 from 'ssh2';\nconst DEFAULT_CONCURRENCY = 1;\nconst DEFAULT_VALIDATE = path => !fsPath.basename(path).startsWith('.');\nconst DEFAULT_TICK = () => {\n  /* No Op */\n};\nexport class SSHError extends Error {\n  constructor(message) {\n    let code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(message);\n    this.code = code;\n  }\n}\nfunction unixifyPath(path) {\n  if (path.includes('\\\\')) {\n    return path.split('\\\\').join('/');\n  }\n  return path;\n}\nasync function readFile(filePath) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(filePath, 'utf8', (err, res) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n}\nconst SFTP_MKDIR_ERR_CODE_REGEXP = /Error: (E[\\S]+): /;\nasync function makeDirectoryWithSftp(path, sftp) {\n  let stats = null;\n  try {\n    stats = await new Promise((resolve, reject) => {\n      sftp.stat(path, (err, res) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res);\n        }\n      });\n    });\n  } catch (_) {\n    /* No Op */\n  }\n  if (stats) {\n    if (stats.isDirectory()) {\n      // Already exists, nothing to worry about\n      return;\n    }\n    throw new Error('mkdir() failed, target already exists and is not a directory');\n  }\n  try {\n    await new Promise((resolve, reject) => {\n      sftp.mkdir(path, err => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  } catch (err) {\n    if (err != null && typeof err.stack === 'string') {\n      const matches = SFTP_MKDIR_ERR_CODE_REGEXP.exec(err.stack);\n      if (matches != null) {\n        throw new SSHError(err.message, matches[1]);\n      }\n      throw err;\n    }\n  }\n}\nexport class NodeSSH {\n  constructor() {\n    this.connection = null;\n  }\n  getConnection() {\n    const {\n      connection\n    } = this;\n    if (connection == null) {\n      throw new Error('Not connected to server');\n    }\n    return connection;\n  }\n  async connect(givenConfig) {\n    invariant(givenConfig != null && typeof givenConfig === 'object', 'config must be a valid object');\n    const config = {\n      ...givenConfig\n    };\n    invariant(config.username != null && typeof config.username === 'string', 'config.username must be a valid string');\n    if (config.host != null) {\n      invariant(typeof config.host === 'string', 'config.host must be a valid string');\n    } else if (config.sock != null) {\n      invariant(typeof config.sock === 'object', 'config.sock must be a valid object');\n    } else {\n      throw new AssertionError({\n        message: 'Either config.host or config.sock must be provided'\n      });\n    }\n    if (config.privateKey != null || config.privateKeyPath != null) {\n      if (config.privateKey != null) {\n        invariant(typeof config.privateKey === 'string', 'config.privateKey must be a valid string');\n        invariant(config.privateKeyPath == null, 'config.privateKeyPath must not be specified when config.privateKey is specified');\n      } else if (config.privateKeyPath != null) {\n        invariant(typeof config.privateKeyPath === 'string', 'config.privateKeyPath must be a valid string');\n        invariant(config.privateKey == null, 'config.privateKey must not be specified when config.privateKeyPath is specified');\n      }\n      invariant(config.passphrase == null || typeof config.passphrase === 'string', 'config.passphrase must be null or a valid string');\n      if (config.privateKeyPath != null) {\n        // Must be an fs path\n        try {\n          config.privateKey = await readFile(config.privateKeyPath);\n        } catch (err) {\n          if (err != null && err.code === 'ENOENT') {\n            throw new AssertionError({\n              message: 'config.privateKeyPath does not exist at given fs path'\n            });\n          }\n          throw err;\n        }\n      }\n    } else if (config.password != null) {\n      invariant(typeof config.password === 'string', 'config.password must be a valid string');\n    }\n    if (config.tryKeyboard != null) {\n      invariant(typeof config.tryKeyboard === 'boolean', 'config.tryKeyboard must be a valid boolean');\n    }\n    if (config.tryKeyboard) {\n      const {\n        password\n      } = config;\n      if (config.onKeyboardInteractive != null) {\n        invariant(typeof config.onKeyboardInteractive === 'function', 'config.onKeyboardInteractive must be a valid function');\n      } else if (password != null) {\n        config.onKeyboardInteractive = (name, instructions, instructionsLang, prompts, finish) => {\n          if (prompts.length > 0 && prompts[0].prompt.toLowerCase().includes('password')) {\n            finish([password]);\n          }\n        };\n      }\n    }\n    const connection = new SSH2.Client();\n    this.connection = connection;\n    await new Promise((resolve, reject) => {\n      connection.on('error', reject);\n      if (config.onKeyboardInteractive) {\n        connection.on('keyboard-interactive', config.onKeyboardInteractive);\n      }\n      connection.on('ready', () => {\n        connection.removeListener('error', reject);\n        resolve();\n      });\n      connection.on('end', () => {\n        if (this.connection === connection) {\n          this.connection = null;\n        }\n      });\n      connection.on('close', () => {\n        if (this.connection === connection) {\n          this.connection = null;\n        }\n        reject(new SSHError('No response from server', 'ETIMEDOUT'));\n      });\n      connection.connect(config);\n    });\n    return this;\n  }\n  isConnected() {\n    return this.connection != null;\n  }\n  async requestShell(options) {\n    const connection = this.getConnection();\n    return new Promise((resolve, reject) => {\n      connection.on('error', reject);\n      const callback = (err, res) => {\n        connection.removeListener('error', reject);\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res);\n        }\n      };\n      if (options == null) {\n        connection.shell(callback);\n      } else {\n        connection.shell(options, callback);\n      }\n    });\n  }\n  async withShell(callback, options) {\n    invariant(typeof callback === 'function', 'callback must be a valid function');\n    const shell = await this.requestShell(options);\n    try {\n      await callback(shell);\n    } finally {\n      // Try to close gracefully\n      if (!shell.close()) {\n        // Destroy local socket if it doesn't work\n        shell.destroy();\n      }\n    }\n  }\n  async requestSFTP() {\n    const connection = this.getConnection();\n    return new Promise((resolve, reject) => {\n      connection.on('error', reject);\n      connection.sftp((err, res) => {\n        connection.removeListener('error', reject);\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res);\n        }\n      });\n    });\n  }\n  async withSFTP(callback) {\n    invariant(typeof callback === 'function', 'callback must be a valid function');\n    const sftp = await this.requestSFTP();\n    try {\n      await callback(sftp);\n    } finally {\n      sftp.end();\n    }\n  }\n  async execCommand(givenCommand) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    invariant(typeof givenCommand === 'string', 'command must be a valid string');\n    invariant(options != null && typeof options === 'object', 'options must be a valid object');\n    invariant(options.cwd == null || typeof options.cwd === 'string', 'options.cwd must be a valid string');\n    invariant(options.stdin == null || typeof options.stdin === 'string' || isStream.readable(options.stdin), 'options.stdin must be a valid string or readable stream');\n    invariant(options.execOptions == null || typeof options.execOptions === 'object', 'options.execOptions must be a valid object');\n    invariant(options.encoding == null || typeof options.encoding === 'string', 'options.encoding must be a valid string');\n    invariant(options.onChannel == null || typeof options.onChannel === 'function', 'options.onChannel must be a valid function');\n    invariant(options.onStdout == null || typeof options.onStdout === 'function', 'options.onStdout must be a valid function');\n    invariant(options.onStderr == null || typeof options.onStderr === 'function', 'options.onStderr must be a valid function');\n    let command = givenCommand;\n    if (options.cwd) {\n      command = `cd ${shellEscape([options.cwd])} ; ${command}`;\n    }\n    const connection = this.getConnection();\n    const output = {\n      stdout: [],\n      stderr: []\n    };\n    return new Promise((resolve, reject) => {\n      connection.on('error', reject);\n      connection.exec(command, options.execOptions != null ? options.execOptions : {}, (err, channel) => {\n        connection.removeListener('error', reject);\n        if (err) {\n          reject(err);\n          return;\n        }\n        if (options.onChannel) {\n          options.onChannel(channel);\n        }\n        channel.on('data', chunk => {\n          if (options.onStdout) options.onStdout(chunk);\n          output.stdout.push(chunk.toString(options.encoding));\n        });\n        channel.stderr.on('data', chunk => {\n          if (options.onStderr) options.onStderr(chunk);\n          output.stderr.push(chunk.toString(options.encoding));\n        });\n        if (options.stdin != null) {\n          if (isStream.readable(options.stdin)) {\n            options.stdin.pipe(channel, {\n              end: true\n            });\n          } else {\n            channel.write(options.stdin);\n            channel.end();\n          }\n        } else {\n          channel.end();\n        }\n        let code = null;\n        let signal = null;\n        channel.on('exit', (code_, signal_) => {\n          code = code_ !== null && code_ !== void 0 ? code_ : null;\n          signal = signal_ !== null && signal_ !== void 0 ? signal_ : null;\n        });\n        channel.on('close', () => {\n          resolve({\n            code: code != null ? code : null,\n            signal: signal != null ? signal : null,\n            stdout: output.stdout.join('').trim(),\n            stderr: output.stderr.join('').trim()\n          });\n        });\n      });\n    });\n  }\n  async exec(command, parameters) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    invariant(typeof command === 'string', 'command must be a valid string');\n    invariant(Array.isArray(parameters), 'parameters must be a valid array');\n    invariant(options != null && typeof options === 'object', 'options must be a valid object');\n    invariant(options.stream == null || ['both', 'stdout', 'stderr'].includes(options.stream), 'options.stream must be one of both, stdout, stderr');\n    for (let i = 0, {\n        length\n      } = parameters; i < length; i += 1) {\n      invariant(typeof parameters[i] === 'string', `parameters[${i}] must be a valid string`);\n    }\n    const completeCommand = `${command}${parameters.length > 0 ? ` ${shellEscape(parameters)}` : ''}`;\n    const response = await this.execCommand(completeCommand, options);\n    if (options.stream == null || options.stream === 'stdout') {\n      if (response.stderr) {\n        throw new Error(response.stderr);\n      }\n      return response.stdout;\n    }\n    if (options.stream === 'stderr') {\n      return response.stderr;\n    }\n    return response;\n  }\n  async mkdir(path) {\n    let method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'sftp';\n    let givenSftp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    invariant(typeof path === 'string', 'path must be a valid string');\n    invariant(typeof method === 'string' && (method === 'sftp' || method === 'exec'), 'method must be either sftp or exec');\n    invariant(givenSftp == null || typeof givenSftp === 'object', 'sftp must be a valid object');\n    if (method === 'exec') {\n      await this.exec('mkdir', ['-p', unixifyPath(path)]);\n      return;\n    }\n    const sftp = givenSftp || (await this.requestSFTP());\n    const makeSftpDirectory = async retry => makeDirectoryWithSftp(unixifyPath(path), sftp).catch(async error => {\n      if (!retry || error == null || error.message !== 'No such file' && error.code !== 'ENOENT') {\n        throw error;\n      }\n      await this.mkdir(fsPath.dirname(path), 'sftp', sftp);\n      await makeSftpDirectory(false);\n    });\n    try {\n      await makeSftpDirectory(true);\n    } finally {\n      if (!givenSftp) {\n        sftp.end();\n      }\n    }\n  }\n  async getFile(localFile, remoteFile) {\n    let givenSftp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let transferOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    invariant(typeof localFile === 'string', 'localFile must be a valid string');\n    invariant(typeof remoteFile === 'string', 'remoteFile must be a valid string');\n    invariant(givenSftp == null || typeof givenSftp === 'object', 'sftp must be a valid object');\n    invariant(transferOptions == null || typeof transferOptions === 'object', 'transferOptions must be a valid object');\n    const sftp = givenSftp || (await this.requestSFTP());\n    try {\n      await new Promise((resolve, reject) => {\n        sftp.fastGet(unixifyPath(remoteFile), localFile, transferOptions || {}, err => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n      });\n    } finally {\n      if (!givenSftp) {\n        sftp.end();\n      }\n    }\n  }\n  async putFile(localFile, remoteFile) {\n    let givenSftp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let transferOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    invariant(typeof localFile === 'string', 'localFile must be a valid string');\n    invariant(typeof remoteFile === 'string', 'remoteFile must be a valid string');\n    invariant(givenSftp == null || typeof givenSftp === 'object', 'sftp must be a valid object');\n    invariant(transferOptions == null || typeof transferOptions === 'object', 'transferOptions must be a valid object');\n    invariant(await new Promise(resolve => {\n      fs.access(localFile, fs.constants.R_OK, err => {\n        resolve(err === null);\n      });\n    }), `localFile does not exist at ${localFile}`);\n    const sftp = givenSftp || (await this.requestSFTP());\n    const putFile = retry => {\n      return new Promise((resolve, reject) => {\n        sftp.fastPut(localFile, unixifyPath(remoteFile), transferOptions || {}, err => {\n          if (err == null) {\n            resolve();\n            return;\n          }\n          if (err.message === 'No such file' && retry) {\n            resolve(this.mkdir(fsPath.dirname(remoteFile), 'sftp', sftp).then(() => putFile(false)));\n          } else {\n            reject(err);\n          }\n        });\n      });\n    };\n    try {\n      await putFile(true);\n    } finally {\n      if (!givenSftp) {\n        sftp.end();\n      }\n    }\n  }\n  async putFiles(files) {\n    let {\n      concurrency = DEFAULT_CONCURRENCY,\n      sftp: givenSftp = null,\n      transferOptions = {}\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    invariant(Array.isArray(files), 'files must be an array');\n    for (let i = 0, {\n        length\n      } = files; i < length; i += 1) {\n      const file = files[i];\n      invariant(file, 'files items must be valid objects');\n      invariant(file.local && typeof file.local === 'string', `files[${i}].local must be a string`);\n      invariant(file.remote && typeof file.remote === 'string', `files[${i}].remote must be a string`);\n    }\n    const transferred = [];\n    const sftp = givenSftp || (await this.requestSFTP());\n    const queue = new PromiseQueue({\n      concurrency\n    });\n    try {\n      await new Promise((resolve, reject) => {\n        files.forEach(file => {\n          queue.add(async () => {\n            await this.putFile(file.local, file.remote, sftp, transferOptions);\n            transferred.push(file);\n          }).catch(reject);\n        });\n        queue.waitTillIdle().then(resolve);\n      });\n    } catch (error) {\n      if (error != null) {\n        error.transferred = transferred;\n      }\n      throw error;\n    } finally {\n      if (!givenSftp) {\n        sftp.end();\n      }\n    }\n  }\n  async putDirectory(localDirectory, remoteDirectory) {\n    let {\n      concurrency = DEFAULT_CONCURRENCY,\n      sftp: givenSftp = null,\n      transferOptions = {},\n      recursive = true,\n      tick = DEFAULT_TICK,\n      validate = DEFAULT_VALIDATE\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    invariant(typeof localDirectory === 'string' && localDirectory, 'localDirectory must be a string');\n    invariant(typeof remoteDirectory === 'string' && remoteDirectory, 'remoteDirectory must be a string');\n    const localDirectoryStat = await new Promise(resolve => {\n      fs.stat(localDirectory, (err, stat) => {\n        resolve(stat || null);\n      });\n    });\n    invariant(localDirectoryStat != null, `localDirectory does not exist at ${localDirectory}`);\n    invariant(localDirectoryStat.isDirectory(), `localDirectory is not a directory at ${localDirectory}`);\n    const sftp = givenSftp || (await this.requestSFTP());\n    const scanned = await scanDirectory(localDirectory, {\n      recursive,\n      validate\n    });\n    const files = scanned.files.map(item => fsPath.relative(localDirectory, item));\n    const directories = scanned.directories.map(item => fsPath.relative(localDirectory, item));\n    // Sort shortest to longest\n    directories.sort((a, b) => a.length - b.length);\n    let failed = false;\n    try {\n      // Do the directories first.\n      await new Promise((resolve, reject) => {\n        const queue = new PromiseQueue({\n          concurrency\n        });\n        directories.forEach(directory => {\n          queue.add(async () => {\n            await this.mkdir(fsPath.join(remoteDirectory, directory), 'sftp', sftp);\n          }).catch(reject);\n        });\n        resolve(queue.waitTillIdle());\n      });\n      // and now the files\n      await new Promise((resolve, reject) => {\n        const queue = new PromiseQueue({\n          concurrency\n        });\n        files.forEach(file => {\n          queue.add(async () => {\n            const localFile = fsPath.join(localDirectory, file);\n            const remoteFile = fsPath.join(remoteDirectory, file);\n            try {\n              await this.putFile(localFile, remoteFile, sftp, transferOptions);\n              tick(localFile, remoteFile, null);\n            } catch (_) {\n              failed = true;\n              tick(localFile, remoteFile, _);\n            }\n          }).catch(reject);\n        });\n        resolve(queue.waitTillIdle());\n      });\n    } finally {\n      if (!givenSftp) {\n        sftp.end();\n      }\n    }\n    return !failed;\n  }\n  async getDirectory(localDirectory, remoteDirectory) {\n    let {\n      concurrency = DEFAULT_CONCURRENCY,\n      sftp: givenSftp = null,\n      transferOptions = {},\n      recursive = true,\n      tick = DEFAULT_TICK,\n      validate = DEFAULT_VALIDATE\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    invariant(typeof localDirectory === 'string' && localDirectory, 'localDirectory must be a string');\n    invariant(typeof remoteDirectory === 'string' && remoteDirectory, 'remoteDirectory must be a string');\n    const localDirectoryStat = await new Promise(resolve => {\n      fs.stat(localDirectory, (err, stat) => {\n        resolve(stat || null);\n      });\n    });\n    invariant(localDirectoryStat != null, `localDirectory does not exist at ${localDirectory}`);\n    invariant(localDirectoryStat.isDirectory(), `localDirectory is not a directory at ${localDirectory}`);\n    const sftp = givenSftp || (await this.requestSFTP());\n    const scanned = await scanDirectory(remoteDirectory, {\n      recursive,\n      validate,\n      concurrency,\n      fileSystem: {\n        basename(path) {\n          return fsPath.posix.basename(path);\n        },\n        join(pathA, pathB) {\n          return fsPath.posix.join(pathA, pathB);\n        },\n        readdir(path) {\n          return new Promise((resolve, reject) => {\n            sftp.readdir(path, (err, res) => {\n              if (err) {\n                reject(err);\n              } else {\n                resolve(res.map(item => item.filename));\n              }\n            });\n          });\n        },\n        stat(path) {\n          return new Promise((resolve, reject) => {\n            sftp.stat(path, (err, res) => {\n              if (err) {\n                reject(err);\n              } else {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                resolve(res);\n              }\n            });\n          });\n        }\n      }\n    });\n    const files = scanned.files.map(item => fsPath.relative(remoteDirectory, item));\n    const directories = scanned.directories.map(item => fsPath.relative(remoteDirectory, item));\n    // Sort shortest to longest\n    directories.sort((a, b) => a.length - b.length);\n    let failed = false;\n    try {\n      // Do the directories first.\n      await new Promise((resolve, reject) => {\n        const queue = new PromiseQueue({\n          concurrency\n        });\n        directories.forEach(directory => {\n          queue.add(async () => {\n            await makeDir(fsPath.join(localDirectory, directory));\n          }).catch(reject);\n        });\n        resolve(queue.waitTillIdle());\n      });\n      // and now the files\n      await new Promise((resolve, reject) => {\n        const queue = new PromiseQueue({\n          concurrency\n        });\n        files.forEach(file => {\n          queue.add(async () => {\n            const localFile = fsPath.join(localDirectory, file);\n            const remoteFile = fsPath.join(remoteDirectory, file);\n            try {\n              await this.getFile(localFile, remoteFile, sftp, transferOptions);\n              tick(localFile, remoteFile, null);\n            } catch (_) {\n              failed = true;\n              tick(localFile, remoteFile, _);\n            }\n          }).catch(reject);\n        });\n        resolve(queue.waitTillIdle());\n      });\n    } finally {\n      if (!givenSftp) {\n        sftp.end();\n      }\n    }\n    return !failed;\n  }\n  forwardIn(remoteAddr, remotePort, onConnection) {\n    const connection = this.getConnection();\n    return new Promise((resolve, reject) => {\n      connection.forwardIn(remoteAddr, remotePort, (error, port) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        const handler = (details, acceptConnection, rejectConnection) => {\n          if (details.destIP === remoteAddr && details.destPort === port) {\n            onConnection === null || onConnection === void 0 ? void 0 : onConnection(details, acceptConnection, rejectConnection);\n          }\n        };\n        if (onConnection) {\n          connection.on('tcp connection', handler);\n        }\n        const dispose = () => {\n          return new Promise((_resolve, _reject) => {\n            connection.off('tcp connection', handler);\n            connection.unforwardIn(remoteAddr, port, _error => {\n              if (_error) {\n                _reject(error);\n              }\n              _resolve();\n            });\n          });\n        };\n        resolve({\n          port,\n          dispose\n        });\n      });\n    });\n  }\n  forwardOut(srcIP, srcPort, dstIP, dstPort) {\n    const connection = this.getConnection();\n    return new Promise((resolve, reject) => {\n      connection.forwardOut(srcIP, srcPort, dstIP, dstPort, (error, channel) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        resolve(channel);\n      });\n    });\n  }\n  forwardInStreamLocal(socketPath, onConnection) {\n    const connection = this.getConnection();\n    return new Promise((resolve, reject) => {\n      connection.openssh_forwardInStreamLocal(socketPath, error => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        const handler = (details, acceptConnection, rejectConnection) => {\n          if (details.socketPath === socketPath) {\n            onConnection === null || onConnection === void 0 ? void 0 : onConnection(details, acceptConnection, rejectConnection);\n          }\n        };\n        if (onConnection) {\n          connection.on('unix connection', handler);\n        }\n        const dispose = () => {\n          return new Promise((_resolve, _reject) => {\n            connection.off('unix connection', handler);\n            connection.openssh_unforwardInStreamLocal(socketPath, _error => {\n              if (_error) {\n                _reject(_error);\n              }\n              _resolve();\n            });\n          });\n        };\n        resolve({\n          dispose\n        });\n      });\n    });\n  }\n  forwardOutStreamLocal(socketPath) {\n    const connection = this.getConnection();\n    return new Promise((resolve, reject) => {\n      connection.openssh_forwardOutStreamLocal(socketPath, (error, channel) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        resolve(channel);\n      });\n    });\n  }\n  dispose() {\n    if (this.connection) {\n      this.connection.end();\n      this.connection = null;\n    }\n  }\n}","map":{"version":3,"names":["fs","fsPath","makeDir","isStream","shellEscape","scanDirectory","PromiseQueue","invariant","AssertionError","SSH2","DEFAULT_CONCURRENCY","DEFAULT_VALIDATE","path","basename","startsWith","DEFAULT_TICK","SSHError","Error","constructor","message","code","arguments","length","undefined","unixifyPath","includes","split","join","readFile","filePath","Promise","resolve","reject","err","res","SFTP_MKDIR_ERR_CODE_REGEXP","makeDirectoryWithSftp","sftp","stats","stat","_","isDirectory","mkdir","stack","matches","exec","NodeSSH","connection","getConnection","connect","givenConfig","config","username","host","sock","privateKey","privateKeyPath","passphrase","password","tryKeyboard","onKeyboardInteractive","name","instructions","instructionsLang","prompts","finish","prompt","toLowerCase","Client","on","removeListener","isConnected","requestShell","options","callback","shell","withShell","close","destroy","requestSFTP","withSFTP","end","execCommand","givenCommand","cwd","stdin","readable","execOptions","encoding","onChannel","onStdout","onStderr","command","output","stdout","stderr","channel","chunk","push","toString","pipe","write","signal","code_","signal_","trim","parameters","Array","isArray","stream","i","completeCommand","response","method","givenSftp","makeSftpDirectory","retry","catch","error","dirname","getFile","localFile","remoteFile","transferOptions","fastGet","putFile","access","constants","R_OK","fastPut","then","putFiles","files","concurrency","file","local","remote","transferred","queue","forEach","add","waitTillIdle","putDirectory","localDirectory","remoteDirectory","recursive","tick","validate","localDirectoryStat","scanned","map","item","relative","directories","sort","a","b","failed","directory","getDirectory","fileSystem","posix","pathA","pathB","readdir","filename","forwardIn","remoteAddr","remotePort","onConnection","port","handler","details","acceptConnection","rejectConnection","destIP","destPort","dispose","_resolve","_reject","off","unforwardIn","_error","forwardOut","srcIP","srcPort","dstIP","dstPort","forwardInStreamLocal","socketPath","openssh_forwardInStreamLocal","openssh_unforwardInStreamLocal","forwardOutStreamLocal","openssh_forwardOutStreamLocal"],"sources":["/home/user/node_modules/node-ssh/lib/esm/index.mjs"],"sourcesContent":["import fs from 'fs';\nimport fsPath from 'path';\nimport makeDir from 'make-dir';\nimport isStream from 'is-stream';\nimport shellEscape from 'shell-escape';\nimport scanDirectory from 'sb-scandir';\nimport { PromiseQueue } from 'sb-promise-queue';\nimport invariant, { AssertionError } from 'assert';\nimport SSH2 from 'ssh2';\nconst DEFAULT_CONCURRENCY = 1;\nconst DEFAULT_VALIDATE = (path) => !fsPath.basename(path).startsWith('.');\nconst DEFAULT_TICK = () => {\n    /* No Op */\n};\nexport class SSHError extends Error {\n    constructor(message, code = null) {\n        super(message);\n        this.code = code;\n    }\n}\nfunction unixifyPath(path) {\n    if (path.includes('\\\\')) {\n        return path.split('\\\\').join('/');\n    }\n    return path;\n}\nasync function readFile(filePath) {\n    return new Promise((resolve, reject) => {\n        fs.readFile(filePath, 'utf8', (err, res) => {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(res);\n            }\n        });\n    });\n}\nconst SFTP_MKDIR_ERR_CODE_REGEXP = /Error: (E[\\S]+): /;\nasync function makeDirectoryWithSftp(path, sftp) {\n    let stats = null;\n    try {\n        stats = await new Promise((resolve, reject) => {\n            sftp.stat(path, (err, res) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(res);\n                }\n            });\n        });\n    }\n    catch (_) {\n        /* No Op */\n    }\n    if (stats) {\n        if (stats.isDirectory()) {\n            // Already exists, nothing to worry about\n            return;\n        }\n        throw new Error('mkdir() failed, target already exists and is not a directory');\n    }\n    try {\n        await new Promise((resolve, reject) => {\n            sftp.mkdir(path, (err) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve();\n                }\n            });\n        });\n    }\n    catch (err) {\n        if (err != null && typeof err.stack === 'string') {\n            const matches = SFTP_MKDIR_ERR_CODE_REGEXP.exec(err.stack);\n            if (matches != null) {\n                throw new SSHError(err.message, matches[1]);\n            }\n            throw err;\n        }\n    }\n}\nexport class NodeSSH {\n    constructor() {\n        this.connection = null;\n    }\n    getConnection() {\n        const { connection } = this;\n        if (connection == null) {\n            throw new Error('Not connected to server');\n        }\n        return connection;\n    }\n    async connect(givenConfig) {\n        invariant(givenConfig != null && typeof givenConfig === 'object', 'config must be a valid object');\n        const config = { ...givenConfig };\n        invariant(config.username != null && typeof config.username === 'string', 'config.username must be a valid string');\n        if (config.host != null) {\n            invariant(typeof config.host === 'string', 'config.host must be a valid string');\n        }\n        else if (config.sock != null) {\n            invariant(typeof config.sock === 'object', 'config.sock must be a valid object');\n        }\n        else {\n            throw new AssertionError({ message: 'Either config.host or config.sock must be provided' });\n        }\n        if (config.privateKey != null || config.privateKeyPath != null) {\n            if (config.privateKey != null) {\n                invariant(typeof config.privateKey === 'string', 'config.privateKey must be a valid string');\n                invariant(config.privateKeyPath == null, 'config.privateKeyPath must not be specified when config.privateKey is specified');\n            }\n            else if (config.privateKeyPath != null) {\n                invariant(typeof config.privateKeyPath === 'string', 'config.privateKeyPath must be a valid string');\n                invariant(config.privateKey == null, 'config.privateKey must not be specified when config.privateKeyPath is specified');\n            }\n            invariant(config.passphrase == null || typeof config.passphrase === 'string', 'config.passphrase must be null or a valid string');\n            if (config.privateKeyPath != null) {\n                // Must be an fs path\n                try {\n                    config.privateKey = await readFile(config.privateKeyPath);\n                }\n                catch (err) {\n                    if (err != null && err.code === 'ENOENT') {\n                        throw new AssertionError({ message: 'config.privateKeyPath does not exist at given fs path' });\n                    }\n                    throw err;\n                }\n            }\n        }\n        else if (config.password != null) {\n            invariant(typeof config.password === 'string', 'config.password must be a valid string');\n        }\n        if (config.tryKeyboard != null) {\n            invariant(typeof config.tryKeyboard === 'boolean', 'config.tryKeyboard must be a valid boolean');\n        }\n        if (config.tryKeyboard) {\n            const { password } = config;\n            if (config.onKeyboardInteractive != null) {\n                invariant(typeof config.onKeyboardInteractive === 'function', 'config.onKeyboardInteractive must be a valid function');\n            }\n            else if (password != null) {\n                config.onKeyboardInteractive = (name, instructions, instructionsLang, prompts, finish) => {\n                    if (prompts.length > 0 && prompts[0].prompt.toLowerCase().includes('password')) {\n                        finish([password]);\n                    }\n                };\n            }\n        }\n        const connection = new SSH2.Client();\n        this.connection = connection;\n        await new Promise((resolve, reject) => {\n            connection.on('error', reject);\n            if (config.onKeyboardInteractive) {\n                connection.on('keyboard-interactive', config.onKeyboardInteractive);\n            }\n            connection.on('ready', () => {\n                connection.removeListener('error', reject);\n                resolve();\n            });\n            connection.on('end', () => {\n                if (this.connection === connection) {\n                    this.connection = null;\n                }\n            });\n            connection.on('close', () => {\n                if (this.connection === connection) {\n                    this.connection = null;\n                }\n                reject(new SSHError('No response from server', 'ETIMEDOUT'));\n            });\n            connection.connect(config);\n        });\n        return this;\n    }\n    isConnected() {\n        return this.connection != null;\n    }\n    async requestShell(options) {\n        const connection = this.getConnection();\n        return new Promise((resolve, reject) => {\n            connection.on('error', reject);\n            const callback = (err, res) => {\n                connection.removeListener('error', reject);\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(res);\n                }\n            };\n            if (options == null) {\n                connection.shell(callback);\n            }\n            else {\n                connection.shell(options, callback);\n            }\n        });\n    }\n    async withShell(callback, options) {\n        invariant(typeof callback === 'function', 'callback must be a valid function');\n        const shell = await this.requestShell(options);\n        try {\n            await callback(shell);\n        }\n        finally {\n            // Try to close gracefully\n            if (!shell.close()) {\n                // Destroy local socket if it doesn't work\n                shell.destroy();\n            }\n        }\n    }\n    async requestSFTP() {\n        const connection = this.getConnection();\n        return new Promise((resolve, reject) => {\n            connection.on('error', reject);\n            connection.sftp((err, res) => {\n                connection.removeListener('error', reject);\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(res);\n                }\n            });\n        });\n    }\n    async withSFTP(callback) {\n        invariant(typeof callback === 'function', 'callback must be a valid function');\n        const sftp = await this.requestSFTP();\n        try {\n            await callback(sftp);\n        }\n        finally {\n            sftp.end();\n        }\n    }\n    async execCommand(givenCommand, options = {}) {\n        invariant(typeof givenCommand === 'string', 'command must be a valid string');\n        invariant(options != null && typeof options === 'object', 'options must be a valid object');\n        invariant(options.cwd == null || typeof options.cwd === 'string', 'options.cwd must be a valid string');\n        invariant(options.stdin == null || typeof options.stdin === 'string' || isStream.readable(options.stdin), 'options.stdin must be a valid string or readable stream');\n        invariant(options.execOptions == null || typeof options.execOptions === 'object', 'options.execOptions must be a valid object');\n        invariant(options.encoding == null || typeof options.encoding === 'string', 'options.encoding must be a valid string');\n        invariant(options.onChannel == null || typeof options.onChannel === 'function', 'options.onChannel must be a valid function');\n        invariant(options.onStdout == null || typeof options.onStdout === 'function', 'options.onStdout must be a valid function');\n        invariant(options.onStderr == null || typeof options.onStderr === 'function', 'options.onStderr must be a valid function');\n        let command = givenCommand;\n        if (options.cwd) {\n            command = `cd ${shellEscape([options.cwd])} ; ${command}`;\n        }\n        const connection = this.getConnection();\n        const output = { stdout: [], stderr: [] };\n        return new Promise((resolve, reject) => {\n            connection.on('error', reject);\n            connection.exec(command, options.execOptions != null ? options.execOptions : {}, (err, channel) => {\n                connection.removeListener('error', reject);\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                if (options.onChannel) {\n                    options.onChannel(channel);\n                }\n                channel.on('data', (chunk) => {\n                    if (options.onStdout)\n                        options.onStdout(chunk);\n                    output.stdout.push(chunk.toString(options.encoding));\n                });\n                channel.stderr.on('data', (chunk) => {\n                    if (options.onStderr)\n                        options.onStderr(chunk);\n                    output.stderr.push(chunk.toString(options.encoding));\n                });\n                if (options.stdin != null) {\n                    if (isStream.readable(options.stdin)) {\n                        options.stdin.pipe(channel, {\n                            end: true,\n                        });\n                    }\n                    else {\n                        channel.write(options.stdin);\n                        channel.end();\n                    }\n                }\n                else {\n                    channel.end();\n                }\n                let code = null;\n                let signal = null;\n                channel.on('exit', (code_, signal_) => {\n                    code = code_ !== null && code_ !== void 0 ? code_ : null;\n                    signal = signal_ !== null && signal_ !== void 0 ? signal_ : null;\n                });\n                channel.on('close', () => {\n                    resolve({\n                        code: code != null ? code : null,\n                        signal: signal != null ? signal : null,\n                        stdout: output.stdout.join('').trim(),\n                        stderr: output.stderr.join('').trim(),\n                    });\n                });\n            });\n        });\n    }\n    async exec(command, parameters, options = {}) {\n        invariant(typeof command === 'string', 'command must be a valid string');\n        invariant(Array.isArray(parameters), 'parameters must be a valid array');\n        invariant(options != null && typeof options === 'object', 'options must be a valid object');\n        invariant(options.stream == null || ['both', 'stdout', 'stderr'].includes(options.stream), 'options.stream must be one of both, stdout, stderr');\n        for (let i = 0, { length } = parameters; i < length; i += 1) {\n            invariant(typeof parameters[i] === 'string', `parameters[${i}] must be a valid string`);\n        }\n        const completeCommand = `${command}${parameters.length > 0 ? ` ${shellEscape(parameters)}` : ''}`;\n        const response = await this.execCommand(completeCommand, options);\n        if (options.stream == null || options.stream === 'stdout') {\n            if (response.stderr) {\n                throw new Error(response.stderr);\n            }\n            return response.stdout;\n        }\n        if (options.stream === 'stderr') {\n            return response.stderr;\n        }\n        return response;\n    }\n    async mkdir(path, method = 'sftp', givenSftp = null) {\n        invariant(typeof path === 'string', 'path must be a valid string');\n        invariant(typeof method === 'string' && (method === 'sftp' || method === 'exec'), 'method must be either sftp or exec');\n        invariant(givenSftp == null || typeof givenSftp === 'object', 'sftp must be a valid object');\n        if (method === 'exec') {\n            await this.exec('mkdir', ['-p', unixifyPath(path)]);\n            return;\n        }\n        const sftp = givenSftp || (await this.requestSFTP());\n        const makeSftpDirectory = async (retry) => makeDirectoryWithSftp(unixifyPath(path), sftp).catch(async (error) => {\n            if (!retry || error == null || (error.message !== 'No such file' && error.code !== 'ENOENT')) {\n                throw error;\n            }\n            await this.mkdir(fsPath.dirname(path), 'sftp', sftp);\n            await makeSftpDirectory(false);\n        });\n        try {\n            await makeSftpDirectory(true);\n        }\n        finally {\n            if (!givenSftp) {\n                sftp.end();\n            }\n        }\n    }\n    async getFile(localFile, remoteFile, givenSftp = null, transferOptions = null) {\n        invariant(typeof localFile === 'string', 'localFile must be a valid string');\n        invariant(typeof remoteFile === 'string', 'remoteFile must be a valid string');\n        invariant(givenSftp == null || typeof givenSftp === 'object', 'sftp must be a valid object');\n        invariant(transferOptions == null || typeof transferOptions === 'object', 'transferOptions must be a valid object');\n        const sftp = givenSftp || (await this.requestSFTP());\n        try {\n            await new Promise((resolve, reject) => {\n                sftp.fastGet(unixifyPath(remoteFile), localFile, transferOptions || {}, (err) => {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve();\n                    }\n                });\n            });\n        }\n        finally {\n            if (!givenSftp) {\n                sftp.end();\n            }\n        }\n    }\n    async putFile(localFile, remoteFile, givenSftp = null, transferOptions = null) {\n        invariant(typeof localFile === 'string', 'localFile must be a valid string');\n        invariant(typeof remoteFile === 'string', 'remoteFile must be a valid string');\n        invariant(givenSftp == null || typeof givenSftp === 'object', 'sftp must be a valid object');\n        invariant(transferOptions == null || typeof transferOptions === 'object', 'transferOptions must be a valid object');\n        invariant(await new Promise((resolve) => {\n            fs.access(localFile, fs.constants.R_OK, (err) => {\n                resolve(err === null);\n            });\n        }), `localFile does not exist at ${localFile}`);\n        const sftp = givenSftp || (await this.requestSFTP());\n        const putFile = (retry) => {\n            return new Promise((resolve, reject) => {\n                sftp.fastPut(localFile, unixifyPath(remoteFile), transferOptions || {}, (err) => {\n                    if (err == null) {\n                        resolve();\n                        return;\n                    }\n                    if (err.message === 'No such file' && retry) {\n                        resolve(this.mkdir(fsPath.dirname(remoteFile), 'sftp', sftp).then(() => putFile(false)));\n                    }\n                    else {\n                        reject(err);\n                    }\n                });\n            });\n        };\n        try {\n            await putFile(true);\n        }\n        finally {\n            if (!givenSftp) {\n                sftp.end();\n            }\n        }\n    }\n    async putFiles(files, { concurrency = DEFAULT_CONCURRENCY, sftp: givenSftp = null, transferOptions = {} } = {}) {\n        invariant(Array.isArray(files), 'files must be an array');\n        for (let i = 0, { length } = files; i < length; i += 1) {\n            const file = files[i];\n            invariant(file, 'files items must be valid objects');\n            invariant(file.local && typeof file.local === 'string', `files[${i}].local must be a string`);\n            invariant(file.remote && typeof file.remote === 'string', `files[${i}].remote must be a string`);\n        }\n        const transferred = [];\n        const sftp = givenSftp || (await this.requestSFTP());\n        const queue = new PromiseQueue({ concurrency });\n        try {\n            await new Promise((resolve, reject) => {\n                files.forEach((file) => {\n                    queue\n                        .add(async () => {\n                        await this.putFile(file.local, file.remote, sftp, transferOptions);\n                        transferred.push(file);\n                    })\n                        .catch(reject);\n                });\n                queue.waitTillIdle().then(resolve);\n            });\n        }\n        catch (error) {\n            if (error != null) {\n                error.transferred = transferred;\n            }\n            throw error;\n        }\n        finally {\n            if (!givenSftp) {\n                sftp.end();\n            }\n        }\n    }\n    async putDirectory(localDirectory, remoteDirectory, { concurrency = DEFAULT_CONCURRENCY, sftp: givenSftp = null, transferOptions = {}, recursive = true, tick = DEFAULT_TICK, validate = DEFAULT_VALIDATE, } = {}) {\n        invariant(typeof localDirectory === 'string' && localDirectory, 'localDirectory must be a string');\n        invariant(typeof remoteDirectory === 'string' && remoteDirectory, 'remoteDirectory must be a string');\n        const localDirectoryStat = await new Promise((resolve) => {\n            fs.stat(localDirectory, (err, stat) => {\n                resolve(stat || null);\n            });\n        });\n        invariant(localDirectoryStat != null, `localDirectory does not exist at ${localDirectory}`);\n        invariant(localDirectoryStat.isDirectory(), `localDirectory is not a directory at ${localDirectory}`);\n        const sftp = givenSftp || (await this.requestSFTP());\n        const scanned = await scanDirectory(localDirectory, {\n            recursive,\n            validate,\n        });\n        const files = scanned.files.map((item) => fsPath.relative(localDirectory, item));\n        const directories = scanned.directories.map((item) => fsPath.relative(localDirectory, item));\n        // Sort shortest to longest\n        directories.sort((a, b) => a.length - b.length);\n        let failed = false;\n        try {\n            // Do the directories first.\n            await new Promise((resolve, reject) => {\n                const queue = new PromiseQueue({ concurrency });\n                directories.forEach((directory) => {\n                    queue\n                        .add(async () => {\n                        await this.mkdir(fsPath.join(remoteDirectory, directory), 'sftp', sftp);\n                    })\n                        .catch(reject);\n                });\n                resolve(queue.waitTillIdle());\n            });\n            // and now the files\n            await new Promise((resolve, reject) => {\n                const queue = new PromiseQueue({ concurrency });\n                files.forEach((file) => {\n                    queue\n                        .add(async () => {\n                        const localFile = fsPath.join(localDirectory, file);\n                        const remoteFile = fsPath.join(remoteDirectory, file);\n                        try {\n                            await this.putFile(localFile, remoteFile, sftp, transferOptions);\n                            tick(localFile, remoteFile, null);\n                        }\n                        catch (_) {\n                            failed = true;\n                            tick(localFile, remoteFile, _);\n                        }\n                    })\n                        .catch(reject);\n                });\n                resolve(queue.waitTillIdle());\n            });\n        }\n        finally {\n            if (!givenSftp) {\n                sftp.end();\n            }\n        }\n        return !failed;\n    }\n    async getDirectory(localDirectory, remoteDirectory, { concurrency = DEFAULT_CONCURRENCY, sftp: givenSftp = null, transferOptions = {}, recursive = true, tick = DEFAULT_TICK, validate = DEFAULT_VALIDATE, } = {}) {\n        invariant(typeof localDirectory === 'string' && localDirectory, 'localDirectory must be a string');\n        invariant(typeof remoteDirectory === 'string' && remoteDirectory, 'remoteDirectory must be a string');\n        const localDirectoryStat = await new Promise((resolve) => {\n            fs.stat(localDirectory, (err, stat) => {\n                resolve(stat || null);\n            });\n        });\n        invariant(localDirectoryStat != null, `localDirectory does not exist at ${localDirectory}`);\n        invariant(localDirectoryStat.isDirectory(), `localDirectory is not a directory at ${localDirectory}`);\n        const sftp = givenSftp || (await this.requestSFTP());\n        const scanned = await scanDirectory(remoteDirectory, {\n            recursive,\n            validate,\n            concurrency,\n            fileSystem: {\n                basename(path) {\n                    return fsPath.posix.basename(path);\n                },\n                join(pathA, pathB) {\n                    return fsPath.posix.join(pathA, pathB);\n                },\n                readdir(path) {\n                    return new Promise((resolve, reject) => {\n                        sftp.readdir(path, (err, res) => {\n                            if (err) {\n                                reject(err);\n                            }\n                            else {\n                                resolve(res.map((item) => item.filename));\n                            }\n                        });\n                    });\n                },\n                stat(path) {\n                    return new Promise((resolve, reject) => {\n                        sftp.stat(path, (err, res) => {\n                            if (err) {\n                                reject(err);\n                            }\n                            else {\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                resolve(res);\n                            }\n                        });\n                    });\n                },\n            },\n        });\n        const files = scanned.files.map((item) => fsPath.relative(remoteDirectory, item));\n        const directories = scanned.directories.map((item) => fsPath.relative(remoteDirectory, item));\n        // Sort shortest to longest\n        directories.sort((a, b) => a.length - b.length);\n        let failed = false;\n        try {\n            // Do the directories first.\n            await new Promise((resolve, reject) => {\n                const queue = new PromiseQueue({ concurrency });\n                directories.forEach((directory) => {\n                    queue\n                        .add(async () => {\n                        await makeDir(fsPath.join(localDirectory, directory));\n                    })\n                        .catch(reject);\n                });\n                resolve(queue.waitTillIdle());\n            });\n            // and now the files\n            await new Promise((resolve, reject) => {\n                const queue = new PromiseQueue({ concurrency });\n                files.forEach((file) => {\n                    queue\n                        .add(async () => {\n                        const localFile = fsPath.join(localDirectory, file);\n                        const remoteFile = fsPath.join(remoteDirectory, file);\n                        try {\n                            await this.getFile(localFile, remoteFile, sftp, transferOptions);\n                            tick(localFile, remoteFile, null);\n                        }\n                        catch (_) {\n                            failed = true;\n                            tick(localFile, remoteFile, _);\n                        }\n                    })\n                        .catch(reject);\n                });\n                resolve(queue.waitTillIdle());\n            });\n        }\n        finally {\n            if (!givenSftp) {\n                sftp.end();\n            }\n        }\n        return !failed;\n    }\n    forwardIn(remoteAddr, remotePort, onConnection) {\n        const connection = this.getConnection();\n        return new Promise((resolve, reject) => {\n            connection.forwardIn(remoteAddr, remotePort, (error, port) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                const handler = (details, acceptConnection, rejectConnection) => {\n                    if (details.destIP === remoteAddr && details.destPort === port) {\n                        onConnection === null || onConnection === void 0 ? void 0 : onConnection(details, acceptConnection, rejectConnection);\n                    }\n                };\n                if (onConnection) {\n                    connection.on('tcp connection', handler);\n                }\n                const dispose = () => {\n                    return new Promise((_resolve, _reject) => {\n                        connection.off('tcp connection', handler);\n                        connection.unforwardIn(remoteAddr, port, (_error) => {\n                            if (_error) {\n                                _reject(error);\n                            }\n                            _resolve();\n                        });\n                    });\n                };\n                resolve({ port, dispose });\n            });\n        });\n    }\n    forwardOut(srcIP, srcPort, dstIP, dstPort) {\n        const connection = this.getConnection();\n        return new Promise((resolve, reject) => {\n            connection.forwardOut(srcIP, srcPort, dstIP, dstPort, (error, channel) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                resolve(channel);\n            });\n        });\n    }\n    forwardInStreamLocal(socketPath, onConnection) {\n        const connection = this.getConnection();\n        return new Promise((resolve, reject) => {\n            connection.openssh_forwardInStreamLocal(socketPath, (error) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                const handler = (details, acceptConnection, rejectConnection) => {\n                    if (details.socketPath === socketPath) {\n                        onConnection === null || onConnection === void 0 ? void 0 : onConnection(details, acceptConnection, rejectConnection);\n                    }\n                };\n                if (onConnection) {\n                    connection.on('unix connection', handler);\n                }\n                const dispose = () => {\n                    return new Promise((_resolve, _reject) => {\n                        connection.off('unix connection', handler);\n                        connection.openssh_unforwardInStreamLocal(socketPath, (_error) => {\n                            if (_error) {\n                                _reject(_error);\n                            }\n                            _resolve();\n                        });\n                    });\n                };\n                resolve({ dispose });\n            });\n        });\n    }\n    forwardOutStreamLocal(socketPath) {\n        const connection = this.getConnection();\n        return new Promise((resolve, reject) => {\n            connection.openssh_forwardOutStreamLocal(socketPath, (error, channel) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                resolve(channel);\n            });\n        });\n    }\n    dispose() {\n        if (this.connection) {\n            this.connection.end();\n            this.connection = null;\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}