{"ast":null,"code":"'use strict';\n\nconst {\n  createDiffieHellman,\n  createDiffieHellmanGroup,\n  createECDH,\n  createHash,\n  createPublicKey,\n  diffieHellman,\n  generateKeyPairSync,\n  randomFillSync\n} = require('crypto');\nconst {\n  Ber\n} = require('asn1');\nconst {\n  COMPAT,\n  curve25519Supported,\n  DEFAULT_KEX,\n  DEFAULT_SERVER_HOST_KEY,\n  DEFAULT_CIPHER,\n  DEFAULT_MAC,\n  DEFAULT_COMPRESSION,\n  DISCONNECT_REASON,\n  MESSAGE\n} = require('./constants.js');\nconst {\n  CIPHER_INFO,\n  createCipher,\n  createDecipher,\n  MAC_INFO\n} = require('./crypto.js');\nconst {\n  parseDERKey\n} = require('./keyParser.js');\nconst {\n  bufferFill,\n  bufferParser,\n  convertSignature,\n  doFatalError,\n  FastBuffer,\n  sigSSHToASN1,\n  writeUInt32BE\n} = require('./utils.js');\nconst {\n  PacketReader,\n  PacketWriter,\n  ZlibPacketReader,\n  ZlibPacketWriter\n} = require('./zlib.js');\nlet MESSAGE_HANDLERS;\nconst GEX_MIN_BITS = 2048; // RFC 8270\nconst GEX_MAX_BITS = 8192; // RFC 8270\n\nconst EMPTY_BUFFER = Buffer.alloc(0);\n\n// Client/Server\nfunction kexinit(self) {\n  /*\n    byte         SSH_MSG_KEXINIT\n    byte[16]     cookie (random bytes)\n    name-list    kex_algorithms\n    name-list    server_host_key_algorithms\n    name-list    encryption_algorithms_client_to_server\n    name-list    encryption_algorithms_server_to_client\n    name-list    mac_algorithms_client_to_server\n    name-list    mac_algorithms_server_to_client\n    name-list    compression_algorithms_client_to_server\n    name-list    compression_algorithms_server_to_client\n    name-list    languages_client_to_server\n    name-list    languages_server_to_client\n    boolean      first_kex_packet_follows\n    uint32       0 (reserved for future extension)\n  */\n\n  let payload;\n  if (self._compatFlags & COMPAT.BAD_DHGEX) {\n    const entry = self._offer.lists.kex;\n    let kex = entry.array;\n    let found = false;\n    for (let i = 0; i < kex.length; ++i) {\n      if (kex[i].includes('group-exchange')) {\n        if (!found) {\n          found = true;\n          // Copy array lazily\n          kex = kex.slice();\n        }\n        kex.splice(i--, 1);\n      }\n    }\n    if (found) {\n      let len = 1 + 16 + self._offer.totalSize + 1 + 4;\n      const newKexBuf = Buffer.from(kex.join(','));\n      len -= entry.buffer.length - newKexBuf.length;\n      const all = self._offer.lists.all;\n      const rest = new Uint8Array(all.buffer, all.byteOffset + 4 + entry.buffer.length, all.length - (4 + entry.buffer.length));\n      payload = Buffer.allocUnsafe(len);\n      writeUInt32BE(payload, newKexBuf.length, 17);\n      payload.set(newKexBuf, 17 + 4);\n      payload.set(rest, 17 + 4 + newKexBuf.length);\n    }\n  }\n  if (payload === undefined) {\n    payload = Buffer.allocUnsafe(1 + 16 + self._offer.totalSize + 1 + 4);\n    self._offer.copyAllTo(payload, 17);\n  }\n  self._debug && self._debug('Outbound: Sending KEXINIT');\n  payload[0] = MESSAGE.KEXINIT;\n  randomFillSync(payload, 1, 16);\n\n  // Zero-fill first_kex_packet_follows and reserved bytes\n  bufferFill(payload, 0, payload.length - 5);\n  self._kexinit = payload;\n\n  // Needed to correct the starting position in allocated \"packets\" when packets\n  // will be buffered due to active key exchange\n  self._packetRW.write.allocStart = 0;\n\n  // TODO: only create single buffer and set _kexinit as slice of packet instead\n  {\n    const p = self._packetRW.write.allocStartKEX;\n    const packet = self._packetRW.write.alloc(payload.length, true);\n    packet.set(payload, p);\n    self._cipher.encrypt(self._packetRW.write.finalize(packet, true));\n  }\n}\nfunction handleKexInit(self, payload) {\n  /*\n    byte         SSH_MSG_KEXINIT\n    byte[16]     cookie (random bytes)\n    name-list    kex_algorithms\n    name-list    server_host_key_algorithms\n    name-list    encryption_algorithms_client_to_server\n    name-list    encryption_algorithms_server_to_client\n    name-list    mac_algorithms_client_to_server\n    name-list    mac_algorithms_server_to_client\n    name-list    compression_algorithms_client_to_server\n    name-list    compression_algorithms_server_to_client\n    name-list    languages_client_to_server\n    name-list    languages_server_to_client\n    boolean      first_kex_packet_follows\n    uint32       0 (reserved for future extension)\n  */\n  const init = {\n    kex: undefined,\n    serverHostKey: undefined,\n    cs: {\n      cipher: undefined,\n      mac: undefined,\n      compress: undefined,\n      lang: undefined\n    },\n    sc: {\n      cipher: undefined,\n      mac: undefined,\n      compress: undefined,\n      lang: undefined\n    }\n  };\n  bufferParser.init(payload, 17);\n  if ((init.kex = bufferParser.readList()) === undefined || (init.serverHostKey = bufferParser.readList()) === undefined || (init.cs.cipher = bufferParser.readList()) === undefined || (init.sc.cipher = bufferParser.readList()) === undefined || (init.cs.mac = bufferParser.readList()) === undefined || (init.sc.mac = bufferParser.readList()) === undefined || (init.cs.compress = bufferParser.readList()) === undefined || (init.sc.compress = bufferParser.readList()) === undefined || (init.cs.lang = bufferParser.readList()) === undefined || (init.sc.lang = bufferParser.readList()) === undefined) {\n    bufferParser.clear();\n    return doFatalError(self, 'Received malformed KEXINIT', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n  const pos = bufferParser.pos();\n  const firstFollows = pos < payload.length && payload[pos] === 1;\n  bufferParser.clear();\n  const local = self._offer;\n  const remote = init;\n  let localKex = local.lists.kex.array;\n  if (self._compatFlags & COMPAT.BAD_DHGEX) {\n    let found = false;\n    for (let i = 0; i < localKex.length; ++i) {\n      if (localKex[i].indexOf('group-exchange') !== -1) {\n        if (!found) {\n          found = true;\n          // Copy array lazily\n          localKex = localKex.slice();\n        }\n        localKex.splice(i--, 1);\n      }\n    }\n  }\n  let clientList;\n  let serverList;\n  let i;\n  const debug = self._debug;\n  debug && debug('Inbound: Handshake in progress');\n\n  // Key exchange method =======================================================\n  debug && debug(`Handshake: (local) KEX method: ${localKex}`);\n  debug && debug(`Handshake: (remote) KEX method: ${remote.kex}`);\n  let remoteExtInfoEnabled;\n  if (self._server) {\n    serverList = localKex;\n    clientList = remote.kex;\n    remoteExtInfoEnabled = clientList.indexOf('ext-info-c') !== -1;\n  } else {\n    serverList = remote.kex;\n    clientList = localKex;\n    remoteExtInfoEnabled = serverList.indexOf('ext-info-s') !== -1;\n  }\n  // Check for agreeable key exchange algorithm\n  for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching key exchange algorithm');\n    return doFatalError(self, 'Handshake failed: no matching key exchange algorithm', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n  init.kex = clientList[i];\n  debug && debug(`Handshake: KEX algorithm: ${clientList[i]}`);\n  if (firstFollows && (!remote.kex.length || clientList[i] !== remote.kex[0])) {\n    // Ignore next inbound packet, it was a wrong first guess at KEX algorithm\n    self._skipNextInboundPacket = true;\n  }\n\n  // Server host key format ====================================================\n  const localSrvHostKey = local.lists.serverHostKey.array;\n  debug && debug(`Handshake: (local) Host key format: ${localSrvHostKey}`);\n  debug && debug(`Handshake: (remote) Host key format: ${remote.serverHostKey}`);\n  if (self._server) {\n    serverList = localSrvHostKey;\n    clientList = remote.serverHostKey;\n  } else {\n    serverList = remote.serverHostKey;\n    clientList = localSrvHostKey;\n  }\n  // Check for agreeable server host key format\n  for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching host key format');\n    return doFatalError(self, 'Handshake failed: no matching host key format', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n  init.serverHostKey = clientList[i];\n  debug && debug(`Handshake: Host key format: ${clientList[i]}`);\n\n  // Client->Server cipher =====================================================\n  const localCSCipher = local.lists.cs.cipher.array;\n  debug && debug(`Handshake: (local) C->S cipher: ${localCSCipher}`);\n  debug && debug(`Handshake: (remote) C->S cipher: ${remote.cs.cipher}`);\n  if (self._server) {\n    serverList = localCSCipher;\n    clientList = remote.cs.cipher;\n  } else {\n    serverList = remote.cs.cipher;\n    clientList = localCSCipher;\n  }\n  // Check for agreeable client->server cipher\n  for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching C->S cipher');\n    return doFatalError(self, 'Handshake failed: no matching C->S cipher', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n  init.cs.cipher = clientList[i];\n  debug && debug(`Handshake: C->S Cipher: ${clientList[i]}`);\n\n  // Server->Client cipher =====================================================\n  const localSCCipher = local.lists.sc.cipher.array;\n  debug && debug(`Handshake: (local) S->C cipher: ${localSCCipher}`);\n  debug && debug(`Handshake: (remote) S->C cipher: ${remote.sc.cipher}`);\n  if (self._server) {\n    serverList = localSCCipher;\n    clientList = remote.sc.cipher;\n  } else {\n    serverList = remote.sc.cipher;\n    clientList = localSCCipher;\n  }\n  // Check for agreeable server->client cipher\n  for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching S->C cipher');\n    return doFatalError(self, 'Handshake failed: no matching S->C cipher', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n  init.sc.cipher = clientList[i];\n  debug && debug(`Handshake: S->C cipher: ${clientList[i]}`);\n\n  // Client->Server MAC ========================================================\n  const localCSMAC = local.lists.cs.mac.array;\n  debug && debug(`Handshake: (local) C->S MAC: ${localCSMAC}`);\n  debug && debug(`Handshake: (remote) C->S MAC: ${remote.cs.mac}`);\n  if (CIPHER_INFO[init.cs.cipher].authLen > 0) {\n    init.cs.mac = '';\n    debug && debug('Handshake: C->S MAC: <implicit>');\n  } else {\n    if (self._server) {\n      serverList = localCSMAC;\n      clientList = remote.cs.mac;\n    } else {\n      serverList = remote.cs.mac;\n      clientList = localCSMAC;\n    }\n    // Check for agreeable client->server hmac algorithm\n    for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n    if (i === clientList.length) {\n      // No suitable match found!\n      debug && debug('Handshake: No matching C->S MAC');\n      return doFatalError(self, 'Handshake failed: no matching C->S MAC', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    }\n    init.cs.mac = clientList[i];\n    debug && debug(`Handshake: C->S MAC: ${clientList[i]}`);\n  }\n\n  // Server->Client MAC ========================================================\n  const localSCMAC = local.lists.sc.mac.array;\n  debug && debug(`Handshake: (local) S->C MAC: ${localSCMAC}`);\n  debug && debug(`Handshake: (remote) S->C MAC: ${remote.sc.mac}`);\n  if (CIPHER_INFO[init.sc.cipher].authLen > 0) {\n    init.sc.mac = '';\n    debug && debug('Handshake: S->C MAC: <implicit>');\n  } else {\n    if (self._server) {\n      serverList = localSCMAC;\n      clientList = remote.sc.mac;\n    } else {\n      serverList = remote.sc.mac;\n      clientList = localSCMAC;\n    }\n    // Check for agreeable server->client hmac algorithm\n    for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n    if (i === clientList.length) {\n      // No suitable match found!\n      debug && debug('Handshake: No matching S->C MAC');\n      return doFatalError(self, 'Handshake failed: no matching S->C MAC', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    }\n    init.sc.mac = clientList[i];\n    debug && debug(`Handshake: S->C MAC: ${clientList[i]}`);\n  }\n\n  // Client->Server compression ================================================\n  const localCSCompress = local.lists.cs.compress.array;\n  debug && debug(`Handshake: (local) C->S compression: ${localCSCompress}`);\n  debug && debug(`Handshake: (remote) C->S compression: ${remote.cs.compress}`);\n  if (self._server) {\n    serverList = localCSCompress;\n    clientList = remote.cs.compress;\n  } else {\n    serverList = remote.cs.compress;\n    clientList = localCSCompress;\n  }\n  // Check for agreeable client->server compression algorithm\n  for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching C->S compression');\n    return doFatalError(self, 'Handshake failed: no matching C->S compression', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n  init.cs.compress = clientList[i];\n  debug && debug(`Handshake: C->S compression: ${clientList[i]}`);\n\n  // Server->Client compression ================================================\n  const localSCCompress = local.lists.sc.compress.array;\n  debug && debug(`Handshake: (local) S->C compression: ${localSCCompress}`);\n  debug && debug(`Handshake: (remote) S->C compression: ${remote.sc.compress}`);\n  if (self._server) {\n    serverList = localSCCompress;\n    clientList = remote.sc.compress;\n  } else {\n    serverList = remote.sc.compress;\n    clientList = localSCCompress;\n  }\n  // Check for agreeable server->client compression algorithm\n  for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching S->C compression');\n    return doFatalError(self, 'Handshake failed: no matching S->C compression', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n  init.sc.compress = clientList[i];\n  debug && debug(`Handshake: S->C compression: ${clientList[i]}`);\n  init.cs.lang = '';\n  init.sc.lang = '';\n\n  // XXX: hack -- find a better way to do this\n  if (self._kex) {\n    if (!self._kexinit) {\n      // We received a rekey request, but we haven't sent a KEXINIT in response\n      // yet\n      kexinit(self);\n    }\n    self._decipher._onPayload = onKEXPayload.bind(self, {\n      firstPacket: false\n    });\n  }\n  self._kex = createKeyExchange(init, self, payload);\n  self._kex.remoteExtInfoEnabled = remoteExtInfoEnabled;\n  self._kex.start();\n}\nconst createKeyExchange = (() => {\n  function convertToMpint(buf) {\n    let idx = 0;\n    let length = buf.length;\n    while (buf[idx] === 0x00) {\n      ++idx;\n      --length;\n    }\n    let newBuf;\n    if (buf[idx] & 0x80) {\n      newBuf = Buffer.allocUnsafe(1 + length);\n      newBuf[0] = 0;\n      buf.copy(newBuf, 1, idx);\n      buf = newBuf;\n    } else if (length !== buf.length) {\n      newBuf = Buffer.allocUnsafe(length);\n      buf.copy(newBuf, 0, idx);\n      buf = newBuf;\n    }\n    return buf;\n  }\n  class KeyExchange {\n    constructor(negotiated, protocol, remoteKexinit) {\n      this._protocol = protocol;\n      this.sessionID = protocol._kex ? protocol._kex.sessionID : undefined;\n      this.negotiated = negotiated;\n      this.remoteExtInfoEnabled = false;\n      this._step = 1;\n      this._public = null;\n      this._dh = null;\n      this._sentNEWKEYS = false;\n      this._receivedNEWKEYS = false;\n      this._finished = false;\n      this._hostVerified = false;\n\n      // Data needed for initializing cipher/decipher/etc.\n      this._kexinit = protocol._kexinit;\n      this._remoteKexinit = remoteKexinit;\n      this._identRaw = protocol._identRaw;\n      this._remoteIdentRaw = protocol._remoteIdentRaw;\n      this._hostKey = undefined;\n      this._dhData = undefined;\n      this._sig = undefined;\n    }\n    finish() {\n      if (this._finished) return false;\n      this._finished = true;\n      const isServer = this._protocol._server;\n      const negotiated = this.negotiated;\n      const pubKey = this.convertPublicKey(this._dhData);\n      let secret = this.computeSecret(this._dhData);\n      if (secret instanceof Error) {\n        secret.message = `Error while computing DH secret (${this.type}): ${secret.message}`;\n        secret.level = 'handshake';\n        return doFatalError(this._protocol, secret, DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      }\n      const hash = createHash(this.hashName);\n      // V_C\n      hashString(hash, isServer ? this._remoteIdentRaw : this._identRaw);\n      // \"V_S\"\n      hashString(hash, isServer ? this._identRaw : this._remoteIdentRaw);\n      // \"I_C\"\n      hashString(hash, isServer ? this._remoteKexinit : this._kexinit);\n      // \"I_S\"\n      hashString(hash, isServer ? this._kexinit : this._remoteKexinit);\n      // \"K_S\"\n      const serverPublicHostKey = isServer ? this._hostKey.getPublicSSH() : this._hostKey;\n      hashString(hash, serverPublicHostKey);\n      if (this.type === 'groupex') {\n        // Group exchange-specific\n        const params = this.getDHParams();\n        const num = Buffer.allocUnsafe(4);\n        // min (uint32)\n        writeUInt32BE(num, this._minBits, 0);\n        hash.update(num);\n        // preferred (uint32)\n        writeUInt32BE(num, this._prefBits, 0);\n        hash.update(num);\n        // max (uint32)\n        writeUInt32BE(num, this._maxBits, 0);\n        hash.update(num);\n        // prime\n        hashString(hash, params.prime);\n        // generator\n        hashString(hash, params.generator);\n      }\n\n      // method-specific data sent by client\n      hashString(hash, isServer ? pubKey : this.getPublicKey());\n      // method-specific data sent by server\n      const serverPublicKey = isServer ? this.getPublicKey() : pubKey;\n      hashString(hash, serverPublicKey);\n      // shared secret (\"K\")\n      hashString(hash, secret);\n\n      // \"H\"\n      const exchangeHash = hash.digest();\n      if (!isServer) {\n        bufferParser.init(this._sig, 0);\n        const sigType = bufferParser.readString(true);\n        if (!sigType) {\n          return doFatalError(this._protocol, 'Malformed packet while reading signature', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n        if (sigType !== negotiated.serverHostKey) {\n          return doFatalError(this._protocol, `Wrong signature type: ${sigType}, ` + `expected: ${negotiated.serverHostKey}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n\n        // \"s\"\n        let sigValue = bufferParser.readString();\n        bufferParser.clear();\n        if (sigValue === undefined) {\n          return doFatalError(this._protocol, 'Malformed packet while reading signature', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n        if (!(sigValue = sigSSHToASN1(sigValue, sigType))) {\n          return doFatalError(this._protocol, 'Malformed signature', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n        let parsedHostKey;\n        {\n          bufferParser.init(this._hostKey, 0);\n          const name = bufferParser.readString(true);\n          const hostKey = this._hostKey.slice(bufferParser.pos());\n          bufferParser.clear();\n          parsedHostKey = parseDERKey(hostKey, name);\n          if (parsedHostKey instanceof Error) {\n            parsedHostKey.level = 'handshake';\n            return doFatalError(this._protocol, parsedHostKey, DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n          }\n        }\n        let hashAlgo;\n        // Check if we need to override the default hash algorithm\n        switch (this.negotiated.serverHostKey) {\n          case 'rsa-sha2-256':\n            hashAlgo = 'sha256';\n            break;\n          case 'rsa-sha2-512':\n            hashAlgo = 'sha512';\n            break;\n        }\n        this._protocol._debug && this._protocol._debug('Verifying signature ...');\n        const verified = parsedHostKey.verify(exchangeHash, sigValue, hashAlgo);\n        if (verified !== true) {\n          if (verified instanceof Error) {\n            this._protocol._debug && this._protocol._debug(`Signature verification failed: ${verified.stack}`);\n          } else {\n            this._protocol._debug && this._protocol._debug('Signature verification failed');\n          }\n          return doFatalError(this._protocol, 'Handshake failed: signature verification failed', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n        this._protocol._debug && this._protocol._debug('Verified signature');\n      } else {\n        // Server\n\n        let hashAlgo;\n        // Check if we need to override the default hash algorithm\n        switch (this.negotiated.serverHostKey) {\n          case 'rsa-sha2-256':\n            hashAlgo = 'sha256';\n            break;\n          case 'rsa-sha2-512':\n            hashAlgo = 'sha512';\n            break;\n        }\n        this._protocol._debug && this._protocol._debug('Generating signature ...');\n        let signature = this._hostKey.sign(exchangeHash, hashAlgo);\n        if (signature instanceof Error) {\n          return doFatalError(this._protocol, 'Handshake failed: signature generation failed for ' + `${this._hostKey.type} host key: ${signature.message}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n        signature = convertSignature(signature, this._hostKey.type);\n        if (signature === false) {\n          return doFatalError(this._protocol, 'Handshake failed: signature conversion failed for ' + `${this._hostKey.type} host key`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n\n        // Send KEX reply\n        /*\n          byte      SSH_MSG_KEXDH_REPLY\n                      / SSH_MSG_KEX_DH_GEX_REPLY\n                      / SSH_MSG_KEX_ECDH_REPLY\n          string    server public host key and certificates (K_S)\n          string    <method-specific data>\n          string    signature of H\n        */\n        const sigType = this.negotiated.serverHostKey;\n        const sigTypeLen = Buffer.byteLength(sigType);\n        const sigLen = 4 + sigTypeLen + 4 + signature.length;\n        let p = this._protocol._packetRW.write.allocStartKEX;\n        const packet = this._protocol._packetRW.write.alloc(1 + 4 + serverPublicHostKey.length + 4 + serverPublicKey.length + 4 + sigLen, true);\n        packet[p] = MESSAGE.KEXDH_REPLY;\n        writeUInt32BE(packet, serverPublicHostKey.length, ++p);\n        packet.set(serverPublicHostKey, p += 4);\n        writeUInt32BE(packet, serverPublicKey.length, p += serverPublicHostKey.length);\n        packet.set(serverPublicKey, p += 4);\n        writeUInt32BE(packet, sigLen, p += serverPublicKey.length);\n        writeUInt32BE(packet, sigTypeLen, p += 4);\n        packet.utf8Write(sigType, p += 4, sigTypeLen);\n        writeUInt32BE(packet, signature.length, p += sigTypeLen);\n        packet.set(signature, p += 4);\n        if (this._protocol._debug) {\n          let type;\n          switch (this.type) {\n            case 'group':\n              type = 'KEXDH_REPLY';\n              break;\n            case 'groupex':\n              type = 'KEXDH_GEX_REPLY';\n              break;\n            default:\n              type = 'KEXECDH_REPLY';\n          }\n          this._protocol._debug(`Outbound: Sending ${type}`);\n        }\n        this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));\n      }\n      trySendNEWKEYS(this);\n      const completeHandshake = () => {\n        if (!this.sessionID) this.sessionID = exchangeHash;\n        {\n          const newSecret = Buffer.allocUnsafe(4 + secret.length);\n          writeUInt32BE(newSecret, secret.length, 0);\n          newSecret.set(secret, 4);\n          secret = newSecret;\n        }\n\n        // Initialize new ciphers, deciphers, etc.\n\n        const csCipherInfo = CIPHER_INFO[negotiated.cs.cipher];\n        const scCipherInfo = CIPHER_INFO[negotiated.sc.cipher];\n        const csIV = generateKEXVal(csCipherInfo.ivLen, this.hashName, secret, exchangeHash, this.sessionID, 'A');\n        const scIV = generateKEXVal(scCipherInfo.ivLen, this.hashName, secret, exchangeHash, this.sessionID, 'B');\n        const csKey = generateKEXVal(csCipherInfo.keyLen, this.hashName, secret, exchangeHash, this.sessionID, 'C');\n        const scKey = generateKEXVal(scCipherInfo.keyLen, this.hashName, secret, exchangeHash, this.sessionID, 'D');\n        let csMacInfo;\n        let csMacKey;\n        if (!csCipherInfo.authLen) {\n          csMacInfo = MAC_INFO[negotiated.cs.mac];\n          csMacKey = generateKEXVal(csMacInfo.len, this.hashName, secret, exchangeHash, this.sessionID, 'E');\n        }\n        let scMacInfo;\n        let scMacKey;\n        if (!scCipherInfo.authLen) {\n          scMacInfo = MAC_INFO[negotiated.sc.mac];\n          scMacKey = generateKEXVal(scMacInfo.len, this.hashName, secret, exchangeHash, this.sessionID, 'F');\n        }\n        const config = {\n          inbound: {\n            onPayload: this._protocol._onPayload,\n            seqno: this._protocol._decipher.inSeqno,\n            decipherInfo: !isServer ? scCipherInfo : csCipherInfo,\n            decipherIV: !isServer ? scIV : csIV,\n            decipherKey: !isServer ? scKey : csKey,\n            macInfo: !isServer ? scMacInfo : csMacInfo,\n            macKey: !isServer ? scMacKey : csMacKey\n          },\n          outbound: {\n            onWrite: this._protocol._onWrite,\n            seqno: this._protocol._cipher.outSeqno,\n            cipherInfo: isServer ? scCipherInfo : csCipherInfo,\n            cipherIV: isServer ? scIV : csIV,\n            cipherKey: isServer ? scKey : csKey,\n            macInfo: isServer ? scMacInfo : csMacInfo,\n            macKey: isServer ? scMacKey : csMacKey\n          }\n        };\n        this._protocol._cipher && this._protocol._cipher.free();\n        this._protocol._decipher && this._protocol._decipher.free();\n        this._protocol._cipher = createCipher(config);\n        this._protocol._decipher = createDecipher(config);\n        const rw = {\n          read: undefined,\n          write: undefined\n        };\n        switch (negotiated.cs.compress) {\n          case 'zlib':\n            // starts immediately\n            if (isServer) rw.read = new ZlibPacketReader();else rw.write = new ZlibPacketWriter(this._protocol);\n            break;\n          case 'zlib@openssh.com':\n            // Starts after successful user authentication\n\n            if (this._protocol._authenticated) {\n              // If a rekey happens and this compression method is selected and\n              // we already authenticated successfully, we need to start\n              // immediately instead\n              if (isServer) rw.read = new ZlibPacketReader();else rw.write = new ZlibPacketWriter(this._protocol);\n              break;\n            }\n          // FALLTHROUGH\n          default:\n            // none -- never any compression/decompression\n\n            if (isServer) rw.read = new PacketReader();else rw.write = new PacketWriter(this._protocol);\n        }\n        switch (negotiated.sc.compress) {\n          case 'zlib':\n            // starts immediately\n            if (isServer) rw.write = new ZlibPacketWriter(this._protocol);else rw.read = new ZlibPacketReader();\n            break;\n          case 'zlib@openssh.com':\n            // Starts after successful user authentication\n\n            if (this._protocol._authenticated) {\n              // If a rekey happens and this compression method is selected and\n              // we already authenticated successfully, we need to start\n              // immediately instead\n              if (isServer) rw.write = new ZlibPacketWriter(this._protocol);else rw.read = new ZlibPacketReader();\n              break;\n            }\n          // FALLTHROUGH\n          default:\n            // none -- never any compression/decompression\n\n            if (isServer) rw.write = new PacketWriter(this._protocol);else rw.read = new PacketReader();\n        }\n        this._protocol._packetRW.read.cleanup();\n        this._protocol._packetRW.write.cleanup();\n        this._protocol._packetRW = rw;\n\n        // Cleanup/reset various state\n        this._public = null;\n        this._dh = null;\n        this._kexinit = this._protocol._kexinit = undefined;\n        this._remoteKexinit = undefined;\n        this._identRaw = undefined;\n        this._remoteIdentRaw = undefined;\n        this._hostKey = undefined;\n        this._dhData = undefined;\n        this._sig = undefined;\n        this._protocol._onHandshakeComplete(negotiated);\n        return false;\n      };\n      if (!isServer) return completeHandshake();\n      this.finish = completeHandshake;\n    }\n    start() {\n      if (!this._protocol._server) {\n        if (this._protocol._debug) {\n          let type;\n          switch (this.type) {\n            case 'group':\n              type = 'KEXDH_INIT';\n              break;\n            default:\n              type = 'KEXECDH_INIT';\n          }\n          this._protocol._debug(`Outbound: Sending ${type}`);\n        }\n        const pubKey = this.getPublicKey();\n        let p = this._protocol._packetRW.write.allocStartKEX;\n        const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubKey.length, true);\n        packet[p] = MESSAGE.KEXDH_INIT;\n        writeUInt32BE(packet, pubKey.length, ++p);\n        packet.set(pubKey, p += 4);\n        this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));\n      }\n    }\n    getPublicKey() {\n      this.generateKeys();\n      const key = this._public;\n      if (key) return this.convertPublicKey(key);\n    }\n    convertPublicKey(key) {\n      let newKey;\n      let idx = 0;\n      let len = key.length;\n      while (key[idx] === 0x00) {\n        ++idx;\n        --len;\n      }\n      if (key[idx] & 0x80) {\n        newKey = Buffer.allocUnsafe(1 + len);\n        newKey[0] = 0;\n        key.copy(newKey, 1, idx);\n        return newKey;\n      }\n      if (len !== key.length) {\n        newKey = Buffer.allocUnsafe(len);\n        key.copy(newKey, 0, idx);\n        key = newKey;\n      }\n      return key;\n    }\n    computeSecret(otherPublicKey) {\n      this.generateKeys();\n      try {\n        return convertToMpint(this._dh.computeSecret(otherPublicKey));\n      } catch (ex) {\n        return ex;\n      }\n    }\n    parse(payload) {\n      const type = payload[0];\n      switch (this._step) {\n        case 1:\n          if (this._protocol._server) {\n            // Server\n            if (type !== MESSAGE.KEXDH_INIT) {\n              return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_INIT}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n            this._protocol._debug && this._protocol._debug('Received DH Init');\n            /*\n              byte     SSH_MSG_KEXDH_INIT\n                         / SSH_MSG_KEX_ECDH_INIT\n              string   <method-specific data>\n            */\n            bufferParser.init(payload, 1);\n            const dhData = bufferParser.readString();\n            bufferParser.clear();\n            if (dhData === undefined) {\n              return doFatalError(this._protocol, 'Received malformed KEX*_INIT', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n\n            // Client public key\n            this._dhData = dhData;\n            let hostKey = this._protocol._hostKeys[this.negotiated.serverHostKey];\n            if (Array.isArray(hostKey)) hostKey = hostKey[0];\n            this._hostKey = hostKey;\n            this.finish();\n          } else {\n            // Client\n            if (type !== MESSAGE.KEXDH_REPLY) {\n              return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_REPLY}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n            this._protocol._debug && this._protocol._debug('Received DH Reply');\n            /*\n              byte      SSH_MSG_KEXDH_REPLY\n                          / SSH_MSG_KEX_DH_GEX_REPLY\n                          / SSH_MSG_KEX_ECDH_REPLY\n              string    server public host key and certificates (K_S)\n              string    <method-specific data>\n              string    signature of H\n            */\n            bufferParser.init(payload, 1);\n            let hostPubKey;\n            let dhData;\n            let sig;\n            if ((hostPubKey = bufferParser.readString()) === undefined || (dhData = bufferParser.readString()) === undefined || (sig = bufferParser.readString()) === undefined) {\n              bufferParser.clear();\n              return doFatalError(this._protocol, 'Received malformed KEX*_REPLY', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n            bufferParser.clear();\n\n            // Check that the host public key type matches what was negotiated\n            // during KEXINIT swap\n            bufferParser.init(hostPubKey, 0);\n            const hostPubKeyType = bufferParser.readString(true);\n            bufferParser.clear();\n            if (hostPubKeyType === undefined) {\n              return doFatalError(this._protocol, 'Received malformed host public key', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n            if (hostPubKeyType !== this.negotiated.serverHostKey) {\n              // Check if we need to make an exception\n              switch (this.negotiated.serverHostKey) {\n                case 'rsa-sha2-256':\n                case 'rsa-sha2-512':\n                  if (hostPubKeyType === 'ssh-rsa') break;\n                // FALLTHROUGH\n                default:\n                  return doFatalError(this._protocol, 'Host key does not match negotiated type', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n              }\n            }\n            this._hostKey = hostPubKey;\n            this._dhData = dhData;\n            this._sig = sig;\n            let checked = false;\n            let ret;\n            if (this._protocol._hostVerifier === undefined) {\n              ret = true;\n              this._protocol._debug && this._protocol._debug('Host accepted by default (no verification)');\n            } else {\n              ret = this._protocol._hostVerifier(hostPubKey, permitted => {\n                if (checked) return;\n                checked = true;\n                if (permitted === false) {\n                  this._protocol._debug && this._protocol._debug('Host denied (verification failed)');\n                  return doFatalError(this._protocol, 'Host denied (verification failed)', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n                }\n                this._protocol._debug && this._protocol._debug('Host accepted (verified)');\n                this._hostVerified = true;\n                if (this._receivedNEWKEYS) this.finish();else trySendNEWKEYS(this);\n              });\n            }\n            if (ret === undefined) {\n              // Async host verification\n              ++this._step;\n              return;\n            }\n            checked = true;\n            if (ret === false) {\n              this._protocol._debug && this._protocol._debug('Host denied (verification failed)');\n              return doFatalError(this._protocol, 'Host denied (verification failed)', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n            this._protocol._debug && this._protocol._debug('Host accepted (verified)');\n            this._hostVerified = true;\n            trySendNEWKEYS(this);\n          }\n          ++this._step;\n          break;\n        case 2:\n          if (type !== MESSAGE.NEWKEYS) {\n            return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.NEWKEYS}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n          }\n          this._protocol._debug && this._protocol._debug('Inbound: NEWKEYS');\n          this._receivedNEWKEYS = true;\n          ++this._step;\n          if (this._protocol._server || this._hostVerified) return this.finish();\n\n          // Signal to current decipher that we need to change to a new decipher\n          // for the next packet\n          return false;\n        default:\n          return doFatalError(this._protocol, `Received unexpected packet ${type} after NEWKEYS`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      }\n    }\n  }\n  class Curve25519Exchange extends KeyExchange {\n    constructor(hashName) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      super(...args);\n      this.type = '25519';\n      this.hashName = hashName;\n      this._keys = null;\n    }\n    generateKeys() {\n      if (!this._keys) this._keys = generateKeyPairSync('x25519');\n    }\n    getPublicKey() {\n      this.generateKeys();\n      const key = this._keys.publicKey.export({\n        type: 'spki',\n        format: 'der'\n      });\n      return key.slice(-32); // HACK: avoids parsing DER/BER header\n    }\n\n    convertPublicKey(key) {\n      let newKey;\n      let idx = 0;\n      let len = key.length;\n      while (key[idx] === 0x00) {\n        ++idx;\n        --len;\n      }\n      if (key.length === 32) return key;\n      if (len !== key.length) {\n        newKey = Buffer.allocUnsafe(len);\n        key.copy(newKey, 0, idx);\n        key = newKey;\n      }\n      return key;\n    }\n    computeSecret(otherPublicKey) {\n      this.generateKeys();\n      try {\n        const asnWriter = new Ber.Writer();\n        asnWriter.startSequence();\n        // algorithm\n        asnWriter.startSequence();\n        asnWriter.writeOID('1.3.101.110'); // id-X25519\n        asnWriter.endSequence();\n\n        // PublicKey\n        asnWriter.startSequence(Ber.BitString);\n        asnWriter.writeByte(0x00);\n        // XXX: hack to write a raw buffer without a tag -- yuck\n        asnWriter._ensure(otherPublicKey.length);\n        otherPublicKey.copy(asnWriter._buf, asnWriter._offset, 0, otherPublicKey.length);\n        asnWriter._offset += otherPublicKey.length;\n        asnWriter.endSequence();\n        asnWriter.endSequence();\n        return convertToMpint(diffieHellman({\n          privateKey: this._keys.privateKey,\n          publicKey: createPublicKey({\n            key: asnWriter.buffer,\n            type: 'spki',\n            format: 'der'\n          })\n        }));\n      } catch (ex) {\n        return ex;\n      }\n    }\n  }\n  class ECDHExchange extends KeyExchange {\n    constructor(curveName, hashName) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n      super(...args);\n      this.type = 'ecdh';\n      this.curveName = curveName;\n      this.hashName = hashName;\n    }\n    generateKeys() {\n      if (!this._dh) {\n        this._dh = createECDH(this.curveName);\n        this._public = this._dh.generateKeys();\n      }\n    }\n  }\n  class DHGroupExchange extends KeyExchange {\n    constructor(hashName) {\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n      super(...args);\n      this.type = 'groupex';\n      this.hashName = hashName;\n      this._prime = null;\n      this._generator = null;\n      this._minBits = GEX_MIN_BITS;\n      this._prefBits = dhEstimate(this.negotiated);\n      if (this._protocol._compatFlags & COMPAT.BUG_DHGEX_LARGE) this._prefBits = Math.min(this._prefBits, 4096);\n      this._maxBits = GEX_MAX_BITS;\n    }\n    start() {\n      if (this._protocol._server) return;\n      this._protocol._debug && this._protocol._debug('Outbound: Sending KEXDH_GEX_REQUEST');\n      let p = this._protocol._packetRW.write.allocStartKEX;\n      const packet = this._protocol._packetRW.write.alloc(1 + 4 + 4 + 4, true);\n      packet[p] = MESSAGE.KEXDH_GEX_REQUEST;\n      writeUInt32BE(packet, this._minBits, ++p);\n      writeUInt32BE(packet, this._prefBits, p += 4);\n      writeUInt32BE(packet, this._maxBits, p += 4);\n      this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));\n    }\n    generateKeys() {\n      if (!this._dh && this._prime && this._generator) {\n        this._dh = createDiffieHellman(this._prime, this._generator);\n        this._public = this._dh.generateKeys();\n      }\n    }\n    setDHParams(prime, generator) {\n      if (!Buffer.isBuffer(prime)) throw new Error('Invalid prime value');\n      if (!Buffer.isBuffer(generator)) throw new Error('Invalid generator value');\n      this._prime = prime;\n      this._generator = generator;\n    }\n    getDHParams() {\n      if (this._dh) {\n        return {\n          prime: convertToMpint(this._dh.getPrime()),\n          generator: convertToMpint(this._dh.getGenerator())\n        };\n      }\n    }\n    parse(payload) {\n      const type = payload[0];\n      switch (this._step) {\n        case 1:\n          {\n            if (this._protocol._server) {\n              if (type !== MESSAGE.KEXDH_GEX_REQUEST) {\n                return doFatalError(this._protocol, `Received packet ${type} instead of ` + MESSAGE.KEXDH_GEX_REQUEST, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n              }\n              // TODO: allow user implementation to provide safe prime and\n              // generator on demand to support group exchange on server side\n              return doFatalError(this._protocol, 'Group exchange not implemented for server', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n            if (type !== MESSAGE.KEXDH_GEX_GROUP) {\n              return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_GROUP}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n            this._protocol._debug && this._protocol._debug('Received DH GEX Group');\n\n            /*\n              byte    SSH_MSG_KEX_DH_GEX_GROUP\n              mpint   p, safe prime\n              mpint   g, generator for subgroup in GF(p)\n            */\n            bufferParser.init(payload, 1);\n            let prime;\n            let gen;\n            if ((prime = bufferParser.readString()) === undefined || (gen = bufferParser.readString()) === undefined) {\n              bufferParser.clear();\n              return doFatalError(this._protocol, 'Received malformed KEXDH_GEX_GROUP', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n            bufferParser.clear();\n\n            // TODO: validate prime\n            this.setDHParams(prime, gen);\n            this.generateKeys();\n            const pubkey = this.getPublicKey();\n            this._protocol._debug && this._protocol._debug('Outbound: Sending KEXDH_GEX_INIT');\n            let p = this._protocol._packetRW.write.allocStartKEX;\n            const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubkey.length, true);\n            packet[p] = MESSAGE.KEXDH_GEX_INIT;\n            writeUInt32BE(packet, pubkey.length, ++p);\n            packet.set(pubkey, p += 4);\n            this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));\n            ++this._step;\n            break;\n          }\n        case 2:\n          if (this._protocol._server) {\n            if (type !== MESSAGE.KEXDH_GEX_INIT) {\n              return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_INIT}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n            this._protocol._debug && this._protocol._debug('Received DH GEX Init');\n            return doFatalError(this._protocol, 'Group exchange not implemented for server', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n          } else if (type !== MESSAGE.KEXDH_GEX_REPLY) {\n            return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_REPLY}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n          }\n          this._protocol._debug && this._protocol._debug('Received DH GEX Reply');\n          this._step = 1;\n          payload[0] = MESSAGE.KEXDH_REPLY;\n          this.parse = KeyExchange.prototype.parse;\n          this.parse(payload);\n      }\n    }\n  }\n  class DHExchange extends KeyExchange {\n    constructor(groupName, hashName) {\n      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n        args[_key4 - 2] = arguments[_key4];\n      }\n      super(...args);\n      this.type = 'group';\n      this.groupName = groupName;\n      this.hashName = hashName;\n    }\n    start() {\n      if (!this._protocol._server) {\n        this._protocol._debug && this._protocol._debug('Outbound: Sending KEXDH_INIT');\n        const pubKey = this.getPublicKey();\n        let p = this._protocol._packetRW.write.allocStartKEX;\n        const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubKey.length, true);\n        packet[p] = MESSAGE.KEXDH_INIT;\n        writeUInt32BE(packet, pubKey.length, ++p);\n        packet.set(pubKey, p += 4);\n        this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));\n      }\n    }\n    generateKeys() {\n      if (!this._dh) {\n        this._dh = createDiffieHellmanGroup(this.groupName);\n        this._public = this._dh.generateKeys();\n      }\n    }\n    getDHParams() {\n      if (this._dh) {\n        return {\n          prime: convertToMpint(this._dh.getPrime()),\n          generator: convertToMpint(this._dh.getGenerator())\n        };\n      }\n    }\n  }\n  return function (negotiated) {\n    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      args[_key5 - 1] = arguments[_key5];\n    }\n    if (typeof negotiated !== 'object' || negotiated === null) throw new Error('Invalid negotiated argument');\n    const kexType = negotiated.kex;\n    if (typeof kexType === 'string') {\n      args = [negotiated, ...args];\n      switch (kexType) {\n        case 'curve25519-sha256':\n        case 'curve25519-sha256@libssh.org':\n          if (!curve25519Supported) break;\n          return new Curve25519Exchange('sha256', ...args);\n        case 'ecdh-sha2-nistp256':\n          return new ECDHExchange('prime256v1', 'sha256', ...args);\n        case 'ecdh-sha2-nistp384':\n          return new ECDHExchange('secp384r1', 'sha384', ...args);\n        case 'ecdh-sha2-nistp521':\n          return new ECDHExchange('secp521r1', 'sha512', ...args);\n        case 'diffie-hellman-group1-sha1':\n          return new DHExchange('modp2', 'sha1', ...args);\n        case 'diffie-hellman-group14-sha1':\n          return new DHExchange('modp14', 'sha1', ...args);\n        case 'diffie-hellman-group14-sha256':\n          return new DHExchange('modp14', 'sha256', ...args);\n        case 'diffie-hellman-group15-sha512':\n          return new DHExchange('modp15', 'sha512', ...args);\n        case 'diffie-hellman-group16-sha512':\n          return new DHExchange('modp16', 'sha512', ...args);\n        case 'diffie-hellman-group17-sha512':\n          return new DHExchange('modp17', 'sha512', ...args);\n        case 'diffie-hellman-group18-sha512':\n          return new DHExchange('modp18', 'sha512', ...args);\n        case 'diffie-hellman-group-exchange-sha1':\n          return new DHGroupExchange('sha1', ...args);\n        case 'diffie-hellman-group-exchange-sha256':\n          return new DHGroupExchange('sha256', ...args);\n      }\n      throw new Error(`Unsupported key exchange algorithm: ${kexType}`);\n    }\n    throw new Error(`Invalid key exchange type: ${kexType}`);\n  };\n})();\nconst KexInit = (() => {\n  const KEX_PROPERTY_NAMES = ['kex', 'serverHostKey', ['cs', 'cipher'], ['sc', 'cipher'], ['cs', 'mac'], ['sc', 'mac'], ['cs', 'compress'], ['sc', 'compress'], ['cs', 'lang'], ['sc', 'lang']];\n  return class KexInit {\n    constructor(obj) {\n      if (typeof obj !== 'object' || obj === null) throw new TypeError('Argument must be an object');\n      const lists = {\n        kex: undefined,\n        serverHostKey: undefined,\n        cs: {\n          cipher: undefined,\n          mac: undefined,\n          compress: undefined,\n          lang: undefined\n        },\n        sc: {\n          cipher: undefined,\n          mac: undefined,\n          compress: undefined,\n          lang: undefined\n        },\n        all: undefined\n      };\n      let totalSize = 0;\n      for (const prop of KEX_PROPERTY_NAMES) {\n        let base;\n        let val;\n        let desc;\n        let key;\n        if (typeof prop === 'string') {\n          base = lists;\n          val = obj[prop];\n          desc = key = prop;\n        } else {\n          const parent = prop[0];\n          base = lists[parent];\n          key = prop[1];\n          val = obj[parent][key];\n          desc = `${parent}.${key}`;\n        }\n        const entry = {\n          array: undefined,\n          buffer: undefined\n        };\n        if (Buffer.isBuffer(val)) {\n          entry.array = ('' + val).split(',');\n          entry.buffer = val;\n          totalSize += 4 + val.length;\n        } else {\n          if (typeof val === 'string') val = val.split(',');\n          if (Array.isArray(val)) {\n            entry.array = val;\n            entry.buffer = Buffer.from(val.join(','));\n          } else {\n            throw new TypeError(`Invalid \\`${desc}\\` type: ${typeof val}`);\n          }\n          totalSize += 4 + entry.buffer.length;\n        }\n        base[key] = entry;\n      }\n      const all = Buffer.allocUnsafe(totalSize);\n      lists.all = all;\n      let allPos = 0;\n      for (const prop of KEX_PROPERTY_NAMES) {\n        let data;\n        if (typeof prop === 'string') data = lists[prop].buffer;else data = lists[prop[0]][prop[1]].buffer;\n        allPos = writeUInt32BE(all, data.length, allPos);\n        all.set(data, allPos);\n        allPos += data.length;\n      }\n      this.totalSize = totalSize;\n      this.lists = lists;\n    }\n    copyAllTo(buf, offset) {\n      const src = this.lists.all;\n      if (typeof offset !== 'number') throw new TypeError(`Invalid offset value: ${typeof offset}`);\n      if (buf.length - offset < src.length) throw new Error('Insufficient space to copy list');\n      buf.set(src, offset);\n      return src.length;\n    }\n  };\n})();\nconst hashString = (() => {\n  const LEN = Buffer.allocUnsafe(4);\n  return (hash, buf) => {\n    writeUInt32BE(LEN, buf.length, 0);\n    hash.update(LEN);\n    hash.update(buf);\n  };\n})();\nfunction generateKEXVal(len, hashName, secret, exchangeHash, sessionID, char) {\n  let ret;\n  if (len) {\n    let digest = createHash(hashName).update(secret).update(exchangeHash).update(char).update(sessionID).digest();\n    while (digest.length < len) {\n      const chunk = createHash(hashName).update(secret).update(exchangeHash).update(digest).digest();\n      const extended = Buffer.allocUnsafe(digest.length + chunk.length);\n      extended.set(digest, 0);\n      extended.set(chunk, digest.length);\n      digest = extended;\n    }\n    if (digest.length === len) ret = digest;else ret = new FastBuffer(digest.buffer, digest.byteOffset, len);\n  } else {\n    ret = EMPTY_BUFFER;\n  }\n  return ret;\n}\nfunction onKEXPayload(state, payload) {\n  // XXX: move this to the Decipher implementations?\n  if (payload.length === 0) {\n    this._debug && this._debug('Inbound: Skipping empty packet payload');\n    return;\n  }\n  if (this._skipNextInboundPacket) {\n    this._skipNextInboundPacket = false;\n    return;\n  }\n  payload = this._packetRW.read.read(payload);\n  const type = payload[0];\n  switch (type) {\n    case MESSAGE.DISCONNECT:\n    case MESSAGE.IGNORE:\n    case MESSAGE.UNIMPLEMENTED:\n    case MESSAGE.DEBUG:\n      if (!MESSAGE_HANDLERS) MESSAGE_HANDLERS = require('./handlers.js');\n      return MESSAGE_HANDLERS[type](this, payload);\n    case MESSAGE.KEXINIT:\n      if (!state.firstPacket) {\n        return doFatalError(this, 'Received extra KEXINIT during handshake', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      }\n      state.firstPacket = false;\n      return handleKexInit(this, payload);\n    default:\n      if (type < 20 || type > 49) {\n        return doFatalError(this, `Received unexpected packet type ${type}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      }\n  }\n  return this._kex.parse(payload);\n}\nfunction dhEstimate(neg) {\n  const csCipher = CIPHER_INFO[neg.cs.cipher];\n  const scCipher = CIPHER_INFO[neg.sc.cipher];\n  // XXX: if OpenSSH's `umac-*` MACs are ever supported, their key lengths will\n  // also need to be considered when calculating `bits`\n  const bits = Math.max(0, csCipher.sslName === 'des-ede3-cbc' ? 14 : csCipher.keyLen, csCipher.blockLen, csCipher.ivLen, scCipher.sslName === 'des-ede3-cbc' ? 14 : scCipher.keyLen, scCipher.blockLen, scCipher.ivLen) * 8;\n  if (bits <= 112) return 2048;\n  if (bits <= 128) return 3072;\n  if (bits <= 192) return 7680;\n  return 8192;\n}\nfunction trySendNEWKEYS(kex) {\n  if (!kex._sentNEWKEYS) {\n    kex._protocol._debug && kex._protocol._debug('Outbound: Sending NEWKEYS');\n    const p = kex._protocol._packetRW.write.allocStartKEX;\n    const packet = kex._protocol._packetRW.write.alloc(1, true);\n    packet[p] = MESSAGE.NEWKEYS;\n    kex._protocol._cipher.encrypt(kex._protocol._packetRW.write.finalize(packet, true));\n    kex._sentNEWKEYS = true;\n  }\n}\nmodule.exports = {\n  KexInit,\n  kexinit,\n  onKEXPayload,\n  DEFAULT_KEXINIT_CLIENT: new KexInit({\n    kex: DEFAULT_KEX.concat(['ext-info-c']),\n    serverHostKey: DEFAULT_SERVER_HOST_KEY,\n    cs: {\n      cipher: DEFAULT_CIPHER,\n      mac: DEFAULT_MAC,\n      compress: DEFAULT_COMPRESSION,\n      lang: []\n    },\n    sc: {\n      cipher: DEFAULT_CIPHER,\n      mac: DEFAULT_MAC,\n      compress: DEFAULT_COMPRESSION,\n      lang: []\n    }\n  }),\n  DEFAULT_KEXINIT_SERVER: new KexInit({\n    kex: DEFAULT_KEX,\n    serverHostKey: DEFAULT_SERVER_HOST_KEY,\n    cs: {\n      cipher: DEFAULT_CIPHER,\n      mac: DEFAULT_MAC,\n      compress: DEFAULT_COMPRESSION,\n      lang: []\n    },\n    sc: {\n      cipher: DEFAULT_CIPHER,\n      mac: DEFAULT_MAC,\n      compress: DEFAULT_COMPRESSION,\n      lang: []\n    }\n  }),\n  HANDLERS: {\n    [MESSAGE.KEXINIT]: handleKexInit\n  }\n};","map":{"version":3,"names":["createDiffieHellman","createDiffieHellmanGroup","createECDH","createHash","createPublicKey","diffieHellman","generateKeyPairSync","randomFillSync","require","Ber","COMPAT","curve25519Supported","DEFAULT_KEX","DEFAULT_SERVER_HOST_KEY","DEFAULT_CIPHER","DEFAULT_MAC","DEFAULT_COMPRESSION","DISCONNECT_REASON","MESSAGE","CIPHER_INFO","createCipher","createDecipher","MAC_INFO","parseDERKey","bufferFill","bufferParser","convertSignature","doFatalError","FastBuffer","sigSSHToASN1","writeUInt32BE","PacketReader","PacketWriter","ZlibPacketReader","ZlibPacketWriter","MESSAGE_HANDLERS","GEX_MIN_BITS","GEX_MAX_BITS","EMPTY_BUFFER","Buffer","alloc","kexinit","self","payload","_compatFlags","BAD_DHGEX","entry","_offer","lists","kex","array","found","i","length","includes","slice","splice","len","totalSize","newKexBuf","from","join","buffer","all","rest","Uint8Array","byteOffset","allocUnsafe","set","undefined","copyAllTo","_debug","KEXINIT","_kexinit","_packetRW","write","allocStart","p","allocStartKEX","packet","_cipher","encrypt","finalize","handleKexInit","init","serverHostKey","cs","cipher","mac","compress","lang","sc","readList","clear","KEY_EXCHANGE_FAILED","pos","firstFollows","local","remote","localKex","indexOf","clientList","serverList","debug","remoteExtInfoEnabled","_server","_skipNextInboundPacket","localSrvHostKey","localCSCipher","localSCCipher","localCSMAC","authLen","localSCMAC","localCSCompress","localSCCompress","_kex","_decipher","_onPayload","onKEXPayload","bind","firstPacket","createKeyExchange","start","convertToMpint","buf","idx","newBuf","copy","KeyExchange","constructor","negotiated","protocol","remoteKexinit","_protocol","sessionID","_step","_public","_dh","_sentNEWKEYS","_receivedNEWKEYS","_finished","_hostVerified","_remoteKexinit","_identRaw","_remoteIdentRaw","_hostKey","_dhData","_sig","finish","isServer","pubKey","convertPublicKey","secret","computeSecret","Error","message","type","level","hash","hashName","hashString","serverPublicHostKey","getPublicSSH","params","getDHParams","num","_minBits","update","_prefBits","_maxBits","prime","generator","getPublicKey","serverPublicKey","exchangeHash","digest","sigType","readString","sigValue","parsedHostKey","name","hostKey","hashAlgo","verified","verify","stack","signature","sign","sigTypeLen","byteLength","sigLen","KEXDH_REPLY","utf8Write","trySendNEWKEYS","completeHandshake","newSecret","csCipherInfo","scCipherInfo","csIV","generateKEXVal","ivLen","scIV","csKey","keyLen","scKey","csMacInfo","csMacKey","scMacInfo","scMacKey","config","inbound","onPayload","seqno","inSeqno","decipherInfo","decipherIV","decipherKey","macInfo","macKey","outbound","onWrite","_onWrite","outSeqno","cipherInfo","cipherIV","cipherKey","free","rw","read","_authenticated","cleanup","_onHandshakeComplete","KEXDH_INIT","generateKeys","key","newKey","otherPublicKey","ex","parse","dhData","_hostKeys","Array","isArray","hostPubKey","sig","hostPubKeyType","checked","ret","_hostVerifier","permitted","NEWKEYS","Curve25519Exchange","_len","arguments","args","_key","_keys","publicKey","export","format","asnWriter","Writer","startSequence","writeOID","endSequence","BitString","writeByte","_ensure","_buf","_offset","privateKey","ECDHExchange","curveName","_len2","_key2","DHGroupExchange","_len3","_key3","_prime","_generator","dhEstimate","BUG_DHGEX_LARGE","Math","min","KEXDH_GEX_REQUEST","setDHParams","isBuffer","getPrime","getGenerator","KEXDH_GEX_GROUP","gen","pubkey","KEXDH_GEX_INIT","KEXDH_GEX_REPLY","prototype","DHExchange","groupName","_len4","_key4","_len5","_key5","kexType","KexInit","KEX_PROPERTY_NAMES","obj","TypeError","prop","base","val","desc","parent","split","allPos","data","offset","src","LEN","char","chunk","extended","state","DISCONNECT","IGNORE","UNIMPLEMENTED","DEBUG","neg","csCipher","scCipher","bits","max","sslName","blockLen","module","exports","DEFAULT_KEXINIT_CLIENT","concat","DEFAULT_KEXINIT_SERVER","HANDLERS"],"sources":["/home/user/node_modules/ssh2/lib/protocol/kex.js"],"sourcesContent":["'use strict';\n\nconst {\n  createDiffieHellman,\n  createDiffieHellmanGroup,\n  createECDH,\n  createHash,\n  createPublicKey,\n  diffieHellman,\n  generateKeyPairSync,\n  randomFillSync,\n} = require('crypto');\n\nconst { Ber } = require('asn1');\n\nconst {\n  COMPAT,\n  curve25519Supported,\n  DEFAULT_KEX,\n  DEFAULT_SERVER_HOST_KEY,\n  DEFAULT_CIPHER,\n  DEFAULT_MAC,\n  DEFAULT_COMPRESSION,\n  DISCONNECT_REASON,\n  MESSAGE,\n} = require('./constants.js');\nconst {\n  CIPHER_INFO,\n  createCipher,\n  createDecipher,\n  MAC_INFO,\n} = require('./crypto.js');\nconst { parseDERKey } = require('./keyParser.js');\nconst {\n  bufferFill,\n  bufferParser,\n  convertSignature,\n  doFatalError,\n  FastBuffer,\n  sigSSHToASN1,\n  writeUInt32BE,\n} = require('./utils.js');\nconst {\n  PacketReader,\n  PacketWriter,\n  ZlibPacketReader,\n  ZlibPacketWriter,\n} = require('./zlib.js');\n\nlet MESSAGE_HANDLERS;\n\nconst GEX_MIN_BITS = 2048; // RFC 8270\nconst GEX_MAX_BITS = 8192; // RFC 8270\n\nconst EMPTY_BUFFER = Buffer.alloc(0);\n\n// Client/Server\nfunction kexinit(self) {\n  /*\n    byte         SSH_MSG_KEXINIT\n    byte[16]     cookie (random bytes)\n    name-list    kex_algorithms\n    name-list    server_host_key_algorithms\n    name-list    encryption_algorithms_client_to_server\n    name-list    encryption_algorithms_server_to_client\n    name-list    mac_algorithms_client_to_server\n    name-list    mac_algorithms_server_to_client\n    name-list    compression_algorithms_client_to_server\n    name-list    compression_algorithms_server_to_client\n    name-list    languages_client_to_server\n    name-list    languages_server_to_client\n    boolean      first_kex_packet_follows\n    uint32       0 (reserved for future extension)\n  */\n\n  let payload;\n  if (self._compatFlags & COMPAT.BAD_DHGEX) {\n    const entry = self._offer.lists.kex;\n    let kex = entry.array;\n    let found = false;\n    for (let i = 0; i < kex.length; ++i) {\n      if (kex[i].includes('group-exchange')) {\n        if (!found) {\n          found = true;\n          // Copy array lazily\n          kex = kex.slice();\n        }\n        kex.splice(i--, 1);\n      }\n    }\n    if (found) {\n      let len = 1 + 16 + self._offer.totalSize + 1 + 4;\n      const newKexBuf = Buffer.from(kex.join(','));\n      len -= (entry.buffer.length - newKexBuf.length);\n\n      const all = self._offer.lists.all;\n      const rest = new Uint8Array(\n        all.buffer,\n        all.byteOffset + 4 + entry.buffer.length,\n        all.length - (4 + entry.buffer.length)\n      );\n\n      payload = Buffer.allocUnsafe(len);\n      writeUInt32BE(payload, newKexBuf.length, 17);\n      payload.set(newKexBuf, 17 + 4);\n      payload.set(rest, 17 + 4 + newKexBuf.length);\n    }\n  }\n\n  if (payload === undefined) {\n    payload = Buffer.allocUnsafe(1 + 16 + self._offer.totalSize + 1 + 4);\n    self._offer.copyAllTo(payload, 17);\n  }\n\n  self._debug && self._debug('Outbound: Sending KEXINIT');\n\n  payload[0] = MESSAGE.KEXINIT;\n  randomFillSync(payload, 1, 16);\n\n  // Zero-fill first_kex_packet_follows and reserved bytes\n  bufferFill(payload, 0, payload.length - 5);\n\n  self._kexinit = payload;\n\n  // Needed to correct the starting position in allocated \"packets\" when packets\n  // will be buffered due to active key exchange\n  self._packetRW.write.allocStart = 0;\n\n  // TODO: only create single buffer and set _kexinit as slice of packet instead\n  {\n    const p = self._packetRW.write.allocStartKEX;\n    const packet = self._packetRW.write.alloc(payload.length, true);\n    packet.set(payload, p);\n    self._cipher.encrypt(self._packetRW.write.finalize(packet, true));\n  }\n}\n\nfunction handleKexInit(self, payload) {\n  /*\n    byte         SSH_MSG_KEXINIT\n    byte[16]     cookie (random bytes)\n    name-list    kex_algorithms\n    name-list    server_host_key_algorithms\n    name-list    encryption_algorithms_client_to_server\n    name-list    encryption_algorithms_server_to_client\n    name-list    mac_algorithms_client_to_server\n    name-list    mac_algorithms_server_to_client\n    name-list    compression_algorithms_client_to_server\n    name-list    compression_algorithms_server_to_client\n    name-list    languages_client_to_server\n    name-list    languages_server_to_client\n    boolean      first_kex_packet_follows\n    uint32       0 (reserved for future extension)\n  */\n  const init = {\n    kex: undefined,\n    serverHostKey: undefined,\n    cs: {\n      cipher: undefined,\n      mac: undefined,\n      compress: undefined,\n      lang: undefined,\n    },\n    sc: {\n      cipher: undefined,\n      mac: undefined,\n      compress: undefined,\n      lang: undefined,\n    },\n  };\n\n  bufferParser.init(payload, 17);\n\n  if ((init.kex = bufferParser.readList()) === undefined\n      || (init.serverHostKey = bufferParser.readList()) === undefined\n      || (init.cs.cipher = bufferParser.readList()) === undefined\n      || (init.sc.cipher = bufferParser.readList()) === undefined\n      || (init.cs.mac = bufferParser.readList()) === undefined\n      || (init.sc.mac = bufferParser.readList()) === undefined\n      || (init.cs.compress = bufferParser.readList()) === undefined\n      || (init.sc.compress = bufferParser.readList()) === undefined\n      || (init.cs.lang = bufferParser.readList()) === undefined\n      || (init.sc.lang = bufferParser.readList()) === undefined) {\n    bufferParser.clear();\n    return doFatalError(\n      self,\n      'Received malformed KEXINIT',\n      'handshake',\n      DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n    );\n  }\n\n  const pos = bufferParser.pos();\n  const firstFollows = (pos < payload.length && payload[pos] === 1);\n  bufferParser.clear();\n\n  const local = self._offer;\n  const remote = init;\n\n  let localKex = local.lists.kex.array;\n  if (self._compatFlags & COMPAT.BAD_DHGEX) {\n    let found = false;\n    for (let i = 0; i < localKex.length; ++i) {\n      if (localKex[i].indexOf('group-exchange') !== -1) {\n        if (!found) {\n          found = true;\n          // Copy array lazily\n          localKex = localKex.slice();\n        }\n        localKex.splice(i--, 1);\n      }\n    }\n  }\n\n  let clientList;\n  let serverList;\n  let i;\n  const debug = self._debug;\n\n  debug && debug('Inbound: Handshake in progress');\n\n  // Key exchange method =======================================================\n  debug && debug(`Handshake: (local) KEX method: ${localKex}`);\n  debug && debug(`Handshake: (remote) KEX method: ${remote.kex}`);\n  let remoteExtInfoEnabled;\n  if (self._server) {\n    serverList = localKex;\n    clientList = remote.kex;\n    remoteExtInfoEnabled = (clientList.indexOf('ext-info-c') !== -1);\n  } else {\n    serverList = remote.kex;\n    clientList = localKex;\n    remoteExtInfoEnabled = (serverList.indexOf('ext-info-s') !== -1);\n  }\n  // Check for agreeable key exchange algorithm\n  for (i = 0;\n       i < clientList.length && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching key exchange algorithm');\n    return doFatalError(\n      self,\n      'Handshake failed: no matching key exchange algorithm',\n      'handshake',\n      DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n    );\n  }\n  init.kex = clientList[i];\n  debug && debug(`Handshake: KEX algorithm: ${clientList[i]}`);\n  if (firstFollows && (!remote.kex.length || clientList[i] !== remote.kex[0])) {\n    // Ignore next inbound packet, it was a wrong first guess at KEX algorithm\n    self._skipNextInboundPacket = true;\n  }\n\n\n  // Server host key format ====================================================\n  const localSrvHostKey = local.lists.serverHostKey.array;\n  debug && debug(`Handshake: (local) Host key format: ${localSrvHostKey}`);\n  debug && debug(\n    `Handshake: (remote) Host key format: ${remote.serverHostKey}`\n  );\n  if (self._server) {\n    serverList = localSrvHostKey;\n    clientList = remote.serverHostKey;\n  } else {\n    serverList = remote.serverHostKey;\n    clientList = localSrvHostKey;\n  }\n  // Check for agreeable server host key format\n  for (i = 0;\n       i < clientList.length && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching host key format');\n    return doFatalError(\n      self,\n      'Handshake failed: no matching host key format',\n      'handshake',\n      DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n    );\n  }\n  init.serverHostKey = clientList[i];\n  debug && debug(`Handshake: Host key format: ${clientList[i]}`);\n\n\n  // Client->Server cipher =====================================================\n  const localCSCipher = local.lists.cs.cipher.array;\n  debug && debug(`Handshake: (local) C->S cipher: ${localCSCipher}`);\n  debug && debug(`Handshake: (remote) C->S cipher: ${remote.cs.cipher}`);\n  if (self._server) {\n    serverList = localCSCipher;\n    clientList = remote.cs.cipher;\n  } else {\n    serverList = remote.cs.cipher;\n    clientList = localCSCipher;\n  }\n  // Check for agreeable client->server cipher\n  for (i = 0;\n       i < clientList.length && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching C->S cipher');\n    return doFatalError(\n      self,\n      'Handshake failed: no matching C->S cipher',\n      'handshake',\n      DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n    );\n  }\n  init.cs.cipher = clientList[i];\n  debug && debug(`Handshake: C->S Cipher: ${clientList[i]}`);\n\n\n  // Server->Client cipher =====================================================\n  const localSCCipher = local.lists.sc.cipher.array;\n  debug && debug(`Handshake: (local) S->C cipher: ${localSCCipher}`);\n  debug && debug(`Handshake: (remote) S->C cipher: ${remote.sc.cipher}`);\n  if (self._server) {\n    serverList = localSCCipher;\n    clientList = remote.sc.cipher;\n  } else {\n    serverList = remote.sc.cipher;\n    clientList = localSCCipher;\n  }\n  // Check for agreeable server->client cipher\n  for (i = 0;\n       i < clientList.length && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching S->C cipher');\n    return doFatalError(\n      self,\n      'Handshake failed: no matching S->C cipher',\n      'handshake',\n      DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n    );\n  }\n  init.sc.cipher = clientList[i];\n  debug && debug(`Handshake: S->C cipher: ${clientList[i]}`);\n\n\n  // Client->Server MAC ========================================================\n  const localCSMAC = local.lists.cs.mac.array;\n  debug && debug(`Handshake: (local) C->S MAC: ${localCSMAC}`);\n  debug && debug(`Handshake: (remote) C->S MAC: ${remote.cs.mac}`);\n  if (CIPHER_INFO[init.cs.cipher].authLen > 0) {\n    init.cs.mac = '';\n    debug && debug('Handshake: C->S MAC: <implicit>');\n  } else {\n    if (self._server) {\n      serverList = localCSMAC;\n      clientList = remote.cs.mac;\n    } else {\n      serverList = remote.cs.mac;\n      clientList = localCSMAC;\n    }\n    // Check for agreeable client->server hmac algorithm\n    for (i = 0;\n         i < clientList.length && serverList.indexOf(clientList[i]) === -1;\n         ++i);\n    if (i === clientList.length) {\n      // No suitable match found!\n      debug && debug('Handshake: No matching C->S MAC');\n      return doFatalError(\n        self,\n        'Handshake failed: no matching C->S MAC',\n        'handshake',\n        DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n      );\n    }\n    init.cs.mac = clientList[i];\n    debug && debug(`Handshake: C->S MAC: ${clientList[i]}`);\n  }\n\n\n  // Server->Client MAC ========================================================\n  const localSCMAC = local.lists.sc.mac.array;\n  debug && debug(`Handshake: (local) S->C MAC: ${localSCMAC}`);\n  debug && debug(`Handshake: (remote) S->C MAC: ${remote.sc.mac}`);\n  if (CIPHER_INFO[init.sc.cipher].authLen > 0) {\n    init.sc.mac = '';\n    debug && debug('Handshake: S->C MAC: <implicit>');\n  } else {\n    if (self._server) {\n      serverList = localSCMAC;\n      clientList = remote.sc.mac;\n    } else {\n      serverList = remote.sc.mac;\n      clientList = localSCMAC;\n    }\n    // Check for agreeable server->client hmac algorithm\n    for (i = 0;\n         i < clientList.length && serverList.indexOf(clientList[i]) === -1;\n         ++i);\n    if (i === clientList.length) {\n      // No suitable match found!\n      debug && debug('Handshake: No matching S->C MAC');\n      return doFatalError(\n        self,\n        'Handshake failed: no matching S->C MAC',\n        'handshake',\n        DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n      );\n    }\n    init.sc.mac = clientList[i];\n    debug && debug(`Handshake: S->C MAC: ${clientList[i]}`);\n  }\n\n\n  // Client->Server compression ================================================\n  const localCSCompress = local.lists.cs.compress.array;\n  debug && debug(`Handshake: (local) C->S compression: ${localCSCompress}`);\n  debug && debug(`Handshake: (remote) C->S compression: ${remote.cs.compress}`);\n  if (self._server) {\n    serverList = localCSCompress;\n    clientList = remote.cs.compress;\n  } else {\n    serverList = remote.cs.compress;\n    clientList = localCSCompress;\n  }\n  // Check for agreeable client->server compression algorithm\n  for (i = 0;\n       i < clientList.length && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching C->S compression');\n    return doFatalError(\n      self,\n      'Handshake failed: no matching C->S compression',\n      'handshake',\n      DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n    );\n  }\n  init.cs.compress = clientList[i];\n  debug && debug(`Handshake: C->S compression: ${clientList[i]}`);\n\n\n  // Server->Client compression ================================================\n  const localSCCompress = local.lists.sc.compress.array;\n  debug && debug(`Handshake: (local) S->C compression: ${localSCCompress}`);\n  debug && debug(`Handshake: (remote) S->C compression: ${remote.sc.compress}`);\n  if (self._server) {\n    serverList = localSCCompress;\n    clientList = remote.sc.compress;\n  } else {\n    serverList = remote.sc.compress;\n    clientList = localSCCompress;\n  }\n  // Check for agreeable server->client compression algorithm\n  for (i = 0;\n       i < clientList.length && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching S->C compression');\n    return doFatalError(\n      self,\n      'Handshake failed: no matching S->C compression',\n      'handshake',\n      DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n    );\n  }\n  init.sc.compress = clientList[i];\n  debug && debug(`Handshake: S->C compression: ${clientList[i]}`);\n\n  init.cs.lang = '';\n  init.sc.lang = '';\n\n  // XXX: hack -- find a better way to do this\n  if (self._kex) {\n    if (!self._kexinit) {\n      // We received a rekey request, but we haven't sent a KEXINIT in response\n      // yet\n      kexinit(self);\n    }\n    self._decipher._onPayload = onKEXPayload.bind(self, { firstPacket: false });\n  }\n\n  self._kex = createKeyExchange(init, self, payload);\n  self._kex.remoteExtInfoEnabled = remoteExtInfoEnabled;\n  self._kex.start();\n}\n\nconst createKeyExchange = (() => {\n  function convertToMpint(buf) {\n    let idx = 0;\n    let length = buf.length;\n    while (buf[idx] === 0x00) {\n      ++idx;\n      --length;\n    }\n    let newBuf;\n    if (buf[idx] & 0x80) {\n      newBuf = Buffer.allocUnsafe(1 + length);\n      newBuf[0] = 0;\n      buf.copy(newBuf, 1, idx);\n      buf = newBuf;\n    } else if (length !== buf.length) {\n      newBuf = Buffer.allocUnsafe(length);\n      buf.copy(newBuf, 0, idx);\n      buf = newBuf;\n    }\n    return buf;\n  }\n\n  class KeyExchange {\n    constructor(negotiated, protocol, remoteKexinit) {\n      this._protocol = protocol;\n\n      this.sessionID = (protocol._kex ? protocol._kex.sessionID : undefined);\n      this.negotiated = negotiated;\n      this.remoteExtInfoEnabled = false;\n      this._step = 1;\n      this._public = null;\n      this._dh = null;\n      this._sentNEWKEYS = false;\n      this._receivedNEWKEYS = false;\n      this._finished = false;\n      this._hostVerified = false;\n\n      // Data needed for initializing cipher/decipher/etc.\n      this._kexinit = protocol._kexinit;\n      this._remoteKexinit = remoteKexinit;\n      this._identRaw = protocol._identRaw;\n      this._remoteIdentRaw = protocol._remoteIdentRaw;\n      this._hostKey = undefined;\n      this._dhData = undefined;\n      this._sig = undefined;\n    }\n    finish() {\n      if (this._finished)\n        return false;\n      this._finished = true;\n\n      const isServer = this._protocol._server;\n      const negotiated = this.negotiated;\n\n      const pubKey = this.convertPublicKey(this._dhData);\n      let secret = this.computeSecret(this._dhData);\n      if (secret instanceof Error) {\n        secret.message =\n          `Error while computing DH secret (${this.type}): ${secret.message}`;\n        secret.level = 'handshake';\n        return doFatalError(\n          this._protocol,\n          secret,\n          DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n        );\n      }\n\n      const hash = createHash(this.hashName);\n      // V_C\n      hashString(hash, (isServer ? this._remoteIdentRaw : this._identRaw));\n      // \"V_S\"\n      hashString(hash, (isServer ? this._identRaw : this._remoteIdentRaw));\n      // \"I_C\"\n      hashString(hash, (isServer ? this._remoteKexinit : this._kexinit));\n      // \"I_S\"\n      hashString(hash, (isServer ? this._kexinit : this._remoteKexinit));\n      // \"K_S\"\n      const serverPublicHostKey = (isServer\n                                   ? this._hostKey.getPublicSSH()\n                                   : this._hostKey);\n      hashString(hash, serverPublicHostKey);\n\n      if (this.type === 'groupex') {\n        // Group exchange-specific\n        const params = this.getDHParams();\n        const num = Buffer.allocUnsafe(4);\n        // min (uint32)\n        writeUInt32BE(num, this._minBits, 0);\n        hash.update(num);\n        // preferred (uint32)\n        writeUInt32BE(num, this._prefBits, 0);\n        hash.update(num);\n        // max (uint32)\n        writeUInt32BE(num, this._maxBits, 0);\n        hash.update(num);\n        // prime\n        hashString(hash, params.prime);\n        // generator\n        hashString(hash, params.generator);\n      }\n\n      // method-specific data sent by client\n      hashString(hash, (isServer ? pubKey : this.getPublicKey()));\n      // method-specific data sent by server\n      const serverPublicKey = (isServer ? this.getPublicKey() : pubKey);\n      hashString(hash, serverPublicKey);\n      // shared secret (\"K\")\n      hashString(hash, secret);\n\n      // \"H\"\n      const exchangeHash = hash.digest();\n\n      if (!isServer) {\n        bufferParser.init(this._sig, 0);\n        const sigType = bufferParser.readString(true);\n\n        if (!sigType) {\n          return doFatalError(\n            this._protocol,\n            'Malformed packet while reading signature',\n            'handshake',\n            DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n          );\n        }\n\n        if (sigType !== negotiated.serverHostKey) {\n          return doFatalError(\n            this._protocol,\n            `Wrong signature type: ${sigType}, `\n              + `expected: ${negotiated.serverHostKey}`,\n            'handshake',\n            DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n          );\n        }\n\n        // \"s\"\n        let sigValue = bufferParser.readString();\n\n        bufferParser.clear();\n\n        if (sigValue === undefined) {\n          return doFatalError(\n            this._protocol,\n            'Malformed packet while reading signature',\n            'handshake',\n            DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n          );\n        }\n\n        if (!(sigValue = sigSSHToASN1(sigValue, sigType))) {\n          return doFatalError(\n            this._protocol,\n            'Malformed signature',\n            'handshake',\n            DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n          );\n        }\n\n        let parsedHostKey;\n        {\n          bufferParser.init(this._hostKey, 0);\n          const name = bufferParser.readString(true);\n          const hostKey = this._hostKey.slice(bufferParser.pos());\n          bufferParser.clear();\n          parsedHostKey = parseDERKey(hostKey, name);\n          if (parsedHostKey instanceof Error) {\n            parsedHostKey.level = 'handshake';\n            return doFatalError(\n              this._protocol,\n              parsedHostKey,\n              DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n            );\n          }\n        }\n\n        let hashAlgo;\n        // Check if we need to override the default hash algorithm\n        switch (this.negotiated.serverHostKey) {\n          case 'rsa-sha2-256': hashAlgo = 'sha256'; break;\n          case 'rsa-sha2-512': hashAlgo = 'sha512'; break;\n        }\n\n        this._protocol._debug\n          && this._protocol._debug('Verifying signature ...');\n\n        const verified = parsedHostKey.verify(exchangeHash, sigValue, hashAlgo);\n        if (verified !== true) {\n          if (verified instanceof Error) {\n            this._protocol._debug && this._protocol._debug(\n              `Signature verification failed: ${verified.stack}`\n            );\n          } else {\n            this._protocol._debug && this._protocol._debug(\n              'Signature verification failed'\n            );\n          }\n          return doFatalError(\n            this._protocol,\n            'Handshake failed: signature verification failed',\n            'handshake',\n            DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n          );\n        }\n        this._protocol._debug && this._protocol._debug('Verified signature');\n      } else {\n        // Server\n\n        let hashAlgo;\n        // Check if we need to override the default hash algorithm\n        switch (this.negotiated.serverHostKey) {\n          case 'rsa-sha2-256': hashAlgo = 'sha256'; break;\n          case 'rsa-sha2-512': hashAlgo = 'sha512'; break;\n        }\n\n        this._protocol._debug && this._protocol._debug(\n          'Generating signature ...'\n        );\n\n        let signature = this._hostKey.sign(exchangeHash, hashAlgo);\n        if (signature instanceof Error) {\n          return doFatalError(\n            this._protocol,\n            'Handshake failed: signature generation failed for '\n              + `${this._hostKey.type} host key: ${signature.message}`,\n            'handshake',\n            DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n          );\n        }\n\n        signature = convertSignature(signature, this._hostKey.type);\n        if (signature === false) {\n          return doFatalError(\n            this._protocol,\n            'Handshake failed: signature conversion failed for '\n              + `${this._hostKey.type} host key`,\n            'handshake',\n            DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n          );\n        }\n\n        // Send KEX reply\n        /*\n          byte      SSH_MSG_KEXDH_REPLY\n                      / SSH_MSG_KEX_DH_GEX_REPLY\n                      / SSH_MSG_KEX_ECDH_REPLY\n          string    server public host key and certificates (K_S)\n          string    <method-specific data>\n          string    signature of H\n        */\n        const sigType = this.negotiated.serverHostKey;\n        const sigTypeLen = Buffer.byteLength(sigType);\n        const sigLen = 4 + sigTypeLen + 4 + signature.length;\n        let p = this._protocol._packetRW.write.allocStartKEX;\n        const packet = this._protocol._packetRW.write.alloc(\n          1\n            + 4 + serverPublicHostKey.length\n            + 4 + serverPublicKey.length\n            + 4 + sigLen,\n          true\n        );\n\n        packet[p] = MESSAGE.KEXDH_REPLY;\n\n        writeUInt32BE(packet, serverPublicHostKey.length, ++p);\n        packet.set(serverPublicHostKey, p += 4);\n\n        writeUInt32BE(packet,\n                      serverPublicKey.length,\n                      p += serverPublicHostKey.length);\n        packet.set(serverPublicKey, p += 4);\n\n        writeUInt32BE(packet, sigLen, p += serverPublicKey.length);\n\n        writeUInt32BE(packet, sigTypeLen, p += 4);\n        packet.utf8Write(sigType, p += 4, sigTypeLen);\n\n        writeUInt32BE(packet, signature.length, p += sigTypeLen);\n        packet.set(signature, p += 4);\n\n        if (this._protocol._debug) {\n          let type;\n          switch (this.type) {\n            case 'group':\n              type = 'KEXDH_REPLY';\n              break;\n            case 'groupex':\n              type = 'KEXDH_GEX_REPLY';\n              break;\n            default:\n              type = 'KEXECDH_REPLY';\n          }\n          this._protocol._debug(`Outbound: Sending ${type}`);\n        }\n        this._protocol._cipher.encrypt(\n          this._protocol._packetRW.write.finalize(packet, true)\n        );\n      }\n      trySendNEWKEYS(this);\n\n      const completeHandshake = () => {\n        if (!this.sessionID)\n          this.sessionID = exchangeHash;\n\n        {\n          const newSecret = Buffer.allocUnsafe(4 + secret.length);\n          writeUInt32BE(newSecret, secret.length, 0);\n          newSecret.set(secret, 4);\n          secret = newSecret;\n        }\n\n        // Initialize new ciphers, deciphers, etc.\n\n        const csCipherInfo = CIPHER_INFO[negotiated.cs.cipher];\n        const scCipherInfo = CIPHER_INFO[negotiated.sc.cipher];\n\n        const csIV = generateKEXVal(csCipherInfo.ivLen,\n                                    this.hashName,\n                                    secret,\n                                    exchangeHash,\n                                    this.sessionID,\n                                    'A');\n        const scIV = generateKEXVal(scCipherInfo.ivLen,\n                                    this.hashName,\n                                    secret,\n                                    exchangeHash,\n                                    this.sessionID,\n                                    'B');\n        const csKey = generateKEXVal(csCipherInfo.keyLen,\n                                     this.hashName,\n                                     secret,\n                                     exchangeHash,\n                                     this.sessionID,\n                                     'C');\n        const scKey = generateKEXVal(scCipherInfo.keyLen,\n                                     this.hashName,\n                                     secret,\n                                     exchangeHash,\n                                     this.sessionID,\n                                     'D');\n        let csMacInfo;\n        let csMacKey;\n        if (!csCipherInfo.authLen) {\n          csMacInfo = MAC_INFO[negotiated.cs.mac];\n          csMacKey = generateKEXVal(csMacInfo.len,\n                                    this.hashName,\n                                    secret,\n                                    exchangeHash,\n                                    this.sessionID,\n                                    'E');\n        }\n        let scMacInfo;\n        let scMacKey;\n        if (!scCipherInfo.authLen) {\n          scMacInfo = MAC_INFO[negotiated.sc.mac];\n          scMacKey = generateKEXVal(scMacInfo.len,\n                                    this.hashName,\n                                    secret,\n                                    exchangeHash,\n                                    this.sessionID,\n                                    'F');\n        }\n\n        const config = {\n          inbound: {\n            onPayload: this._protocol._onPayload,\n            seqno: this._protocol._decipher.inSeqno,\n            decipherInfo: (!isServer ? scCipherInfo : csCipherInfo),\n            decipherIV: (!isServer ? scIV : csIV),\n            decipherKey: (!isServer ? scKey : csKey),\n            macInfo: (!isServer ? scMacInfo : csMacInfo),\n            macKey: (!isServer ? scMacKey : csMacKey),\n          },\n          outbound: {\n            onWrite: this._protocol._onWrite,\n            seqno: this._protocol._cipher.outSeqno,\n            cipherInfo: (isServer ? scCipherInfo : csCipherInfo),\n            cipherIV: (isServer ? scIV : csIV),\n            cipherKey: (isServer ? scKey : csKey),\n            macInfo: (isServer ? scMacInfo : csMacInfo),\n            macKey: (isServer ? scMacKey : csMacKey),\n          },\n        };\n        this._protocol._cipher && this._protocol._cipher.free();\n        this._protocol._decipher && this._protocol._decipher.free();\n        this._protocol._cipher = createCipher(config);\n        this._protocol._decipher = createDecipher(config);\n\n        const rw = {\n          read: undefined,\n          write: undefined,\n        };\n        switch (negotiated.cs.compress) {\n          case 'zlib': // starts immediately\n            if (isServer)\n              rw.read = new ZlibPacketReader();\n            else\n              rw.write = new ZlibPacketWriter(this._protocol);\n            break;\n          case 'zlib@openssh.com':\n            // Starts after successful user authentication\n\n            if (this._protocol._authenticated) {\n              // If a rekey happens and this compression method is selected and\n              // we already authenticated successfully, we need to start\n              // immediately instead\n              if (isServer)\n                rw.read = new ZlibPacketReader();\n              else\n                rw.write = new ZlibPacketWriter(this._protocol);\n              break;\n            }\n          // FALLTHROUGH\n          default:\n            // none -- never any compression/decompression\n\n            if (isServer)\n              rw.read = new PacketReader();\n            else\n              rw.write = new PacketWriter(this._protocol);\n        }\n        switch (negotiated.sc.compress) {\n          case 'zlib': // starts immediately\n            if (isServer)\n              rw.write = new ZlibPacketWriter(this._protocol);\n            else\n              rw.read = new ZlibPacketReader();\n            break;\n          case 'zlib@openssh.com':\n            // Starts after successful user authentication\n\n            if (this._protocol._authenticated) {\n              // If a rekey happens and this compression method is selected and\n              // we already authenticated successfully, we need to start\n              // immediately instead\n              if (isServer)\n                rw.write = new ZlibPacketWriter(this._protocol);\n              else\n                rw.read = new ZlibPacketReader();\n              break;\n            }\n          // FALLTHROUGH\n          default:\n            // none -- never any compression/decompression\n\n            if (isServer)\n              rw.write = new PacketWriter(this._protocol);\n            else\n              rw.read = new PacketReader();\n        }\n        this._protocol._packetRW.read.cleanup();\n        this._protocol._packetRW.write.cleanup();\n        this._protocol._packetRW = rw;\n\n        // Cleanup/reset various state\n        this._public = null;\n        this._dh = null;\n        this._kexinit = this._protocol._kexinit = undefined;\n        this._remoteKexinit = undefined;\n        this._identRaw = undefined;\n        this._remoteIdentRaw = undefined;\n        this._hostKey = undefined;\n        this._dhData = undefined;\n        this._sig = undefined;\n\n        this._protocol._onHandshakeComplete(negotiated);\n\n        return false;\n      };\n      if (!isServer)\n        return completeHandshake();\n      this.finish = completeHandshake;\n    }\n\n    start() {\n      if (!this._protocol._server) {\n        if (this._protocol._debug) {\n          let type;\n          switch (this.type) {\n            case 'group':\n              type = 'KEXDH_INIT';\n              break;\n            default:\n              type = 'KEXECDH_INIT';\n          }\n          this._protocol._debug(`Outbound: Sending ${type}`);\n        }\n\n        const pubKey = this.getPublicKey();\n\n        let p = this._protocol._packetRW.write.allocStartKEX;\n        const packet = this._protocol._packetRW.write.alloc(\n          1 + 4 + pubKey.length,\n          true\n        );\n        packet[p] = MESSAGE.KEXDH_INIT;\n        writeUInt32BE(packet, pubKey.length, ++p);\n        packet.set(pubKey, p += 4);\n        this._protocol._cipher.encrypt(\n          this._protocol._packetRW.write.finalize(packet, true)\n        );\n      }\n    }\n    getPublicKey() {\n      this.generateKeys();\n\n      const key = this._public;\n\n      if (key)\n        return this.convertPublicKey(key);\n    }\n    convertPublicKey(key) {\n      let newKey;\n      let idx = 0;\n      let len = key.length;\n      while (key[idx] === 0x00) {\n        ++idx;\n        --len;\n      }\n\n      if (key[idx] & 0x80) {\n        newKey = Buffer.allocUnsafe(1 + len);\n        newKey[0] = 0;\n        key.copy(newKey, 1, idx);\n        return newKey;\n      }\n\n      if (len !== key.length) {\n        newKey = Buffer.allocUnsafe(len);\n        key.copy(newKey, 0, idx);\n        key = newKey;\n      }\n      return key;\n    }\n    computeSecret(otherPublicKey) {\n      this.generateKeys();\n\n      try {\n        return convertToMpint(this._dh.computeSecret(otherPublicKey));\n      } catch (ex) {\n        return ex;\n      }\n    }\n    parse(payload) {\n      const type = payload[0];\n      switch (this._step) {\n        case 1:\n          if (this._protocol._server) {\n            // Server\n            if (type !== MESSAGE.KEXDH_INIT) {\n              return doFatalError(\n                this._protocol,\n                `Received packet ${type} instead of ${MESSAGE.KEXDH_INIT}`,\n                'handshake',\n                DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n              );\n            }\n            this._protocol._debug && this._protocol._debug(\n              'Received DH Init'\n            );\n            /*\n              byte     SSH_MSG_KEXDH_INIT\n                         / SSH_MSG_KEX_ECDH_INIT\n              string   <method-specific data>\n            */\n            bufferParser.init(payload, 1);\n            const dhData = bufferParser.readString();\n            bufferParser.clear();\n            if (dhData === undefined) {\n              return doFatalError(\n                this._protocol,\n                'Received malformed KEX*_INIT',\n                'handshake',\n                DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n              );\n            }\n\n            // Client public key\n            this._dhData = dhData;\n\n            let hostKey =\n              this._protocol._hostKeys[this.negotiated.serverHostKey];\n            if (Array.isArray(hostKey))\n              hostKey = hostKey[0];\n            this._hostKey = hostKey;\n\n            this.finish();\n          } else {\n            // Client\n            if (type !== MESSAGE.KEXDH_REPLY) {\n              return doFatalError(\n                this._protocol,\n                `Received packet ${type} instead of ${MESSAGE.KEXDH_REPLY}`,\n                'handshake',\n                DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n              );\n            }\n            this._protocol._debug && this._protocol._debug(\n              'Received DH Reply'\n            );\n            /*\n              byte      SSH_MSG_KEXDH_REPLY\n                          / SSH_MSG_KEX_DH_GEX_REPLY\n                          / SSH_MSG_KEX_ECDH_REPLY\n              string    server public host key and certificates (K_S)\n              string    <method-specific data>\n              string    signature of H\n            */\n            bufferParser.init(payload, 1);\n            let hostPubKey;\n            let dhData;\n            let sig;\n            if ((hostPubKey = bufferParser.readString()) === undefined\n                || (dhData = bufferParser.readString()) === undefined\n                || (sig = bufferParser.readString()) === undefined) {\n              bufferParser.clear();\n              return doFatalError(\n                this._protocol,\n                'Received malformed KEX*_REPLY',\n                'handshake',\n                DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n              );\n            }\n            bufferParser.clear();\n\n            // Check that the host public key type matches what was negotiated\n            // during KEXINIT swap\n            bufferParser.init(hostPubKey, 0);\n            const hostPubKeyType = bufferParser.readString(true);\n            bufferParser.clear();\n            if (hostPubKeyType === undefined) {\n              return doFatalError(\n                this._protocol,\n                'Received malformed host public key',\n                'handshake',\n                DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n              );\n            }\n            if (hostPubKeyType !== this.negotiated.serverHostKey) {\n              // Check if we need to make an exception\n              switch (this.negotiated.serverHostKey) {\n                case 'rsa-sha2-256':\n                case 'rsa-sha2-512':\n                  if (hostPubKeyType === 'ssh-rsa')\n                    break;\n                // FALLTHROUGH\n                default:\n                  return doFatalError(\n                    this._protocol,\n                    'Host key does not match negotiated type',\n                    'handshake',\n                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n                  );\n              }\n            }\n\n            this._hostKey = hostPubKey;\n            this._dhData = dhData;\n            this._sig = sig;\n\n            let checked = false;\n            let ret;\n            if (this._protocol._hostVerifier === undefined) {\n              ret = true;\n              this._protocol._debug && this._protocol._debug(\n                'Host accepted by default (no verification)'\n              );\n            } else {\n              ret = this._protocol._hostVerifier(hostPubKey, (permitted) => {\n                if (checked)\n                  return;\n                checked = true;\n                if (permitted === false) {\n                  this._protocol._debug && this._protocol._debug(\n                    'Host denied (verification failed)'\n                  );\n                  return doFatalError(\n                    this._protocol,\n                    'Host denied (verification failed)',\n                    'handshake',\n                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n                  );\n                }\n                this._protocol._debug && this._protocol._debug(\n                  'Host accepted (verified)'\n                );\n                this._hostVerified = true;\n                if (this._receivedNEWKEYS)\n                  this.finish();\n                else\n                  trySendNEWKEYS(this);\n              });\n            }\n            if (ret === undefined) {\n              // Async host verification\n              ++this._step;\n              return;\n            }\n            checked = true;\n            if (ret === false) {\n              this._protocol._debug && this._protocol._debug(\n                'Host denied (verification failed)'\n              );\n              return doFatalError(\n                this._protocol,\n                'Host denied (verification failed)',\n                'handshake',\n                DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n              );\n            }\n            this._protocol._debug && this._protocol._debug(\n              'Host accepted (verified)'\n            );\n            this._hostVerified = true;\n            trySendNEWKEYS(this);\n          }\n          ++this._step;\n          break;\n        case 2:\n          if (type !== MESSAGE.NEWKEYS) {\n            return doFatalError(\n              this._protocol,\n              `Received packet ${type} instead of ${MESSAGE.NEWKEYS}`,\n              'handshake',\n              DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n            );\n          }\n          this._protocol._debug && this._protocol._debug(\n            'Inbound: NEWKEYS'\n          );\n          this._receivedNEWKEYS = true;\n          ++this._step;\n          if (this._protocol._server || this._hostVerified)\n            return this.finish();\n\n          // Signal to current decipher that we need to change to a new decipher\n          // for the next packet\n          return false;\n        default:\n          return doFatalError(\n            this._protocol,\n            `Received unexpected packet ${type} after NEWKEYS`,\n            'handshake',\n            DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n          );\n      }\n    }\n  }\n\n  class Curve25519Exchange extends KeyExchange {\n    constructor(hashName, ...args) {\n      super(...args);\n\n      this.type = '25519';\n      this.hashName = hashName;\n      this._keys = null;\n    }\n    generateKeys() {\n      if (!this._keys)\n        this._keys = generateKeyPairSync('x25519');\n    }\n    getPublicKey() {\n      this.generateKeys();\n\n      const key = this._keys.publicKey.export({ type: 'spki', format: 'der' });\n      return key.slice(-32); // HACK: avoids parsing DER/BER header\n    }\n    convertPublicKey(key) {\n      let newKey;\n      let idx = 0;\n      let len = key.length;\n      while (key[idx] === 0x00) {\n        ++idx;\n        --len;\n      }\n\n      if (key.length === 32)\n        return key;\n\n      if (len !== key.length) {\n        newKey = Buffer.allocUnsafe(len);\n        key.copy(newKey, 0, idx);\n        key = newKey;\n      }\n      return key;\n    }\n    computeSecret(otherPublicKey) {\n      this.generateKeys();\n\n      try {\n        const asnWriter = new Ber.Writer();\n        asnWriter.startSequence();\n          // algorithm\n          asnWriter.startSequence();\n            asnWriter.writeOID('1.3.101.110'); // id-X25519\n          asnWriter.endSequence();\n\n          // PublicKey\n          asnWriter.startSequence(Ber.BitString);\n            asnWriter.writeByte(0x00);\n            // XXX: hack to write a raw buffer without a tag -- yuck\n            asnWriter._ensure(otherPublicKey.length);\n            otherPublicKey.copy(asnWriter._buf,\n                                asnWriter._offset,\n                                0,\n                                otherPublicKey.length);\n            asnWriter._offset += otherPublicKey.length;\n          asnWriter.endSequence();\n        asnWriter.endSequence();\n\n        return convertToMpint(diffieHellman({\n          privateKey: this._keys.privateKey,\n          publicKey: createPublicKey({\n            key: asnWriter.buffer,\n            type: 'spki',\n            format: 'der',\n          }),\n        }));\n      } catch (ex) {\n        return ex;\n      }\n    }\n  }\n\n  class ECDHExchange extends KeyExchange {\n    constructor(curveName, hashName, ...args) {\n      super(...args);\n\n      this.type = 'ecdh';\n      this.curveName = curveName;\n      this.hashName = hashName;\n    }\n    generateKeys() {\n      if (!this._dh) {\n        this._dh = createECDH(this.curveName);\n        this._public = this._dh.generateKeys();\n      }\n    }\n  }\n\n  class DHGroupExchange extends KeyExchange {\n    constructor(hashName, ...args) {\n      super(...args);\n\n      this.type = 'groupex';\n      this.hashName = hashName;\n      this._prime = null;\n      this._generator = null;\n      this._minBits = GEX_MIN_BITS;\n      this._prefBits = dhEstimate(this.negotiated);\n      if (this._protocol._compatFlags & COMPAT.BUG_DHGEX_LARGE)\n        this._prefBits = Math.min(this._prefBits, 4096);\n      this._maxBits = GEX_MAX_BITS;\n    }\n    start() {\n      if (this._protocol._server)\n        return;\n      this._protocol._debug && this._protocol._debug(\n        'Outbound: Sending KEXDH_GEX_REQUEST'\n      );\n      let p = this._protocol._packetRW.write.allocStartKEX;\n      const packet = this._protocol._packetRW.write.alloc(\n        1 + 4 + 4 + 4,\n        true\n      );\n      packet[p] = MESSAGE.KEXDH_GEX_REQUEST;\n      writeUInt32BE(packet, this._minBits, ++p);\n      writeUInt32BE(packet, this._prefBits, p += 4);\n      writeUInt32BE(packet, this._maxBits, p += 4);\n      this._protocol._cipher.encrypt(\n        this._protocol._packetRW.write.finalize(packet, true)\n      );\n    }\n    generateKeys() {\n      if (!this._dh && this._prime && this._generator) {\n        this._dh = createDiffieHellman(this._prime, this._generator);\n        this._public = this._dh.generateKeys();\n      }\n    }\n    setDHParams(prime, generator) {\n      if (!Buffer.isBuffer(prime))\n        throw new Error('Invalid prime value');\n      if (!Buffer.isBuffer(generator))\n        throw new Error('Invalid generator value');\n      this._prime = prime;\n      this._generator = generator;\n    }\n    getDHParams() {\n      if (this._dh) {\n        return {\n          prime: convertToMpint(this._dh.getPrime()),\n          generator: convertToMpint(this._dh.getGenerator()),\n        };\n      }\n    }\n    parse(payload) {\n      const type = payload[0];\n      switch (this._step) {\n        case 1: {\n          if (this._protocol._server) {\n            if (type !== MESSAGE.KEXDH_GEX_REQUEST) {\n              return doFatalError(\n                this._protocol,\n                `Received packet ${type} instead of `\n                  + MESSAGE.KEXDH_GEX_REQUEST,\n                'handshake',\n                DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n              );\n            }\n            // TODO: allow user implementation to provide safe prime and\n            // generator on demand to support group exchange on server side\n            return doFatalError(\n              this._protocol,\n              'Group exchange not implemented for server',\n              'handshake',\n              DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n            );\n          }\n\n          if (type !== MESSAGE.KEXDH_GEX_GROUP) {\n            return doFatalError(\n              this._protocol,\n              `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_GROUP}`,\n              'handshake',\n              DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n            );\n          }\n\n          this._protocol._debug && this._protocol._debug(\n            'Received DH GEX Group'\n          );\n\n          /*\n            byte    SSH_MSG_KEX_DH_GEX_GROUP\n            mpint   p, safe prime\n            mpint   g, generator for subgroup in GF(p)\n          */\n          bufferParser.init(payload, 1);\n          let prime;\n          let gen;\n          if ((prime = bufferParser.readString()) === undefined\n              || (gen = bufferParser.readString()) === undefined) {\n            bufferParser.clear();\n            return doFatalError(\n              this._protocol,\n              'Received malformed KEXDH_GEX_GROUP',\n              'handshake',\n              DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n            );\n          }\n          bufferParser.clear();\n\n          // TODO: validate prime\n          this.setDHParams(prime, gen);\n          this.generateKeys();\n          const pubkey = this.getPublicKey();\n\n          this._protocol._debug && this._protocol._debug(\n            'Outbound: Sending KEXDH_GEX_INIT'\n          );\n\n          let p = this._protocol._packetRW.write.allocStartKEX;\n          const packet =\n            this._protocol._packetRW.write.alloc(1 + 4 + pubkey.length, true);\n          packet[p] = MESSAGE.KEXDH_GEX_INIT;\n          writeUInt32BE(packet, pubkey.length, ++p);\n          packet.set(pubkey, p += 4);\n          this._protocol._cipher.encrypt(\n            this._protocol._packetRW.write.finalize(packet, true)\n          );\n\n          ++this._step;\n          break;\n        }\n        case 2:\n          if (this._protocol._server) {\n            if (type !== MESSAGE.KEXDH_GEX_INIT) {\n              return doFatalError(\n                this._protocol,\n                `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_INIT}`,\n                'handshake',\n                DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n              );\n            }\n            this._protocol._debug && this._protocol._debug(\n              'Received DH GEX Init'\n            );\n            return doFatalError(\n              this._protocol,\n              'Group exchange not implemented for server',\n              'handshake',\n              DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n            );\n          } else if (type !== MESSAGE.KEXDH_GEX_REPLY) {\n            return doFatalError(\n              this._protocol,\n              `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_REPLY}`,\n              'handshake',\n              DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n            );\n          }\n          this._protocol._debug && this._protocol._debug(\n            'Received DH GEX Reply'\n          );\n          this._step = 1;\n          payload[0] = MESSAGE.KEXDH_REPLY;\n          this.parse = KeyExchange.prototype.parse;\n          this.parse(payload);\n      }\n    }\n  }\n\n  class DHExchange extends KeyExchange {\n    constructor(groupName, hashName, ...args) {\n      super(...args);\n\n      this.type = 'group';\n      this.groupName = groupName;\n      this.hashName = hashName;\n    }\n    start() {\n      if (!this._protocol._server) {\n        this._protocol._debug && this._protocol._debug(\n          'Outbound: Sending KEXDH_INIT'\n        );\n        const pubKey = this.getPublicKey();\n        let p = this._protocol._packetRW.write.allocStartKEX;\n        const packet =\n          this._protocol._packetRW.write.alloc(1 + 4 + pubKey.length, true);\n        packet[p] = MESSAGE.KEXDH_INIT;\n        writeUInt32BE(packet, pubKey.length, ++p);\n        packet.set(pubKey, p += 4);\n        this._protocol._cipher.encrypt(\n          this._protocol._packetRW.write.finalize(packet, true)\n        );\n      }\n    }\n    generateKeys() {\n      if (!this._dh) {\n        this._dh = createDiffieHellmanGroup(this.groupName);\n        this._public = this._dh.generateKeys();\n      }\n    }\n    getDHParams() {\n      if (this._dh) {\n        return {\n          prime: convertToMpint(this._dh.getPrime()),\n          generator: convertToMpint(this._dh.getGenerator()),\n        };\n      }\n    }\n  }\n\n  return (negotiated, ...args) => {\n    if (typeof negotiated !== 'object' || negotiated === null)\n      throw new Error('Invalid negotiated argument');\n    const kexType = negotiated.kex;\n    if (typeof kexType === 'string') {\n      args = [negotiated, ...args];\n      switch (kexType) {\n        case 'curve25519-sha256':\n        case 'curve25519-sha256@libssh.org':\n          if (!curve25519Supported)\n            break;\n          return new Curve25519Exchange('sha256', ...args);\n\n        case 'ecdh-sha2-nistp256':\n          return new ECDHExchange('prime256v1', 'sha256', ...args);\n        case 'ecdh-sha2-nistp384':\n          return new ECDHExchange('secp384r1', 'sha384', ...args);\n        case 'ecdh-sha2-nistp521':\n          return new ECDHExchange('secp521r1', 'sha512', ...args);\n\n        case 'diffie-hellman-group1-sha1':\n          return new DHExchange('modp2', 'sha1', ...args);\n        case 'diffie-hellman-group14-sha1':\n          return new DHExchange('modp14', 'sha1', ...args);\n        case 'diffie-hellman-group14-sha256':\n          return new DHExchange('modp14', 'sha256', ...args);\n        case 'diffie-hellman-group15-sha512':\n          return new DHExchange('modp15', 'sha512', ...args);\n        case 'diffie-hellman-group16-sha512':\n          return new DHExchange('modp16', 'sha512', ...args);\n        case 'diffie-hellman-group17-sha512':\n          return new DHExchange('modp17', 'sha512', ...args);\n        case 'diffie-hellman-group18-sha512':\n          return new DHExchange('modp18', 'sha512', ...args);\n\n        case 'diffie-hellman-group-exchange-sha1':\n          return new DHGroupExchange('sha1', ...args);\n        case 'diffie-hellman-group-exchange-sha256':\n          return new DHGroupExchange('sha256', ...args);\n      }\n      throw new Error(`Unsupported key exchange algorithm: ${kexType}`);\n    }\n    throw new Error(`Invalid key exchange type: ${kexType}`);\n  };\n})();\n\nconst KexInit = (() => {\n  const KEX_PROPERTY_NAMES = [\n    'kex',\n    'serverHostKey',\n    ['cs', 'cipher' ],\n    ['sc', 'cipher' ],\n    ['cs', 'mac' ],\n    ['sc', 'mac' ],\n    ['cs', 'compress' ],\n    ['sc', 'compress' ],\n    ['cs', 'lang' ],\n    ['sc', 'lang' ],\n  ];\n  return class KexInit {\n    constructor(obj) {\n      if (typeof obj !== 'object' || obj === null)\n        throw new TypeError('Argument must be an object');\n\n      const lists = {\n        kex: undefined,\n        serverHostKey: undefined,\n        cs: {\n          cipher: undefined,\n          mac: undefined,\n          compress: undefined,\n          lang: undefined,\n        },\n        sc: {\n          cipher: undefined,\n          mac: undefined,\n          compress: undefined,\n          lang: undefined,\n        },\n\n        all: undefined,\n      };\n      let totalSize = 0;\n      for (const prop of KEX_PROPERTY_NAMES) {\n        let base;\n        let val;\n        let desc;\n        let key;\n        if (typeof prop === 'string') {\n          base = lists;\n          val = obj[prop];\n          desc = key = prop;\n        } else {\n          const parent = prop[0];\n          base = lists[parent];\n          key = prop[1];\n          val = obj[parent][key];\n          desc = `${parent}.${key}`;\n        }\n        const entry = { array: undefined, buffer: undefined };\n        if (Buffer.isBuffer(val)) {\n          entry.array = ('' + val).split(',');\n          entry.buffer = val;\n          totalSize += 4 + val.length;\n        } else {\n          if (typeof val === 'string')\n            val = val.split(',');\n          if (Array.isArray(val)) {\n            entry.array = val;\n            entry.buffer = Buffer.from(val.join(','));\n          } else {\n            throw new TypeError(`Invalid \\`${desc}\\` type: ${typeof val}`);\n          }\n          totalSize += 4 + entry.buffer.length;\n        }\n        base[key] = entry;\n      }\n\n      const all = Buffer.allocUnsafe(totalSize);\n      lists.all = all;\n\n      let allPos = 0;\n      for (const prop of KEX_PROPERTY_NAMES) {\n        let data;\n        if (typeof prop === 'string')\n          data = lists[prop].buffer;\n        else\n          data = lists[prop[0]][prop[1]].buffer;\n        allPos = writeUInt32BE(all, data.length, allPos);\n        all.set(data, allPos);\n        allPos += data.length;\n      }\n\n      this.totalSize = totalSize;\n      this.lists = lists;\n    }\n    copyAllTo(buf, offset) {\n      const src = this.lists.all;\n      if (typeof offset !== 'number')\n        throw new TypeError(`Invalid offset value: ${typeof offset}`);\n      if (buf.length - offset < src.length)\n        throw new Error('Insufficient space to copy list');\n      buf.set(src, offset);\n      return src.length;\n    }\n  };\n})();\n\nconst hashString = (() => {\n  const LEN = Buffer.allocUnsafe(4);\n  return (hash, buf) => {\n    writeUInt32BE(LEN, buf.length, 0);\n    hash.update(LEN);\n    hash.update(buf);\n  };\n})();\n\nfunction generateKEXVal(len, hashName, secret, exchangeHash, sessionID, char) {\n  let ret;\n  if (len) {\n    let digest = createHash(hashName)\n                   .update(secret)\n                   .update(exchangeHash)\n                   .update(char)\n                   .update(sessionID)\n                   .digest();\n    while (digest.length < len) {\n      const chunk = createHash(hashName)\n                      .update(secret)\n                      .update(exchangeHash)\n                      .update(digest)\n                      .digest();\n      const extended = Buffer.allocUnsafe(digest.length + chunk.length);\n      extended.set(digest, 0);\n      extended.set(chunk, digest.length);\n      digest = extended;\n    }\n    if (digest.length === len)\n      ret = digest;\n    else\n      ret = new FastBuffer(digest.buffer, digest.byteOffset, len);\n  } else {\n    ret = EMPTY_BUFFER;\n  }\n  return ret;\n}\n\nfunction onKEXPayload(state, payload) {\n  // XXX: move this to the Decipher implementations?\n  if (payload.length === 0) {\n    this._debug && this._debug('Inbound: Skipping empty packet payload');\n    return;\n  }\n\n  if (this._skipNextInboundPacket) {\n    this._skipNextInboundPacket = false;\n    return;\n  }\n\n  payload = this._packetRW.read.read(payload);\n\n  const type = payload[0];\n  switch (type) {\n    case MESSAGE.DISCONNECT:\n    case MESSAGE.IGNORE:\n    case MESSAGE.UNIMPLEMENTED:\n    case MESSAGE.DEBUG:\n      if (!MESSAGE_HANDLERS)\n        MESSAGE_HANDLERS = require('./handlers.js');\n      return MESSAGE_HANDLERS[type](this, payload);\n    case MESSAGE.KEXINIT:\n      if (!state.firstPacket) {\n        return doFatalError(\n          this,\n          'Received extra KEXINIT during handshake',\n          'handshake',\n          DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n        );\n      }\n      state.firstPacket = false;\n      return handleKexInit(this, payload);\n    default:\n      if (type < 20 || type > 49) {\n        return doFatalError(\n          this,\n          `Received unexpected packet type ${type}`,\n          'handshake',\n          DISCONNECT_REASON.KEY_EXCHANGE_FAILED\n        );\n      }\n  }\n\n  return this._kex.parse(payload);\n}\n\nfunction dhEstimate(neg) {\n  const csCipher = CIPHER_INFO[neg.cs.cipher];\n  const scCipher = CIPHER_INFO[neg.sc.cipher];\n  // XXX: if OpenSSH's `umac-*` MACs are ever supported, their key lengths will\n  // also need to be considered when calculating `bits`\n  const bits = Math.max(\n    0,\n    (csCipher.sslName === 'des-ede3-cbc' ? 14 : csCipher.keyLen),\n    csCipher.blockLen,\n    csCipher.ivLen,\n    (scCipher.sslName === 'des-ede3-cbc' ? 14 : scCipher.keyLen),\n    scCipher.blockLen,\n    scCipher.ivLen\n  ) * 8;\n  if (bits <= 112)\n    return 2048;\n  if (bits <= 128)\n    return 3072;\n  if (bits <= 192)\n    return 7680;\n  return 8192;\n}\n\nfunction trySendNEWKEYS(kex) {\n  if (!kex._sentNEWKEYS) {\n    kex._protocol._debug && kex._protocol._debug(\n      'Outbound: Sending NEWKEYS'\n    );\n    const p = kex._protocol._packetRW.write.allocStartKEX;\n    const packet = kex._protocol._packetRW.write.alloc(1, true);\n    packet[p] = MESSAGE.NEWKEYS;\n    kex._protocol._cipher.encrypt(\n      kex._protocol._packetRW.write.finalize(packet, true)\n    );\n    kex._sentNEWKEYS = true;\n  }\n}\n\nmodule.exports = {\n  KexInit,\n  kexinit,\n  onKEXPayload,\n  DEFAULT_KEXINIT_CLIENT: new KexInit({\n    kex: DEFAULT_KEX.concat(['ext-info-c']),\n    serverHostKey: DEFAULT_SERVER_HOST_KEY,\n    cs: {\n      cipher: DEFAULT_CIPHER,\n      mac: DEFAULT_MAC,\n      compress: DEFAULT_COMPRESSION,\n      lang: [],\n    },\n    sc: {\n      cipher: DEFAULT_CIPHER,\n      mac: DEFAULT_MAC,\n      compress: DEFAULT_COMPRESSION,\n      lang: [],\n    },\n  }),\n  DEFAULT_KEXINIT_SERVER: new KexInit({\n    kex: DEFAULT_KEX,\n    serverHostKey: DEFAULT_SERVER_HOST_KEY,\n    cs: {\n      cipher: DEFAULT_CIPHER,\n      mac: DEFAULT_MAC,\n      compress: DEFAULT_COMPRESSION,\n      lang: [],\n    },\n    sc: {\n      cipher: DEFAULT_CIPHER,\n      mac: DEFAULT_MAC,\n      compress: DEFAULT_COMPRESSION,\n      lang: [],\n    },\n  }),\n  HANDLERS: {\n    [MESSAGE.KEXINIT]: handleKexInit,\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}