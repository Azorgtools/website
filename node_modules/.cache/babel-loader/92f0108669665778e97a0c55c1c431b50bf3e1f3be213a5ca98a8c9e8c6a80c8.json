{"ast":null,"code":"// TODO:\n//    * add `.connected` or similar property to allow immediate connection\n//      status checking\n//    * add/improve debug output during user authentication phase\n'use strict';\n\nconst {\n  createHash,\n  getHashes,\n  randomFillSync\n} = require('crypto');\nconst {\n  Socket\n} = require('net');\nconst {\n  lookup: dnsLookup\n} = require('dns');\nconst EventEmitter = require('events');\nconst HASHES = getHashes();\nconst {\n  COMPAT,\n  CHANNEL_EXTENDED_DATATYPE: {\n    STDERR\n  },\n  CHANNEL_OPEN_FAILURE,\n  DEFAULT_CIPHER,\n  DEFAULT_COMPRESSION,\n  DEFAULT_KEX,\n  DEFAULT_MAC,\n  DEFAULT_SERVER_HOST_KEY,\n  DISCONNECT_REASON,\n  DISCONNECT_REASON_BY_VALUE,\n  SUPPORTED_CIPHER,\n  SUPPORTED_COMPRESSION,\n  SUPPORTED_KEX,\n  SUPPORTED_MAC,\n  SUPPORTED_SERVER_HOST_KEY\n} = require('./protocol/constants.js');\nconst {\n  init: cryptoInit\n} = require('./protocol/crypto.js');\nconst Protocol = require('./protocol/Protocol.js');\nconst {\n  parseKey\n} = require('./protocol/keyParser.js');\nconst {\n  SFTP\n} = require('./protocol/SFTP.js');\nconst {\n  bufferCopy,\n  makeBufferParser,\n  makeError,\n  readUInt32BE,\n  sigSSHToASN1,\n  writeUInt32BE\n} = require('./protocol/utils.js');\nconst {\n  AgentContext,\n  createAgent,\n  isAgent\n} = require('./agent.js');\nconst {\n  Channel,\n  MAX_WINDOW,\n  PACKET_SIZE,\n  windowAdjust,\n  WINDOW_THRESHOLD\n} = require('./Channel.js');\nconst {\n  ChannelManager,\n  generateAlgorithmList,\n  isWritable,\n  onChannelOpenFailure,\n  onCHANNEL_CLOSE\n} = require('./utils.js');\nconst bufferParser = makeBufferParser();\nconst sigParser = makeBufferParser();\nconst RE_OPENSSH = /^OpenSSH_(?:(?![0-4])\\d)|(?:\\d{2,})/;\nconst noop = err => {};\nclass Client extends EventEmitter {\n  constructor() {\n    super();\n    this.config = {\n      host: undefined,\n      port: undefined,\n      localAddress: undefined,\n      localPort: undefined,\n      forceIPv4: undefined,\n      forceIPv6: undefined,\n      keepaliveCountMax: undefined,\n      keepaliveInterval: undefined,\n      readyTimeout: undefined,\n      ident: undefined,\n      username: undefined,\n      password: undefined,\n      privateKey: undefined,\n      tryKeyboard: undefined,\n      agent: undefined,\n      allowAgentFwd: undefined,\n      authHandler: undefined,\n      hostHashAlgo: undefined,\n      hostHashCb: undefined,\n      strictVendor: undefined,\n      debug: undefined\n    };\n    this._agent = undefined;\n    this._readyTimeout = undefined;\n    this._chanMgr = undefined;\n    this._callbacks = undefined;\n    this._forwarding = undefined;\n    this._forwardingUnix = undefined;\n    this._acceptX11 = undefined;\n    this._agentFwdEnabled = undefined;\n    this._remoteVer = undefined;\n    this._protocol = undefined;\n    this._sock = undefined;\n    this._resetKA = undefined;\n  }\n  connect(cfg) {\n    var _this = this;\n    if (this._sock && isWritable(this._sock)) {\n      this.once('close', () => {\n        this.connect(cfg);\n      });\n      this.end();\n      return this;\n    }\n    this.config.host = cfg.hostname || cfg.host || 'localhost';\n    this.config.port = cfg.port || 22;\n    this.config.localAddress = typeof cfg.localAddress === 'string' ? cfg.localAddress : undefined;\n    this.config.localPort = typeof cfg.localPort === 'string' || typeof cfg.localPort === 'number' ? cfg.localPort : undefined;\n    this.config.forceIPv4 = cfg.forceIPv4 || false;\n    this.config.forceIPv6 = cfg.forceIPv6 || false;\n    this.config.keepaliveCountMax = typeof cfg.keepaliveCountMax === 'number' && cfg.keepaliveCountMax >= 0 ? cfg.keepaliveCountMax : 3;\n    this.config.keepaliveInterval = typeof cfg.keepaliveInterval === 'number' && cfg.keepaliveInterval > 0 ? cfg.keepaliveInterval : 0;\n    this.config.readyTimeout = typeof cfg.readyTimeout === 'number' && cfg.readyTimeout >= 0 ? cfg.readyTimeout : 20000;\n    this.config.ident = typeof cfg.ident === 'string' || Buffer.isBuffer(cfg.ident) ? cfg.ident : undefined;\n    const algorithms = {\n      kex: undefined,\n      serverHostKey: undefined,\n      cs: {\n        cipher: undefined,\n        mac: undefined,\n        compress: undefined,\n        lang: []\n      },\n      sc: undefined\n    };\n    let allOfferDefaults = true;\n    if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {\n      algorithms.kex = generateAlgorithmList(cfg.algorithms.kex, DEFAULT_KEX, SUPPORTED_KEX);\n      if (algorithms.kex !== DEFAULT_KEX) allOfferDefaults = false;\n      algorithms.serverHostKey = generateAlgorithmList(cfg.algorithms.serverHostKey, DEFAULT_SERVER_HOST_KEY, SUPPORTED_SERVER_HOST_KEY);\n      if (algorithms.serverHostKey !== DEFAULT_SERVER_HOST_KEY) allOfferDefaults = false;\n      algorithms.cs.cipher = generateAlgorithmList(cfg.algorithms.cipher, DEFAULT_CIPHER, SUPPORTED_CIPHER);\n      if (algorithms.cs.cipher !== DEFAULT_CIPHER) allOfferDefaults = false;\n      algorithms.cs.mac = generateAlgorithmList(cfg.algorithms.hmac, DEFAULT_MAC, SUPPORTED_MAC);\n      if (algorithms.cs.mac !== DEFAULT_MAC) allOfferDefaults = false;\n      algorithms.cs.compress = generateAlgorithmList(cfg.algorithms.compress, DEFAULT_COMPRESSION, SUPPORTED_COMPRESSION);\n      if (algorithms.cs.compress !== DEFAULT_COMPRESSION) allOfferDefaults = false;\n      if (!allOfferDefaults) algorithms.sc = algorithms.cs;\n    }\n    if (typeof cfg.username === 'string') this.config.username = cfg.username;else if (typeof cfg.user === 'string') this.config.username = cfg.user;else throw new Error('Invalid username');\n    this.config.password = typeof cfg.password === 'string' ? cfg.password : undefined;\n    this.config.privateKey = typeof cfg.privateKey === 'string' || Buffer.isBuffer(cfg.privateKey) ? cfg.privateKey : undefined;\n    this.config.localHostname = typeof cfg.localHostname === 'string' ? cfg.localHostname : undefined;\n    this.config.localUsername = typeof cfg.localUsername === 'string' ? cfg.localUsername : undefined;\n    this.config.tryKeyboard = cfg.tryKeyboard === true;\n    if (typeof cfg.agent === 'string' && cfg.agent.length) this.config.agent = createAgent(cfg.agent);else if (isAgent(cfg.agent)) this.config.agent = cfg.agent;else this.config.agent = undefined;\n    this.config.allowAgentFwd = cfg.agentForward === true && this.config.agent !== undefined;\n    let authHandler = this.config.authHandler = typeof cfg.authHandler === 'function' || Array.isArray(cfg.authHandler) ? cfg.authHandler : undefined;\n    this.config.strictVendor = typeof cfg.strictVendor === 'boolean' ? cfg.strictVendor : true;\n    const debug = this.config.debug = typeof cfg.debug === 'function' ? cfg.debug : undefined;\n    if (cfg.agentForward === true && !this.config.allowAgentFwd) {\n      throw new Error('You must set a valid agent path to allow agent forwarding');\n    }\n    let callbacks = this._callbacks = [];\n    this._chanMgr = new ChannelManager(this);\n    this._forwarding = {};\n    this._forwardingUnix = {};\n    this._acceptX11 = 0;\n    this._agentFwdEnabled = false;\n    this._agent = this.config.agent ? this.config.agent : undefined;\n    this._remoteVer = undefined;\n    let privateKey;\n    if (this.config.privateKey) {\n      privateKey = parseKey(this.config.privateKey, cfg.passphrase);\n      if (privateKey instanceof Error) throw new Error(`Cannot parse privateKey: ${privateKey.message}`);\n      if (Array.isArray(privateKey)) {\n        // OpenSSH's newer format only stores 1 key for now\n        privateKey = privateKey[0];\n      }\n      if (privateKey.getPrivatePEM() === null) {\n        throw new Error('privateKey value does not contain a (valid) private key');\n      }\n    }\n    let hostVerifier;\n    if (typeof cfg.hostVerifier === 'function') {\n      const hashCb = cfg.hostVerifier;\n      let hasher;\n      if (HASHES.indexOf(cfg.hostHash) !== -1) {\n        // Default to old behavior of hashing on user's behalf\n        hasher = createHash(cfg.hostHash);\n      }\n      hostVerifier = (key, verify) => {\n        if (hasher) {\n          hasher.update(key);\n          key = hasher.digest('hex');\n        }\n        const ret = hashCb(key, verify);\n        if (ret !== undefined) verify(ret);\n      };\n    }\n    const sock = this._sock = cfg.sock || new Socket();\n    let ready = false;\n    let sawHeader = false;\n    if (this._protocol) this._protocol.cleanup();\n    const DEBUG_HANDLER = !debug ? undefined : (p, display, msg) => {\n      debug(`Debug output from server: ${JSON.stringify(msg)}`);\n    };\n    let serverSigAlgs;\n    const proto = this._protocol = new Protocol({\n      ident: this.config.ident,\n      offer: allOfferDefaults ? undefined : algorithms,\n      onWrite: data => {\n        if (isWritable(sock)) sock.write(data);\n      },\n      onError: err => {\n        if (err.level === 'handshake') clearTimeout(this._readyTimeout);\n        if (!proto._destruct) sock.removeAllListeners('data');\n        this.emit('error', err);\n        try {\n          sock.end();\n        } catch {}\n      },\n      onHeader: header => {\n        sawHeader = true;\n        this._remoteVer = header.versions.software;\n        if (header.greeting) this.emit('greeting', header.greeting);\n      },\n      onHandshakeComplete: negotiated => {\n        this.emit('handshake', negotiated);\n        if (!ready) {\n          ready = true;\n          proto.service('ssh-userauth');\n        }\n      },\n      debug,\n      hostVerifier,\n      messageHandlers: {\n        DEBUG: DEBUG_HANDLER,\n        DISCONNECT: (p, reason, desc) => {\n          if (reason !== DISCONNECT_REASON.BY_APPLICATION) {\n            if (!desc) {\n              desc = DISCONNECT_REASON_BY_VALUE[reason];\n              if (desc === undefined) desc = `Unexpected disconnection reason: ${reason}`;\n            }\n            const err = new Error(desc);\n            err.code = reason;\n            this.emit('error', err);\n          }\n          sock.end();\n        },\n        SERVICE_ACCEPT: (p, name) => {\n          if (name === 'ssh-userauth') tryNextAuth();\n        },\n        EXT_INFO: (p, exts) => {\n          if (serverSigAlgs === undefined) {\n            for (const ext of exts) {\n              if (ext.name === 'server-sig-algs') {\n                serverSigAlgs = ext.algs;\n                return;\n              }\n            }\n            serverSigAlgs = null;\n          }\n        },\n        USERAUTH_BANNER: (p, msg) => {\n          this.emit('banner', msg);\n        },\n        USERAUTH_SUCCESS: p => {\n          // Start keepalive mechanism\n          resetKA();\n          clearTimeout(this._readyTimeout);\n          this.emit('ready');\n        },\n        USERAUTH_FAILURE: (p, authMethods, partialSuccess) => {\n          // For key-based authentication, check if we should retry the current\n          // key with a different algorithm first\n          if (curAuth.keyAlgos) {\n            const oldKeyAlgo = curAuth.keyAlgos[0][0];\n            if (debug) debug(`Client: ${curAuth.type} (${oldKeyAlgo}) auth failed`);\n            curAuth.keyAlgos.shift();\n            if (curAuth.keyAlgos.length) {\n              const [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];\n              switch (curAuth.type) {\n                case 'agent':\n                  proto.authPK(curAuth.username, curAuth.agentCtx.currentKey(), keyAlgo);\n                  return;\n                case 'publickey':\n                  proto.authPK(curAuth.username, curAuth.key, keyAlgo);\n                  return;\n                case 'hostbased':\n                  proto.authHostbased(curAuth.username, curAuth.key, curAuth.localHostname, curAuth.localUsername, keyAlgo, (buf, cb) => {\n                    const signature = curAuth.key.sign(buf, hashAlgo);\n                    if (signature instanceof Error) {\n                      signature.message = `Error while signing with key: ${signature.message}`;\n                      signature.level = 'client-authentication';\n                      this.emit('error', signature);\n                      return tryNextAuth();\n                    }\n                    cb(signature);\n                  });\n                  return;\n              }\n            } else {\n              curAuth.keyAlgos = undefined;\n            }\n          }\n          if (curAuth.type === 'agent') {\n            const pos = curAuth.agentCtx.pos();\n            debug && debug(`Client: Agent key #${pos + 1} failed`);\n            return tryNextAgentKey();\n          }\n          debug && debug(`Client: ${curAuth.type} auth failed`);\n          curPartial = partialSuccess;\n          curAuthsLeft = authMethods;\n          tryNextAuth();\n        },\n        USERAUTH_PASSWD_CHANGEREQ: (p, prompt) => {\n          if (curAuth.type === 'password') {\n            // TODO: support a `changePrompt()` on `curAuth` that defaults to\n            // emitting 'change password' as before\n            this.emit('change password', prompt, newPassword => {\n              proto.authPassword(this.config.username, this.config.password, newPassword);\n            });\n          }\n        },\n        USERAUTH_PK_OK: p => {\n          let keyAlgo;\n          let hashAlgo;\n          if (curAuth.keyAlgos) [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];\n          if (curAuth.type === 'agent') {\n            const key = curAuth.agentCtx.currentKey();\n            proto.authPK(curAuth.username, key, keyAlgo, (buf, cb) => {\n              const opts = {\n                hash: hashAlgo\n              };\n              curAuth.agentCtx.sign(key, buf, opts, (err, signed) => {\n                if (err) {\n                  err.level = 'agent';\n                  this.emit('error', err);\n                } else {\n                  return cb(signed);\n                }\n                tryNextAgentKey();\n              });\n            });\n          } else if (curAuth.type === 'publickey') {\n            proto.authPK(curAuth.username, curAuth.key, keyAlgo, (buf, cb) => {\n              const signature = curAuth.key.sign(buf, hashAlgo);\n              if (signature instanceof Error) {\n                signature.message = `Error signing data with key: ${signature.message}`;\n                signature.level = 'client-authentication';\n                this.emit('error', signature);\n                return tryNextAuth();\n              }\n              cb(signature);\n            });\n          }\n        },\n        USERAUTH_INFO_REQUEST: (p, name, instructions, prompts) => {\n          if (curAuth.type === 'keyboard-interactive') {\n            const nprompts = Array.isArray(prompts) ? prompts.length : 0;\n            if (nprompts === 0) {\n              debug && debug('Client: Sending automatic USERAUTH_INFO_RESPONSE');\n              proto.authInfoRes();\n              return;\n            }\n            // We sent a keyboard-interactive user authentication request and\n            // now the server is sending us the prompts we need to present to\n            // the user\n            curAuth.prompt(name, instructions, '', prompts, answers => {\n              proto.authInfoRes(answers);\n            });\n          }\n        },\n        REQUEST_SUCCESS: (p, data) => {\n          if (callbacks.length) callbacks.shift()(false, data);\n        },\n        REQUEST_FAILURE: p => {\n          if (callbacks.length) callbacks.shift()(true);\n        },\n        GLOBAL_REQUEST: (p, name, wantReply, data) => {\n          switch (name) {\n            case 'hostkeys-00@openssh.com':\n              // Automatically verify keys before passing to end user\n              hostKeysProve(this, data, (err, keys) => {\n                if (err) return;\n                this.emit('hostkeys', keys);\n              });\n              if (wantReply) proto.requestSuccess();\n              break;\n            default:\n              // Auto-reject all other global requests, this can be especially\n              // useful if the server is sending us dummy keepalive global\n              // requests\n              if (wantReply) proto.requestFailure();\n          }\n        },\n        CHANNEL_OPEN: (p, info) => {\n          // Handle incoming requests from server, typically a forwarded TCP or\n          // X11 connection\n          onCHANNEL_OPEN(this, info);\n        },\n        CHANNEL_OPEN_CONFIRMATION: (p, info) => {\n          const channel = this._chanMgr.get(info.recipient);\n          if (typeof channel !== 'function') return;\n          const isSFTP = channel.type === 'sftp';\n          const type = isSFTP ? 'session' : channel.type;\n          const chanInfo = {\n            type,\n            incoming: {\n              id: info.recipient,\n              window: MAX_WINDOW,\n              packetSize: PACKET_SIZE,\n              state: 'open'\n            },\n            outgoing: {\n              id: info.sender,\n              window: info.window,\n              packetSize: info.packetSize,\n              state: 'open'\n            }\n          };\n          const instance = isSFTP ? new SFTP(this, chanInfo, {\n            debug\n          }) : new Channel(this, chanInfo);\n          this._chanMgr.update(info.recipient, instance);\n          channel(undefined, instance);\n        },\n        CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'function') return;\n          const info = {\n            reason,\n            description\n          };\n          onChannelOpenFailure(this, recipient, info, channel);\n        },\n        CHANNEL_DATA: (p, recipient, data) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n\n          // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n          if (channel.incoming.window === 0) return;\n          channel.incoming.window -= data.length;\n          if (channel.push(data) === false) {\n            channel._waitChanDrain = true;\n            return;\n          }\n          if (channel.incoming.window <= WINDOW_THRESHOLD) windowAdjust(channel);\n        },\n        CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {\n          if (type !== STDERR) return;\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n\n          // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n          if (channel.incoming.window === 0) return;\n          channel.incoming.window -= data.length;\n          if (!channel.stderr.push(data)) {\n            channel._waitChanDrain = true;\n            return;\n          }\n          if (channel.incoming.window <= WINDOW_THRESHOLD) windowAdjust(channel);\n        },\n        CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n\n          // The other side is allowing us to send `amount` more bytes of data\n          channel.outgoing.window += amount;\n          if (channel._waitWindow) {\n            channel._waitWindow = false;\n            if (channel._chunk) {\n              channel._write(channel._chunk, null, channel._chunkcb);\n            } else if (channel._chunkcb) {\n              channel._chunkcb();\n            } else if (channel._chunkErr) {\n              channel.stderr._write(channel._chunkErr, null, channel._chunkcbErr);\n            } else if (channel._chunkcbErr) {\n              channel._chunkcbErr();\n            }\n          }\n        },\n        CHANNEL_SUCCESS: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          this._resetKA();\n          if (channel._callbacks.length) channel._callbacks.shift()(false);\n        },\n        CHANNEL_FAILURE: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          this._resetKA();\n          if (channel._callbacks.length) channel._callbacks.shift()(true);\n        },\n        CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          const exit = channel._exit;\n          if (exit.code !== undefined) return;\n          switch (type) {\n            case 'exit-status':\n              channel.emit('exit', exit.code = data);\n              return;\n            case 'exit-signal':\n              channel.emit('exit', exit.code = null, exit.signal = `SIG${data.signal}`, exit.dump = data.coreDumped, exit.desc = data.errorMessage);\n              return;\n          }\n\n          // Keepalive request? OpenSSH will send one as a channel request if\n          // there is a channel open\n\n          if (wantReply) p.channelFailure(channel.outgoing.id);\n        },\n        CHANNEL_EOF: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          if (channel.incoming.state !== 'open') return;\n          channel.incoming.state = 'eof';\n          if (channel.readable) channel.push(null);\n          if (channel.stderr.readable) channel.stderr.push(null);\n        },\n        CHANNEL_CLOSE: (p, recipient) => {\n          onCHANNEL_CLOSE(this, recipient, this._chanMgr.get(recipient));\n        }\n      }\n    });\n    sock.pause();\n\n    // TODO: check keepalive implementation\n    // Keepalive-related\n    const kainterval = this.config.keepaliveInterval;\n    const kacountmax = this.config.keepaliveCountMax;\n    let kacount = 0;\n    let katimer;\n    const sendKA = () => {\n      if (++kacount > kacountmax) {\n        clearInterval(katimer);\n        if (sock.readable) {\n          const err = new Error('Keepalive timeout');\n          err.level = 'client-timeout';\n          this.emit('error', err);\n          sock.destroy();\n        }\n        return;\n      }\n      if (isWritable(sock)) {\n        // Append dummy callback to keep correct callback order\n        callbacks.push(resetKA);\n        proto.ping();\n      } else {\n        clearInterval(katimer);\n      }\n    };\n    function resetKA() {\n      if (kainterval > 0) {\n        kacount = 0;\n        clearInterval(katimer);\n        if (isWritable(sock)) katimer = setInterval(sendKA, kainterval);\n      }\n    }\n    this._resetKA = resetKA;\n    const onDone = (() => {\n      let called = false;\n      return () => {\n        if (called) return;\n        called = true;\n        if (wasConnected && !sawHeader) {\n          const err = makeError('Connection lost before handshake', 'protocol', true);\n          this.emit('error', err);\n        }\n      };\n    })();\n    const onConnect = (() => {\n      let called = false;\n      return () => {\n        if (called) return;\n        called = true;\n        wasConnected = true;\n        debug && debug('Socket connected');\n        this.emit('connect');\n        cryptoInit.then(() => {\n          proto.start();\n          sock.on('data', data => {\n            try {\n              proto.parse(data, 0, data.length);\n            } catch (ex) {\n              this.emit('error', ex);\n              try {\n                if (isWritable(sock)) sock.end();\n              } catch {}\n            }\n          });\n\n          // Drain stderr if we are connection hopping using an exec stream\n          if (sock.stderr && typeof sock.stderr.resume === 'function') sock.stderr.resume();\n          sock.resume();\n        }).catch(err => {\n          this.emit('error', err);\n          try {\n            if (isWritable(sock)) sock.end();\n          } catch {}\n        });\n      };\n    })();\n    let wasConnected = false;\n    sock.on('connect', onConnect).on('timeout', () => {\n      this.emit('timeout');\n    }).on('error', err => {\n      debug && debug(`Socket error: ${err.message}`);\n      clearTimeout(this._readyTimeout);\n      err.level = 'client-socket';\n      this.emit('error', err);\n    }).on('end', () => {\n      debug && debug('Socket ended');\n      onDone();\n      proto.cleanup();\n      clearTimeout(this._readyTimeout);\n      clearInterval(katimer);\n      this.emit('end');\n    }).on('close', () => {\n      debug && debug('Socket closed');\n      onDone();\n      proto.cleanup();\n      clearTimeout(this._readyTimeout);\n      clearInterval(katimer);\n      this.emit('close');\n\n      // Notify outstanding channel requests of disconnection ...\n      const callbacks_ = callbacks;\n      callbacks = this._callbacks = [];\n      const err = new Error('No response from server');\n      for (let i = 0; i < callbacks_.length; ++i) callbacks_[i](err);\n\n      // Simulate error for any channels waiting to be opened\n      this._chanMgr.cleanup(err);\n    });\n\n    // Begin authentication handling ===========================================\n    let curAuth;\n    let curPartial = null;\n    let curAuthsLeft = null;\n    const authsAllowed = ['none'];\n    if (this.config.password !== undefined) authsAllowed.push('password');\n    if (privateKey !== undefined) authsAllowed.push('publickey');\n    if (this._agent !== undefined) authsAllowed.push('agent');\n    if (this.config.tryKeyboard) authsAllowed.push('keyboard-interactive');\n    if (privateKey !== undefined && this.config.localHostname !== undefined && this.config.localUsername !== undefined) {\n      authsAllowed.push('hostbased');\n    }\n    if (Array.isArray(authHandler)) authHandler = makeSimpleAuthHandler(authHandler);else if (typeof authHandler !== 'function') authHandler = makeSimpleAuthHandler(authsAllowed);\n    let hasSentAuth = false;\n    const doNextAuth = nextAuth => {\n      if (hasSentAuth) return;\n      hasSentAuth = true;\n      if (nextAuth === false) {\n        const err = new Error('All configured authentication methods failed');\n        err.level = 'client-authentication';\n        this.emit('error', err);\n        this.end();\n        return;\n      }\n      if (typeof nextAuth === 'string') {\n        // Remain backwards compatible with original `authHandler()` usage,\n        // which only supported passing names of next method to try using data\n        // from the `connect()` config object\n\n        const type = nextAuth;\n        if (authsAllowed.indexOf(type) === -1) return skipAuth(`Authentication method not allowed: ${type}`);\n        const username = this.config.username;\n        switch (type) {\n          case 'password':\n            nextAuth = {\n              type,\n              username,\n              password: this.config.password\n            };\n            break;\n          case 'publickey':\n            nextAuth = {\n              type,\n              username,\n              key: privateKey\n            };\n            break;\n          case 'hostbased':\n            nextAuth = {\n              type,\n              username,\n              key: privateKey,\n              localHostname: this.config.localHostname,\n              localUsername: this.config.localUsername\n            };\n            break;\n          case 'agent':\n            nextAuth = {\n              type,\n              username,\n              agentCtx: new AgentContext(this._agent)\n            };\n            break;\n          case 'keyboard-interactive':\n            nextAuth = {\n              type,\n              username,\n              prompt: function () {\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n                }\n                return _this.emit('keyboard-interactive', ...args);\n              }\n            };\n            break;\n          case 'none':\n            nextAuth = {\n              type,\n              username\n            };\n            break;\n          default:\n            return skipAuth(`Skipping unsupported authentication method: ${nextAuth}`);\n        }\n      } else if (typeof nextAuth !== 'object' || nextAuth === null) {\n        return skipAuth(`Skipping invalid authentication attempt: ${nextAuth}`);\n      } else {\n        const username = nextAuth.username;\n        if (typeof username !== 'string') {\n          return skipAuth(`Skipping invalid authentication attempt: ${nextAuth}`);\n        }\n        const type = nextAuth.type;\n        switch (type) {\n          case 'password':\n            {\n              const {\n                password\n              } = nextAuth;\n              if (typeof password !== 'string' && !Buffer.isBuffer(password)) return skipAuth('Skipping invalid password auth attempt');\n              nextAuth = {\n                type,\n                username,\n                password\n              };\n              break;\n            }\n          case 'publickey':\n            {\n              const key = parseKey(nextAuth.key, nextAuth.passphrase);\n              if (key instanceof Error) return skipAuth('Skipping invalid key auth attempt');\n              if (!key.isPrivateKey()) return skipAuth('Skipping non-private key');\n              nextAuth = {\n                type,\n                username,\n                key\n              };\n              break;\n            }\n          case 'hostbased':\n            {\n              const {\n                localHostname,\n                localUsername\n              } = nextAuth;\n              const key = parseKey(nextAuth.key, nextAuth.passphrase);\n              if (key instanceof Error || typeof localHostname !== 'string' || typeof localUsername !== 'string') {\n                return skipAuth('Skipping invalid hostbased auth attempt');\n              }\n              if (!key.isPrivateKey()) return skipAuth('Skipping non-private key');\n              nextAuth = {\n                type,\n                username,\n                key,\n                localHostname,\n                localUsername\n              };\n              break;\n            }\n          case 'agent':\n            {\n              let agent = nextAuth.agent;\n              if (typeof agent === 'string' && agent.length) {\n                agent = createAgent(agent);\n              } else if (!isAgent(agent)) {\n                return skipAuth(`Skipping invalid agent: ${nextAuth.agent}`);\n              }\n              nextAuth = {\n                type,\n                username,\n                agentCtx: new AgentContext(agent)\n              };\n              break;\n            }\n          case 'keyboard-interactive':\n            {\n              const {\n                prompt\n              } = nextAuth;\n              if (typeof prompt !== 'function') {\n                return skipAuth('Skipping invalid keyboard-interactive auth attempt');\n              }\n              nextAuth = {\n                type,\n                username,\n                prompt\n              };\n              break;\n            }\n          case 'none':\n            nextAuth = {\n              type,\n              username\n            };\n            break;\n          default:\n            return skipAuth(`Skipping unsupported authentication method: ${nextAuth}`);\n        }\n      }\n      curAuth = nextAuth;\n\n      // Begin authentication method's process\n      try {\n        const username = curAuth.username;\n        switch (curAuth.type) {\n          case 'password':\n            proto.authPassword(username, curAuth.password);\n            break;\n          case 'publickey':\n            {\n              let keyAlgo;\n              curAuth.keyAlgos = getKeyAlgos(this, curAuth.key, serverSigAlgs);\n              if (curAuth.keyAlgos) {\n                if (curAuth.keyAlgos.length) {\n                  keyAlgo = curAuth.keyAlgos[0][0];\n                } else {\n                  return skipAuth('Skipping key authentication (no mutual hash algorithm)');\n                }\n              }\n              proto.authPK(username, curAuth.key, keyAlgo);\n              break;\n            }\n          case 'hostbased':\n            {\n              let keyAlgo;\n              let hashAlgo;\n              curAuth.keyAlgos = getKeyAlgos(this, curAuth.key, serverSigAlgs);\n              if (curAuth.keyAlgos) {\n                if (curAuth.keyAlgos.length) {\n                  [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];\n                } else {\n                  return skipAuth('Skipping hostbased authentication (no mutual hash algorithm)');\n                }\n              }\n              proto.authHostbased(username, curAuth.key, curAuth.localHostname, curAuth.localUsername, keyAlgo, (buf, cb) => {\n                const signature = curAuth.key.sign(buf, hashAlgo);\n                if (signature instanceof Error) {\n                  signature.message = `Error while signing with key: ${signature.message}`;\n                  signature.level = 'client-authentication';\n                  this.emit('error', signature);\n                  return tryNextAuth();\n                }\n                cb(signature);\n              });\n              break;\n            }\n          case 'agent':\n            curAuth.agentCtx.init(err => {\n              if (err) {\n                err.level = 'agent';\n                this.emit('error', err);\n                return tryNextAuth();\n              }\n              tryNextAgentKey();\n            });\n            break;\n          case 'keyboard-interactive':\n            proto.authKeyboard(username);\n            break;\n          case 'none':\n            proto.authNone(username);\n            break;\n        }\n      } finally {\n        hasSentAuth = false;\n      }\n    };\n    function skipAuth(msg) {\n      debug && debug(msg);\n      process.nextTick(tryNextAuth);\n    }\n    function tryNextAuth() {\n      hasSentAuth = false;\n      const auth = authHandler(curAuthsLeft, curPartial, doNextAuth);\n      if (hasSentAuth || auth === undefined) return;\n      doNextAuth(auth);\n    }\n    const tryNextAgentKey = () => {\n      if (curAuth.type === 'agent') {\n        const key = curAuth.agentCtx.nextKey();\n        if (key === false) {\n          debug && debug('Agent: No more keys left to try');\n          debug && debug('Client: agent auth failed');\n          tryNextAuth();\n        } else {\n          const pos = curAuth.agentCtx.pos();\n          let keyAlgo;\n          curAuth.keyAlgos = getKeyAlgos(this, key, serverSigAlgs);\n          if (curAuth.keyAlgos) {\n            if (curAuth.keyAlgos.length) {\n              keyAlgo = curAuth.keyAlgos[0][0];\n            } else {\n              debug && debug(`Agent: Skipping key #${pos + 1} (no mutual hash algorithm)`);\n              tryNextAgentKey();\n              return;\n            }\n          }\n          debug && debug(`Agent: Trying key #${pos + 1}`);\n          proto.authPK(curAuth.username, key, keyAlgo);\n        }\n      }\n    };\n    const startTimeout = () => {\n      if (this.config.readyTimeout > 0) {\n        this._readyTimeout = setTimeout(() => {\n          const err = new Error('Timed out while waiting for handshake');\n          err.level = 'client-timeout';\n          this.emit('error', err);\n          sock.destroy();\n        }, this.config.readyTimeout);\n      }\n    };\n    if (!cfg.sock) {\n      let host = this.config.host;\n      const forceIPv4 = this.config.forceIPv4;\n      const forceIPv6 = this.config.forceIPv6;\n      debug && debug(`Client: Trying ${host} on port ${this.config.port} ...`);\n      const doConnect = () => {\n        startTimeout();\n        sock.connect({\n          host,\n          port: this.config.port,\n          localAddress: this.config.localAddress,\n          localPort: this.config.localPort\n        });\n        sock.setMaxListeners(0);\n        sock.setTimeout(typeof cfg.timeout === 'number' ? cfg.timeout : 0);\n      };\n      if (!forceIPv4 && !forceIPv6 || forceIPv4 && forceIPv6) {\n        doConnect();\n      } else {\n        dnsLookup(host, forceIPv4 ? 4 : 6, (err, address, family) => {\n          if (err) {\n            const type = forceIPv4 ? 'IPv4' : 'IPv6';\n            const error = new Error(`Error while looking up ${type} address for '${host}': ${err}`);\n            clearTimeout(this._readyTimeout);\n            error.level = 'client-dns';\n            this.emit('error', error);\n            this.emit('close');\n            return;\n          }\n          host = address;\n          doConnect();\n        });\n      }\n    } else {\n      // Custom socket passed in\n      startTimeout();\n      if (typeof sock.connecting === 'boolean') {\n        // net.Socket\n\n        if (!sock.connecting) {\n          // Already connected\n          onConnect();\n        }\n      } else {\n        // Assume socket/stream is already \"connected\"\n        onConnect();\n      }\n    }\n    return this;\n  }\n  end() {\n    if (this._sock && isWritable(this._sock)) {\n      this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n      this._sock.end();\n    }\n    return this;\n  }\n  destroy() {\n    this._sock && isWritable(this._sock) && this._sock.destroy();\n    return this;\n  }\n  exec(cmd, opts, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    if (typeof opts === 'function') {\n      cb = opts;\n      opts = {};\n    }\n    const extraOpts = {\n      allowHalfOpen: opts.allowHalfOpen !== false\n    };\n    openChannel(this, 'session', extraOpts, (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n      const todo = [];\n      function reqCb(err) {\n        if (err) {\n          chan.close();\n          cb(err);\n          return;\n        }\n        if (todo.length) todo.shift()();\n      }\n      if (this.config.allowAgentFwd === true || opts && opts.agentForward === true && this._agent !== undefined) {\n        todo.push(() => reqAgentFwd(chan, reqCb));\n      }\n      if (typeof opts === 'object' && opts !== null) {\n        if (typeof opts.env === 'object' && opts.env !== null) reqEnv(chan, opts.env);\n        if (typeof opts.pty === 'object' && opts.pty !== null || opts.pty === true) {\n          todo.push(() => reqPty(chan, opts.pty, reqCb));\n        }\n        if (typeof opts.x11 === 'object' && opts.x11 !== null || opts.x11 === 'number' || opts.x11 === true) {\n          todo.push(() => reqX11(chan, opts.x11, reqCb));\n        }\n      }\n      todo.push(() => reqExec(chan, cmd, opts, cb));\n      todo.shift()();\n    });\n    return this;\n  }\n  shell(wndopts, opts, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    if (typeof wndopts === 'function') {\n      cb = wndopts;\n      wndopts = opts = undefined;\n    } else if (typeof opts === 'function') {\n      cb = opts;\n      opts = undefined;\n    }\n    if (wndopts && (wndopts.x11 !== undefined || wndopts.env !== undefined)) {\n      opts = wndopts;\n      wndopts = undefined;\n    }\n    openChannel(this, 'session', (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n      const todo = [];\n      function reqCb(err) {\n        if (err) {\n          chan.close();\n          cb(err);\n          return;\n        }\n        if (todo.length) todo.shift()();\n      }\n      if (this.config.allowAgentFwd === true || opts && opts.agentForward === true && this._agent !== undefined) {\n        todo.push(() => reqAgentFwd(chan, reqCb));\n      }\n      if (wndopts !== false) todo.push(() => reqPty(chan, wndopts, reqCb));\n      if (typeof opts === 'object' && opts !== null) {\n        if (typeof opts.env === 'object' && opts.env !== null) reqEnv(chan, opts.env);\n        if (typeof opts.x11 === 'object' && opts.x11 !== null || opts.x11 === 'number' || opts.x11 === true) {\n          todo.push(() => reqX11(chan, opts.x11, reqCb));\n        }\n      }\n      todo.push(() => reqShell(chan, cb));\n      todo.shift()();\n    });\n    return this;\n  }\n  subsys(name, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    openChannel(this, 'session', (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n      reqSubsystem(chan, name, (err, stream) => {\n        if (err) {\n          cb(err);\n          return;\n        }\n        cb(undefined, stream);\n      });\n    });\n    return this;\n  }\n  forwardIn(bindAddr, bindPort, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n\n    // Send a request for the server to start forwarding TCP connections to us\n    // on a particular address and port\n\n    const wantReply = typeof cb === 'function';\n    if (wantReply) {\n      this._callbacks.push((had_err, data) => {\n        if (had_err) {\n          cb(had_err !== true ? had_err : new Error(`Unable to bind to ${bindAddr}:${bindPort}`));\n          return;\n        }\n        let realPort = bindPort;\n        if (bindPort === 0 && data && data.length >= 4) {\n          realPort = readUInt32BE(data, 0);\n          if (!(this._protocol._compatFlags & COMPAT.DYN_RPORT_BUG)) bindPort = realPort;\n        }\n        this._forwarding[`${bindAddr}:${bindPort}`] = realPort;\n        cb(undefined, realPort);\n      });\n    }\n    this._protocol.tcpipForward(bindAddr, bindPort, wantReply);\n    return this;\n  }\n  unforwardIn(bindAddr, bindPort, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n\n    // Send a request to stop forwarding us new connections for a particular\n    // address and port\n\n    const wantReply = typeof cb === 'function';\n    if (wantReply) {\n      this._callbacks.push(had_err => {\n        if (had_err) {\n          cb(had_err !== true ? had_err : new Error(`Unable to unbind from ${bindAddr}:${bindPort}`));\n          return;\n        }\n        delete this._forwarding[`${bindAddr}:${bindPort}`];\n        cb();\n      });\n    }\n    this._protocol.cancelTcpipForward(bindAddr, bindPort, wantReply);\n    return this;\n  }\n  forwardOut(srcIP, srcPort, dstIP, dstPort, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n\n    // Send a request to forward a TCP connection to the server\n\n    const cfg = {\n      srcIP: srcIP,\n      srcPort: srcPort,\n      dstIP: dstIP,\n      dstPort: dstPort\n    };\n    if (typeof cb !== 'function') cb = noop;\n    openChannel(this, 'direct-tcpip', cfg, cb);\n    return this;\n  }\n  openssh_noMoreSessions(cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    const wantReply = typeof cb === 'function';\n    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {\n      if (wantReply) {\n        this._callbacks.push(had_err => {\n          if (had_err) {\n            cb(had_err !== true ? had_err : new Error('Unable to disable future sessions'));\n            return;\n          }\n          cb();\n        });\n      }\n      this._protocol.openssh_noMoreSessions(wantReply);\n      return this;\n    }\n    if (!wantReply) return this;\n    process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    return this;\n  }\n  openssh_forwardInStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    const wantReply = typeof cb === 'function';\n    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {\n      if (wantReply) {\n        this._callbacks.push(had_err => {\n          if (had_err) {\n            cb(had_err !== true ? had_err : new Error(`Unable to bind to ${socketPath}`));\n            return;\n          }\n          this._forwardingUnix[socketPath] = true;\n          cb();\n        });\n      }\n      this._protocol.openssh_streamLocalForward(socketPath, wantReply);\n      return this;\n    }\n    if (!wantReply) return this;\n    process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    return this;\n  }\n  openssh_unforwardInStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    const wantReply = typeof cb === 'function';\n    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {\n      if (wantReply) {\n        this._callbacks.push(had_err => {\n          if (had_err) {\n            cb(had_err !== true ? had_err : new Error(`Unable to unbind from ${socketPath}`));\n            return;\n          }\n          delete this._forwardingUnix[socketPath];\n          cb();\n        });\n      }\n      this._protocol.openssh_cancelStreamLocalForward(socketPath, wantReply);\n      return this;\n    }\n    if (!wantReply) return this;\n    process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    return this;\n  }\n  openssh_forwardOutStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    if (typeof cb !== 'function') cb = noop;\n    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {\n      openChannel(this, 'direct-streamlocal@openssh.com', {\n        socketPath\n      }, cb);\n      return this;\n    }\n    process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    return this;\n  }\n  sftp(cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    openChannel(this, 'sftp', (err, sftp) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n      reqSubsystem(sftp, 'sftp', (err, sftp_) => {\n        if (err) {\n          cb(err);\n          return;\n        }\n        function removeListeners() {\n          sftp.removeListener('ready', onReady);\n          sftp.removeListener('error', onError);\n          sftp.removeListener('exit', onExit);\n          sftp.removeListener('close', onExit);\n        }\n        function onReady() {\n          // TODO: do not remove exit/close in case remote end closes the\n          // channel abruptly and we need to notify outstanding callbacks\n          removeListeners();\n          cb(undefined, sftp);\n        }\n        function onError(err) {\n          removeListeners();\n          cb(err);\n        }\n        function onExit(code, signal) {\n          removeListeners();\n          let msg;\n          if (typeof code === 'number') msg = `Received exit code ${code} while establishing SFTP session`;else if (signal !== undefined) msg = `Received signal ${signal} while establishing SFTP session`;else msg = 'Received unexpected SFTP session termination';\n          const err = new Error(msg);\n          err.code = code;\n          err.signal = signal;\n          cb(err);\n        }\n        sftp.on('ready', onReady).on('error', onError).on('exit', onExit).on('close', onExit);\n        sftp._init();\n      });\n    });\n    return this;\n  }\n  setNoDelay(noDelay) {\n    if (this._sock && typeof this._sock.setNoDelay === 'function') this._sock.setNoDelay(noDelay);\n    return this;\n  }\n}\nfunction openChannel(self, type, opts, cb) {\n  // Ask the server to open a channel for some purpose\n  // (e.g. session (sftp, exec, shell), or forwarding a TCP connection\n  const initWindow = MAX_WINDOW;\n  const maxPacket = PACKET_SIZE;\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  const wrapper = (err, stream) => {\n    cb(err, stream);\n  };\n  wrapper.type = type;\n  const localChan = self._chanMgr.add(wrapper);\n  if (localChan === -1) {\n    cb(new Error('No free channels available'));\n    return;\n  }\n  switch (type) {\n    case 'session':\n    case 'sftp':\n      self._protocol.session(localChan, initWindow, maxPacket);\n      break;\n    case 'direct-tcpip':\n      self._protocol.directTcpip(localChan, initWindow, maxPacket, opts);\n      break;\n    case 'direct-streamlocal@openssh.com':\n      self._protocol.openssh_directStreamLocal(localChan, initWindow, maxPacket, opts);\n      break;\n    default:\n      throw new Error(`Unsupported channel type: ${type}`);\n  }\n}\nfunction reqX11(chan, screen, cb) {\n  // Asks server to start sending us X11 connections\n  const cfg = {\n    single: false,\n    protocol: 'MIT-MAGIC-COOKIE-1',\n    cookie: undefined,\n    screen: 0\n  };\n  if (typeof screen === 'function') {\n    cb = screen;\n  } else if (typeof screen === 'object' && screen !== null) {\n    if (typeof screen.single === 'boolean') cfg.single = screen.single;\n    if (typeof screen.screen === 'number') cfg.screen = screen.screen;\n    if (typeof screen.protocol === 'string') cfg.protocol = screen.protocol;\n    if (typeof screen.cookie === 'string') cfg.cookie = screen.cookie;else if (Buffer.isBuffer(screen.cookie)) cfg.cookie = screen.cookie.hexSlice(0, screen.cookie.length);\n  }\n  if (cfg.cookie === undefined) cfg.cookie = randomCookie();\n  const wantReply = typeof cb === 'function';\n  if (chan.outgoing.state !== 'open') {\n    if (wantReply) cb(new Error('Channel is not open'));\n    return;\n  }\n  if (wantReply) {\n    chan._callbacks.push(had_err => {\n      if (had_err) {\n        cb(had_err !== true ? had_err : new Error('Unable to request X11'));\n        return;\n      }\n      chan._hasX11 = true;\n      ++chan._client._acceptX11;\n      chan.once('close', () => {\n        if (chan._client._acceptX11) --chan._client._acceptX11;\n      });\n      cb();\n    });\n  }\n  chan._client._protocol.x11Forward(chan.outgoing.id, cfg, wantReply);\n}\nfunction reqPty(chan, opts, cb) {\n  let rows = 24;\n  let cols = 80;\n  let width = 640;\n  let height = 480;\n  let term = 'vt100';\n  let modes = null;\n  if (typeof opts === 'function') {\n    cb = opts;\n  } else if (typeof opts === 'object' && opts !== null) {\n    if (typeof opts.rows === 'number') rows = opts.rows;\n    if (typeof opts.cols === 'number') cols = opts.cols;\n    if (typeof opts.width === 'number') width = opts.width;\n    if (typeof opts.height === 'number') height = opts.height;\n    if (typeof opts.term === 'string') term = opts.term;\n    if (typeof opts.modes === 'object') modes = opts.modes;\n  }\n  const wantReply = typeof cb === 'function';\n  if (chan.outgoing.state !== 'open') {\n    if (wantReply) cb(new Error('Channel is not open'));\n    return;\n  }\n  if (wantReply) {\n    chan._callbacks.push(had_err => {\n      if (had_err) {\n        cb(had_err !== true ? had_err : new Error('Unable to request a pseudo-terminal'));\n        return;\n      }\n      cb();\n    });\n  }\n  chan._client._protocol.pty(chan.outgoing.id, rows, cols, height, width, term, modes, wantReply);\n}\nfunction reqAgentFwd(chan, cb) {\n  const wantReply = typeof cb === 'function';\n  if (chan.outgoing.state !== 'open') {\n    wantReply && cb(new Error('Channel is not open'));\n    return;\n  }\n  if (chan._client._agentFwdEnabled) {\n    wantReply && cb(false);\n    return;\n  }\n  chan._client._agentFwdEnabled = true;\n  chan._callbacks.push(had_err => {\n    if (had_err) {\n      chan._client._agentFwdEnabled = false;\n      if (wantReply) {\n        cb(had_err !== true ? had_err : new Error('Unable to request agent forwarding'));\n      }\n      return;\n    }\n    if (wantReply) cb();\n  });\n  chan._client._protocol.openssh_agentForward(chan.outgoing.id, true);\n}\nfunction reqShell(chan, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n  chan._callbacks.push(had_err => {\n    if (had_err) {\n      cb(had_err !== true ? had_err : new Error('Unable to open shell'));\n      return;\n    }\n    chan.subtype = 'shell';\n    cb(undefined, chan);\n  });\n  chan._client._protocol.shell(chan.outgoing.id, true);\n}\nfunction reqExec(chan, cmd, opts, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n  chan._callbacks.push(had_err => {\n    if (had_err) {\n      cb(had_err !== true ? had_err : new Error('Unable to exec'));\n      return;\n    }\n    chan.subtype = 'exec';\n    chan.allowHalfOpen = opts.allowHalfOpen !== false;\n    cb(undefined, chan);\n  });\n  chan._client._protocol.exec(chan.outgoing.id, cmd, true);\n}\nfunction reqEnv(chan, env) {\n  if (chan.outgoing.state !== 'open') return;\n  const keys = Object.keys(env || {});\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    const val = env[key];\n    chan._client._protocol.env(chan.outgoing.id, key, val, false);\n  }\n}\nfunction reqSubsystem(chan, name, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n  chan._callbacks.push(had_err => {\n    if (had_err) {\n      cb(had_err !== true ? had_err : new Error(`Unable to start subsystem: ${name}`));\n      return;\n    }\n    chan.subtype = 'subsystem';\n    cb(undefined, chan);\n  });\n  chan._client._protocol.subsystem(chan.outgoing.id, name, true);\n}\n\n// TODO: inline implementation into single call site\nfunction onCHANNEL_OPEN(self, info) {\n  // The server is trying to open a channel with us, this is usually when\n  // we asked the server to forward us connections on some port and now they\n  // are asking us to accept/deny an incoming connection on their side\n\n  let localChan = -1;\n  let reason;\n  const accept = () => {\n    const chanInfo = {\n      type: info.type,\n      incoming: {\n        id: localChan,\n        window: MAX_WINDOW,\n        packetSize: PACKET_SIZE,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n    const stream = new Channel(self, chanInfo);\n    self._chanMgr.update(localChan, stream);\n    self._protocol.channelOpenConfirm(info.sender, localChan, MAX_WINDOW, PACKET_SIZE);\n    return stream;\n  };\n  const reject = () => {\n    if (reason === undefined) {\n      if (localChan === -1) reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;else reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;\n    }\n    if (localChan !== -1) self._chanMgr.remove(localChan);\n    self._protocol.channelOpenFail(info.sender, reason, '');\n  };\n  const reserveChannel = () => {\n    localChan = self._chanMgr.add();\n    if (localChan === -1) {\n      reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n      if (self.config.debug) {\n        self.config.debug('Client: Automatic rejection of incoming channel open: ' + 'no channels available');\n      }\n    }\n    return localChan !== -1;\n  };\n  const data = info.data;\n  switch (info.type) {\n    case 'forwarded-tcpip':\n      {\n        const val = self._forwarding[`${data.destIP}:${data.destPort}`];\n        if (val !== undefined && reserveChannel()) {\n          if (data.destPort === 0) data.destPort = val;\n          self.emit('tcp connection', data, accept, reject);\n          return;\n        }\n        break;\n      }\n    case 'forwarded-streamlocal@openssh.com':\n      if (self._forwardingUnix[data.socketPath] !== undefined && reserveChannel()) {\n        self.emit('unix connection', data, accept, reject);\n        return;\n      }\n      break;\n    case 'auth-agent@openssh.com':\n      if (self._agentFwdEnabled && typeof self._agent.getStream === 'function' && reserveChannel()) {\n        self._agent.getStream((err, stream) => {\n          if (err) return reject();\n          const upstream = accept();\n          upstream.pipe(stream).pipe(upstream);\n        });\n        return;\n      }\n      break;\n    case 'x11':\n      if (self._acceptX11 !== 0 && reserveChannel()) {\n        self.emit('x11', data, accept, reject);\n        return;\n      }\n      break;\n    default:\n      // Automatically reject any unsupported channel open requests\n      reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;\n      if (self.config.debug) {\n        self.config.debug('Client: Automatic rejection of unsupported incoming channel open ' + `type: ${info.type}`);\n      }\n  }\n  if (reason === undefined) {\n    reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n    if (self.config.debug) {\n      self.config.debug('Client: Automatic rejection of unexpected incoming channel open for: ' + info.type);\n    }\n  }\n  reject();\n}\nconst randomCookie = (() => {\n  const buffer = Buffer.allocUnsafe(16);\n  return () => {\n    randomFillSync(buffer, 0, 16);\n    return buffer.hexSlice(0, 16);\n  };\n})();\nfunction makeSimpleAuthHandler(authList) {\n  if (!Array.isArray(authList)) throw new Error('authList must be an array');\n  let a = 0;\n  return (authsLeft, partialSuccess, cb) => {\n    if (a === authList.length) return false;\n    return authList[a++];\n  };\n}\nfunction hostKeysProve(client, keys_, cb) {\n  if (!client._sock || !isWritable(client._sock)) return;\n  if (typeof cb !== 'function') cb = noop;\n  if (!Array.isArray(keys_)) throw new TypeError('Invalid keys argument type');\n  const keys = [];\n  for (const key of keys_) {\n    const parsed = parseKey(key);\n    if (parsed instanceof Error) throw parsed;\n    keys.push(parsed);\n  }\n  if (!client.config.strictVendor || client.config.strictVendor && RE_OPENSSH.test(client._remoteVer)) {\n    client._callbacks.push((had_err, data) => {\n      if (had_err) {\n        cb(had_err !== true ? had_err : new Error('Server failed to prove supplied keys'));\n        return;\n      }\n\n      // TODO: move all of this parsing/verifying logic out of the client?\n      const ret = [];\n      let keyIdx = 0;\n      bufferParser.init(data, 0);\n      while (bufferParser.avail()) {\n        if (keyIdx === keys.length) break;\n        const key = keys[keyIdx++];\n        const keyPublic = key.getPublicSSH();\n        const sigEntry = bufferParser.readString();\n        sigParser.init(sigEntry, 0);\n        const type = sigParser.readString(true);\n        let value = sigParser.readString();\n        let algo;\n        if (type !== key.type) {\n          if (key.type === 'ssh-rsa') {\n            switch (type) {\n              case 'rsa-sha2-256':\n                algo = 'sha256';\n                break;\n              case 'rsa-sha2-512':\n                algo = 'sha512';\n                break;\n              default:\n                continue;\n            }\n          } else {\n            continue;\n          }\n        }\n        const sessionID = client._protocol._kex.sessionID;\n        const verifyData = Buffer.allocUnsafe(4 + 29 + 4 + sessionID.length + 4 + keyPublic.length);\n        let p = 0;\n        writeUInt32BE(verifyData, 29, p);\n        verifyData.utf8Write('hostkeys-prove-00@openssh.com', p += 4, 29);\n        writeUInt32BE(verifyData, sessionID.length, p += 29);\n        bufferCopy(sessionID, verifyData, 0, sessionID.length, p += 4);\n        writeUInt32BE(verifyData, keyPublic.length, p += sessionID.length);\n        bufferCopy(keyPublic, verifyData, 0, keyPublic.length, p += 4);\n        if (!(value = sigSSHToASN1(value, type))) continue;\n        if (key.verify(verifyData, value, algo) === true) ret.push(key);\n      }\n      sigParser.clear();\n      bufferParser.clear();\n      cb(null, ret);\n    });\n    client._protocol.openssh_hostKeysProve(keys);\n    return;\n  }\n  process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n}\nfunction getKeyAlgos(client, key, serverSigAlgs) {\n  switch (key.type) {\n    case 'ssh-rsa':\n      if (client._protocol._compatFlags & COMPAT.IMPLY_RSA_SHA2_SIGALGS) {\n        if (!Array.isArray(serverSigAlgs)) serverSigAlgs = ['rsa-sha2-256', 'rsa-sha2-512'];else serverSigAlgs = ['rsa-sha2-256', 'rsa-sha2-512', ...serverSigAlgs];\n      }\n      if (Array.isArray(serverSigAlgs)) {\n        if (serverSigAlgs.indexOf('rsa-sha2-256') !== -1) return [['rsa-sha2-256', 'sha256']];\n        if (serverSigAlgs.indexOf('rsa-sha2-512') !== -1) return [['rsa-sha2-512', 'sha512']];\n        if (serverSigAlgs.indexOf('ssh-rsa') === -1) return [];\n      }\n      return [['ssh-rsa', 'sha1']];\n  }\n}\nmodule.exports = Client;","map":{"version":3,"names":["createHash","getHashes","randomFillSync","require","Socket","lookup","dnsLookup","EventEmitter","HASHES","COMPAT","CHANNEL_EXTENDED_DATATYPE","STDERR","CHANNEL_OPEN_FAILURE","DEFAULT_CIPHER","DEFAULT_COMPRESSION","DEFAULT_KEX","DEFAULT_MAC","DEFAULT_SERVER_HOST_KEY","DISCONNECT_REASON","DISCONNECT_REASON_BY_VALUE","SUPPORTED_CIPHER","SUPPORTED_COMPRESSION","SUPPORTED_KEX","SUPPORTED_MAC","SUPPORTED_SERVER_HOST_KEY","init","cryptoInit","Protocol","parseKey","SFTP","bufferCopy","makeBufferParser","makeError","readUInt32BE","sigSSHToASN1","writeUInt32BE","AgentContext","createAgent","isAgent","Channel","MAX_WINDOW","PACKET_SIZE","windowAdjust","WINDOW_THRESHOLD","ChannelManager","generateAlgorithmList","isWritable","onChannelOpenFailure","onCHANNEL_CLOSE","bufferParser","sigParser","RE_OPENSSH","noop","err","Client","constructor","config","host","undefined","port","localAddress","localPort","forceIPv4","forceIPv6","keepaliveCountMax","keepaliveInterval","readyTimeout","ident","username","password","privateKey","tryKeyboard","agent","allowAgentFwd","authHandler","hostHashAlgo","hostHashCb","strictVendor","debug","_agent","_readyTimeout","_chanMgr","_callbacks","_forwarding","_forwardingUnix","_acceptX11","_agentFwdEnabled","_remoteVer","_protocol","_sock","_resetKA","connect","cfg","_this","once","end","hostname","Buffer","isBuffer","algorithms","kex","serverHostKey","cs","cipher","mac","compress","lang","sc","allOfferDefaults","hmac","user","Error","localHostname","localUsername","length","agentForward","Array","isArray","callbacks","passphrase","message","getPrivatePEM","hostVerifier","hashCb","hasher","indexOf","hostHash","key","verify","update","digest","ret","sock","ready","sawHeader","cleanup","DEBUG_HANDLER","p","display","msg","JSON","stringify","serverSigAlgs","proto","offer","onWrite","data","write","onError","level","clearTimeout","_destruct","removeAllListeners","emit","onHeader","header","versions","software","greeting","onHandshakeComplete","negotiated","service","messageHandlers","DEBUG","DISCONNECT","reason","desc","BY_APPLICATION","code","SERVICE_ACCEPT","name","tryNextAuth","EXT_INFO","exts","ext","algs","USERAUTH_BANNER","USERAUTH_SUCCESS","resetKA","USERAUTH_FAILURE","authMethods","partialSuccess","curAuth","keyAlgos","oldKeyAlgo","type","shift","keyAlgo","hashAlgo","authPK","agentCtx","currentKey","authHostbased","buf","cb","signature","sign","pos","tryNextAgentKey","curPartial","curAuthsLeft","USERAUTH_PASSWD_CHANGEREQ","prompt","newPassword","authPassword","USERAUTH_PK_OK","opts","hash","signed","USERAUTH_INFO_REQUEST","instructions","prompts","nprompts","authInfoRes","answers","REQUEST_SUCCESS","REQUEST_FAILURE","GLOBAL_REQUEST","wantReply","hostKeysProve","keys","requestSuccess","requestFailure","CHANNEL_OPEN","info","onCHANNEL_OPEN","CHANNEL_OPEN_CONFIRMATION","channel","get","recipient","isSFTP","chanInfo","incoming","id","window","packetSize","state","outgoing","sender","instance","description","CHANNEL_DATA","push","_waitChanDrain","CHANNEL_EXTENDED_DATA","stderr","CHANNEL_WINDOW_ADJUST","amount","_waitWindow","_chunk","_write","_chunkcb","_chunkErr","_chunkcbErr","CHANNEL_SUCCESS","CHANNEL_FAILURE","CHANNEL_REQUEST","exit","_exit","signal","dump","coreDumped","errorMessage","channelFailure","CHANNEL_EOF","readable","CHANNEL_CLOSE","pause","kainterval","kacountmax","kacount","katimer","sendKA","clearInterval","destroy","ping","setInterval","onDone","called","wasConnected","onConnect","then","start","on","parse","ex","resume","catch","callbacks_","i","authsAllowed","makeSimpleAuthHandler","hasSentAuth","doNextAuth","nextAuth","skipAuth","_len","arguments","args","_key","isPrivateKey","getKeyAlgos","authKeyboard","authNone","process","nextTick","auth","nextKey","startTimeout","setTimeout","doConnect","setMaxListeners","timeout","address","family","error","connecting","disconnect","exec","cmd","extraOpts","allowHalfOpen","openChannel","chan","todo","reqCb","close","reqAgentFwd","env","reqEnv","pty","reqPty","x11","reqX11","reqExec","shell","wndopts","reqShell","subsys","reqSubsystem","stream","forwardIn","bindAddr","bindPort","had_err","realPort","_compatFlags","DYN_RPORT_BUG","tcpipForward","unforwardIn","cancelTcpipForward","forwardOut","srcIP","srcPort","dstIP","dstPort","openssh_noMoreSessions","test","openssh_forwardInStreamLocal","socketPath","openssh_streamLocalForward","openssh_unforwardInStreamLocal","openssh_cancelStreamLocalForward","openssh_forwardOutStreamLocal","sftp","sftp_","removeListeners","removeListener","onReady","onExit","_init","setNoDelay","noDelay","self","initWindow","maxPacket","wrapper","localChan","add","session","directTcpip","openssh_directStreamLocal","screen","single","protocol","cookie","hexSlice","randomCookie","_hasX11","_client","x11Forward","rows","cols","width","height","term","modes","openssh_agentForward","subtype","Object","val","subsystem","accept","channelOpenConfirm","reject","RESOURCE_SHORTAGE","CONNECT_FAILED","remove","channelOpenFail","reserveChannel","destIP","destPort","getStream","upstream","pipe","UNKNOWN_CHANNEL_TYPE","ADMINISTRATIVELY_PROHIBITED","buffer","allocUnsafe","authList","a","authsLeft","client","keys_","TypeError","parsed","keyIdx","avail","keyPublic","getPublicSSH","sigEntry","readString","value","algo","sessionID","_kex","verifyData","utf8Write","clear","openssh_hostKeysProve","IMPLY_RSA_SHA2_SIGALGS","module","exports"],"sources":["/home/user/node_modules/ssh2/lib/client.js"],"sourcesContent":["// TODO:\n//    * add `.connected` or similar property to allow immediate connection\n//      status checking\n//    * add/improve debug output during user authentication phase\n'use strict';\n\nconst {\n  createHash,\n  getHashes,\n  randomFillSync,\n} = require('crypto');\nconst { Socket } = require('net');\nconst { lookup: dnsLookup } = require('dns');\nconst EventEmitter = require('events');\nconst HASHES = getHashes();\n\nconst {\n  COMPAT,\n  CHANNEL_EXTENDED_DATATYPE: { STDERR },\n  CHANNEL_OPEN_FAILURE,\n  DEFAULT_CIPHER,\n  DEFAULT_COMPRESSION,\n  DEFAULT_KEX,\n  DEFAULT_MAC,\n  DEFAULT_SERVER_HOST_KEY,\n  DISCONNECT_REASON,\n  DISCONNECT_REASON_BY_VALUE,\n  SUPPORTED_CIPHER,\n  SUPPORTED_COMPRESSION,\n  SUPPORTED_KEX,\n  SUPPORTED_MAC,\n  SUPPORTED_SERVER_HOST_KEY,\n} = require('./protocol/constants.js');\nconst { init: cryptoInit } = require('./protocol/crypto.js');\nconst Protocol = require('./protocol/Protocol.js');\nconst { parseKey } = require('./protocol/keyParser.js');\nconst { SFTP } = require('./protocol/SFTP.js');\nconst {\n  bufferCopy,\n  makeBufferParser,\n  makeError,\n  readUInt32BE,\n  sigSSHToASN1,\n  writeUInt32BE,\n} = require('./protocol/utils.js');\n\nconst { AgentContext, createAgent, isAgent } = require('./agent.js');\nconst {\n  Channel,\n  MAX_WINDOW,\n  PACKET_SIZE,\n  windowAdjust,\n  WINDOW_THRESHOLD,\n} = require('./Channel.js');\nconst {\n  ChannelManager,\n  generateAlgorithmList,\n  isWritable,\n  onChannelOpenFailure,\n  onCHANNEL_CLOSE,\n} = require('./utils.js');\n\nconst bufferParser = makeBufferParser();\nconst sigParser = makeBufferParser();\nconst RE_OPENSSH = /^OpenSSH_(?:(?![0-4])\\d)|(?:\\d{2,})/;\nconst noop = (err) => {};\n\nclass Client extends EventEmitter {\n  constructor() {\n    super();\n\n    this.config = {\n      host: undefined,\n      port: undefined,\n      localAddress: undefined,\n      localPort: undefined,\n      forceIPv4: undefined,\n      forceIPv6: undefined,\n      keepaliveCountMax: undefined,\n      keepaliveInterval: undefined,\n      readyTimeout: undefined,\n      ident: undefined,\n\n      username: undefined,\n      password: undefined,\n      privateKey: undefined,\n      tryKeyboard: undefined,\n      agent: undefined,\n      allowAgentFwd: undefined,\n      authHandler: undefined,\n\n      hostHashAlgo: undefined,\n      hostHashCb: undefined,\n      strictVendor: undefined,\n      debug: undefined\n    };\n\n    this._agent = undefined;\n    this._readyTimeout = undefined;\n    this._chanMgr = undefined;\n    this._callbacks = undefined;\n    this._forwarding = undefined;\n    this._forwardingUnix = undefined;\n    this._acceptX11 = undefined;\n    this._agentFwdEnabled = undefined;\n    this._remoteVer = undefined;\n\n    this._protocol = undefined;\n    this._sock = undefined;\n    this._resetKA = undefined;\n  }\n\n  connect(cfg) {\n    if (this._sock && isWritable(this._sock)) {\n      this.once('close', () => {\n        this.connect(cfg);\n      });\n      this.end();\n      return this;\n    }\n\n    this.config.host = cfg.hostname || cfg.host || 'localhost';\n    this.config.port = cfg.port || 22;\n    this.config.localAddress = (typeof cfg.localAddress === 'string'\n                                ? cfg.localAddress\n                                : undefined);\n    this.config.localPort = (typeof cfg.localPort === 'string'\n                             || typeof cfg.localPort === 'number'\n                             ? cfg.localPort\n                             : undefined);\n    this.config.forceIPv4 = cfg.forceIPv4 || false;\n    this.config.forceIPv6 = cfg.forceIPv6 || false;\n    this.config.keepaliveCountMax = (typeof cfg.keepaliveCountMax === 'number'\n                                     && cfg.keepaliveCountMax >= 0\n                                     ? cfg.keepaliveCountMax\n                                     : 3);\n    this.config.keepaliveInterval = (typeof cfg.keepaliveInterval === 'number'\n                                     && cfg.keepaliveInterval > 0\n                                     ? cfg.keepaliveInterval\n                                     : 0);\n    this.config.readyTimeout = (typeof cfg.readyTimeout === 'number'\n                                && cfg.readyTimeout >= 0\n                                ? cfg.readyTimeout\n                                : 20000);\n    this.config.ident = (typeof cfg.ident === 'string'\n                         || Buffer.isBuffer(cfg.ident)\n                         ? cfg.ident\n                         : undefined);\n\n    const algorithms = {\n      kex: undefined,\n      serverHostKey: undefined,\n      cs: {\n        cipher: undefined,\n        mac: undefined,\n        compress: undefined,\n        lang: [],\n      },\n      sc: undefined,\n    };\n    let allOfferDefaults = true;\n    if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {\n      algorithms.kex = generateAlgorithmList(cfg.algorithms.kex,\n                                             DEFAULT_KEX,\n                                             SUPPORTED_KEX);\n      if (algorithms.kex !== DEFAULT_KEX)\n        allOfferDefaults = false;\n\n      algorithms.serverHostKey =\n        generateAlgorithmList(cfg.algorithms.serverHostKey,\n                              DEFAULT_SERVER_HOST_KEY,\n                              SUPPORTED_SERVER_HOST_KEY);\n      if (algorithms.serverHostKey !== DEFAULT_SERVER_HOST_KEY)\n        allOfferDefaults = false;\n\n      algorithms.cs.cipher = generateAlgorithmList(cfg.algorithms.cipher,\n                                                   DEFAULT_CIPHER,\n                                                   SUPPORTED_CIPHER);\n      if (algorithms.cs.cipher !== DEFAULT_CIPHER)\n        allOfferDefaults = false;\n\n      algorithms.cs.mac = generateAlgorithmList(cfg.algorithms.hmac,\n                                                DEFAULT_MAC,\n                                                SUPPORTED_MAC);\n      if (algorithms.cs.mac !== DEFAULT_MAC)\n        allOfferDefaults = false;\n\n      algorithms.cs.compress = generateAlgorithmList(cfg.algorithms.compress,\n                                                     DEFAULT_COMPRESSION,\n                                                     SUPPORTED_COMPRESSION);\n      if (algorithms.cs.compress !== DEFAULT_COMPRESSION)\n        allOfferDefaults = false;\n\n      if (!allOfferDefaults)\n        algorithms.sc = algorithms.cs;\n    }\n\n    if (typeof cfg.username === 'string')\n      this.config.username = cfg.username;\n    else if (typeof cfg.user === 'string')\n      this.config.username = cfg.user;\n    else\n      throw new Error('Invalid username');\n\n    this.config.password = (typeof cfg.password === 'string'\n                            ? cfg.password\n                            : undefined);\n    this.config.privateKey = (typeof cfg.privateKey === 'string'\n                              || Buffer.isBuffer(cfg.privateKey)\n                              ? cfg.privateKey\n                              : undefined);\n    this.config.localHostname = (typeof cfg.localHostname === 'string'\n                                 ? cfg.localHostname\n                                 : undefined);\n    this.config.localUsername = (typeof cfg.localUsername === 'string'\n                                 ? cfg.localUsername\n                                 : undefined);\n    this.config.tryKeyboard = (cfg.tryKeyboard === true);\n    if (typeof cfg.agent === 'string' && cfg.agent.length)\n      this.config.agent = createAgent(cfg.agent);\n    else if (isAgent(cfg.agent))\n      this.config.agent = cfg.agent;\n    else\n      this.config.agent = undefined;\n    this.config.allowAgentFwd = (cfg.agentForward === true\n                                 && this.config.agent !== undefined);\n    let authHandler = this.config.authHandler = (\n      typeof cfg.authHandler === 'function'\n      || Array.isArray(cfg.authHandler)\n      ? cfg.authHandler\n      : undefined\n    );\n\n    this.config.strictVendor = (typeof cfg.strictVendor === 'boolean'\n                                ? cfg.strictVendor\n                                : true);\n\n    const debug = this.config.debug = (typeof cfg.debug === 'function'\n                                       ? cfg.debug\n                                       : undefined);\n\n    if (cfg.agentForward === true && !this.config.allowAgentFwd) {\n      throw new Error(\n        'You must set a valid agent path to allow agent forwarding'\n      );\n    }\n\n    let callbacks = this._callbacks = [];\n    this._chanMgr = new ChannelManager(this);\n    this._forwarding = {};\n    this._forwardingUnix = {};\n    this._acceptX11 = 0;\n    this._agentFwdEnabled = false;\n    this._agent = (this.config.agent ? this.config.agent : undefined);\n    this._remoteVer = undefined;\n    let privateKey;\n\n    if (this.config.privateKey) {\n      privateKey = parseKey(this.config.privateKey, cfg.passphrase);\n      if (privateKey instanceof Error)\n        throw new Error(`Cannot parse privateKey: ${privateKey.message}`);\n      if (Array.isArray(privateKey)) {\n        // OpenSSH's newer format only stores 1 key for now\n        privateKey = privateKey[0];\n      }\n      if (privateKey.getPrivatePEM() === null) {\n        throw new Error(\n          'privateKey value does not contain a (valid) private key'\n        );\n      }\n    }\n\n    let hostVerifier;\n    if (typeof cfg.hostVerifier === 'function') {\n      const hashCb = cfg.hostVerifier;\n      let hasher;\n      if (HASHES.indexOf(cfg.hostHash) !== -1) {\n        // Default to old behavior of hashing on user's behalf\n        hasher = createHash(cfg.hostHash);\n      }\n      hostVerifier = (key, verify) => {\n        if (hasher) {\n          hasher.update(key);\n          key = hasher.digest('hex');\n        }\n        const ret = hashCb(key, verify);\n        if (ret !== undefined)\n          verify(ret);\n      };\n    }\n\n    const sock = this._sock = (cfg.sock || new Socket());\n    let ready = false;\n    let sawHeader = false;\n    if (this._protocol)\n      this._protocol.cleanup();\n    const DEBUG_HANDLER = (!debug ? undefined : (p, display, msg) => {\n      debug(`Debug output from server: ${JSON.stringify(msg)}`);\n    });\n    let serverSigAlgs;\n    const proto = this._protocol = new Protocol({\n      ident: this.config.ident,\n      offer: (allOfferDefaults ? undefined : algorithms),\n      onWrite: (data) => {\n        if (isWritable(sock))\n          sock.write(data);\n      },\n      onError: (err) => {\n        if (err.level === 'handshake')\n          clearTimeout(this._readyTimeout);\n        if (!proto._destruct)\n          sock.removeAllListeners('data');\n        this.emit('error', err);\n        try {\n          sock.end();\n        } catch {}\n      },\n      onHeader: (header) => {\n        sawHeader = true;\n        this._remoteVer = header.versions.software;\n        if (header.greeting)\n          this.emit('greeting', header.greeting);\n      },\n      onHandshakeComplete: (negotiated) => {\n        this.emit('handshake', negotiated);\n        if (!ready) {\n          ready = true;\n          proto.service('ssh-userauth');\n        }\n      },\n      debug,\n      hostVerifier,\n      messageHandlers: {\n        DEBUG: DEBUG_HANDLER,\n        DISCONNECT: (p, reason, desc) => {\n          if (reason !== DISCONNECT_REASON.BY_APPLICATION) {\n            if (!desc) {\n              desc = DISCONNECT_REASON_BY_VALUE[reason];\n              if (desc === undefined)\n                desc = `Unexpected disconnection reason: ${reason}`;\n            }\n            const err = new Error(desc);\n            err.code = reason;\n            this.emit('error', err);\n          }\n          sock.end();\n        },\n        SERVICE_ACCEPT: (p, name) => {\n          if (name === 'ssh-userauth')\n            tryNextAuth();\n        },\n        EXT_INFO: (p, exts) => {\n          if (serverSigAlgs === undefined) {\n            for (const ext of exts) {\n              if (ext.name === 'server-sig-algs') {\n                serverSigAlgs = ext.algs;\n                return;\n              }\n            }\n            serverSigAlgs = null;\n          }\n        },\n        USERAUTH_BANNER: (p, msg) => {\n          this.emit('banner', msg);\n        },\n        USERAUTH_SUCCESS: (p) => {\n          // Start keepalive mechanism\n          resetKA();\n\n          clearTimeout(this._readyTimeout);\n\n          this.emit('ready');\n        },\n        USERAUTH_FAILURE: (p, authMethods, partialSuccess) => {\n          // For key-based authentication, check if we should retry the current\n          // key with a different algorithm first\n          if (curAuth.keyAlgos) {\n            const oldKeyAlgo = curAuth.keyAlgos[0][0];\n            if (debug)\n              debug(`Client: ${curAuth.type} (${oldKeyAlgo}) auth failed`);\n            curAuth.keyAlgos.shift();\n            if (curAuth.keyAlgos.length) {\n              const [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];\n              switch (curAuth.type) {\n                case 'agent':\n                  proto.authPK(\n                    curAuth.username,\n                    curAuth.agentCtx.currentKey(),\n                    keyAlgo\n                  );\n                  return;\n                case 'publickey':\n                  proto.authPK(curAuth.username, curAuth.key, keyAlgo);\n                  return;\n                case 'hostbased':\n                  proto.authHostbased(curAuth.username,\n                                      curAuth.key,\n                                      curAuth.localHostname,\n                                      curAuth.localUsername,\n                                      keyAlgo,\n                                      (buf, cb) => {\n                    const signature = curAuth.key.sign(buf, hashAlgo);\n                    if (signature instanceof Error) {\n                      signature.message =\n                        `Error while signing with key: ${signature.message}`;\n                      signature.level = 'client-authentication';\n                      this.emit('error', signature);\n                      return tryNextAuth();\n                    }\n\n                    cb(signature);\n                  });\n                  return;\n              }\n            } else {\n              curAuth.keyAlgos = undefined;\n            }\n          }\n\n          if (curAuth.type === 'agent') {\n            const pos = curAuth.agentCtx.pos();\n            debug && debug(`Client: Agent key #${pos + 1} failed`);\n            return tryNextAgentKey();\n          }\n\n          debug && debug(`Client: ${curAuth.type} auth failed`);\n\n          curPartial = partialSuccess;\n          curAuthsLeft = authMethods;\n          tryNextAuth();\n        },\n        USERAUTH_PASSWD_CHANGEREQ: (p, prompt) => {\n          if (curAuth.type === 'password') {\n            // TODO: support a `changePrompt()` on `curAuth` that defaults to\n            // emitting 'change password' as before\n            this.emit('change password', prompt, (newPassword) => {\n              proto.authPassword(\n                this.config.username,\n                this.config.password,\n                newPassword\n              );\n            });\n          }\n        },\n        USERAUTH_PK_OK: (p) => {\n          let keyAlgo;\n          let hashAlgo;\n          if (curAuth.keyAlgos)\n            [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];\n          if (curAuth.type === 'agent') {\n            const key = curAuth.agentCtx.currentKey();\n            proto.authPK(curAuth.username, key, keyAlgo, (buf, cb) => {\n              const opts = { hash: hashAlgo };\n              curAuth.agentCtx.sign(key, buf, opts, (err, signed) => {\n                if (err) {\n                  err.level = 'agent';\n                  this.emit('error', err);\n                } else {\n                  return cb(signed);\n                }\n\n                tryNextAgentKey();\n              });\n            });\n          } else if (curAuth.type === 'publickey') {\n            proto.authPK(curAuth.username, curAuth.key, keyAlgo, (buf, cb) => {\n              const signature = curAuth.key.sign(buf, hashAlgo);\n              if (signature instanceof Error) {\n                signature.message =\n                  `Error signing data with key: ${signature.message}`;\n                signature.level = 'client-authentication';\n                this.emit('error', signature);\n                return tryNextAuth();\n              }\n              cb(signature);\n            });\n          }\n        },\n        USERAUTH_INFO_REQUEST: (p, name, instructions, prompts) => {\n          if (curAuth.type === 'keyboard-interactive') {\n            const nprompts = (Array.isArray(prompts) ? prompts.length : 0);\n            if (nprompts === 0) {\n              debug && debug(\n                'Client: Sending automatic USERAUTH_INFO_RESPONSE'\n              );\n              proto.authInfoRes();\n              return;\n            }\n            // We sent a keyboard-interactive user authentication request and\n            // now the server is sending us the prompts we need to present to\n            // the user\n            curAuth.prompt(\n              name,\n              instructions,\n              '',\n              prompts,\n              (answers) => {\n                proto.authInfoRes(answers);\n              }\n            );\n          }\n        },\n        REQUEST_SUCCESS: (p, data) => {\n          if (callbacks.length)\n            callbacks.shift()(false, data);\n        },\n        REQUEST_FAILURE: (p) => {\n          if (callbacks.length)\n            callbacks.shift()(true);\n        },\n        GLOBAL_REQUEST: (p, name, wantReply, data) => {\n          switch (name) {\n            case 'hostkeys-00@openssh.com':\n              // Automatically verify keys before passing to end user\n              hostKeysProve(this, data, (err, keys) => {\n                if (err)\n                  return;\n                this.emit('hostkeys', keys);\n              });\n              if (wantReply)\n                proto.requestSuccess();\n              break;\n            default:\n              // Auto-reject all other global requests, this can be especially\n              // useful if the server is sending us dummy keepalive global\n              // requests\n              if (wantReply)\n                proto.requestFailure();\n          }\n        },\n        CHANNEL_OPEN: (p, info) => {\n          // Handle incoming requests from server, typically a forwarded TCP or\n          // X11 connection\n          onCHANNEL_OPEN(this, info);\n        },\n        CHANNEL_OPEN_CONFIRMATION: (p, info) => {\n          const channel = this._chanMgr.get(info.recipient);\n          if (typeof channel !== 'function')\n            return;\n\n          const isSFTP = (channel.type === 'sftp');\n          const type = (isSFTP ? 'session' : channel.type);\n          const chanInfo = {\n            type,\n            incoming: {\n              id: info.recipient,\n              window: MAX_WINDOW,\n              packetSize: PACKET_SIZE,\n              state: 'open'\n            },\n            outgoing: {\n              id: info.sender,\n              window: info.window,\n              packetSize: info.packetSize,\n              state: 'open'\n            }\n          };\n          const instance = (\n            isSFTP\n            ? new SFTP(this, chanInfo, { debug })\n            : new Channel(this, chanInfo)\n          );\n          this._chanMgr.update(info.recipient, instance);\n          channel(undefined, instance);\n        },\n        CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'function')\n            return;\n\n          const info = { reason, description };\n          onChannelOpenFailure(this, recipient, info, channel);\n        },\n        CHANNEL_DATA: (p, recipient, data) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n          if (channel.incoming.window === 0)\n            return;\n\n          channel.incoming.window -= data.length;\n\n          if (channel.push(data) === false) {\n            channel._waitChanDrain = true;\n            return;\n          }\n\n          if (channel.incoming.window <= WINDOW_THRESHOLD)\n            windowAdjust(channel);\n        },\n        CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {\n          if (type !== STDERR)\n            return;\n\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n          if (channel.incoming.window === 0)\n            return;\n\n          channel.incoming.window -= data.length;\n\n          if (!channel.stderr.push(data)) {\n            channel._waitChanDrain = true;\n            return;\n          }\n\n          if (channel.incoming.window <= WINDOW_THRESHOLD)\n            windowAdjust(channel);\n        },\n        CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          // The other side is allowing us to send `amount` more bytes of data\n          channel.outgoing.window += amount;\n\n          if (channel._waitWindow) {\n            channel._waitWindow = false;\n\n            if (channel._chunk) {\n              channel._write(channel._chunk, null, channel._chunkcb);\n            } else if (channel._chunkcb) {\n              channel._chunkcb();\n            } else if (channel._chunkErr) {\n              channel.stderr._write(channel._chunkErr,\n                                    null,\n                                    channel._chunkcbErr);\n            } else if (channel._chunkcbErr) {\n              channel._chunkcbErr();\n            }\n          }\n        },\n        CHANNEL_SUCCESS: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          this._resetKA();\n\n          if (channel._callbacks.length)\n            channel._callbacks.shift()(false);\n        },\n        CHANNEL_FAILURE: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          this._resetKA();\n\n          if (channel._callbacks.length)\n            channel._callbacks.shift()(true);\n        },\n        CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          const exit = channel._exit;\n          if (exit.code !== undefined)\n            return;\n          switch (type) {\n            case 'exit-status':\n              channel.emit('exit', exit.code = data);\n              return;\n            case 'exit-signal':\n              channel.emit('exit',\n                           exit.code = null,\n                           exit.signal = `SIG${data.signal}`,\n                           exit.dump = data.coreDumped,\n                           exit.desc = data.errorMessage);\n              return;\n          }\n\n          // Keepalive request? OpenSSH will send one as a channel request if\n          // there is a channel open\n\n          if (wantReply)\n            p.channelFailure(channel.outgoing.id);\n        },\n        CHANNEL_EOF: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          if (channel.incoming.state !== 'open')\n            return;\n          channel.incoming.state = 'eof';\n\n          if (channel.readable)\n            channel.push(null);\n          if (channel.stderr.readable)\n            channel.stderr.push(null);\n        },\n        CHANNEL_CLOSE: (p, recipient) => {\n          onCHANNEL_CLOSE(this, recipient, this._chanMgr.get(recipient));\n        },\n      },\n    });\n\n    sock.pause();\n\n    // TODO: check keepalive implementation\n    // Keepalive-related\n    const kainterval = this.config.keepaliveInterval;\n    const kacountmax = this.config.keepaliveCountMax;\n    let kacount = 0;\n    let katimer;\n    const sendKA = () => {\n      if (++kacount > kacountmax) {\n        clearInterval(katimer);\n        if (sock.readable) {\n          const err = new Error('Keepalive timeout');\n          err.level = 'client-timeout';\n          this.emit('error', err);\n          sock.destroy();\n        }\n        return;\n      }\n      if (isWritable(sock)) {\n        // Append dummy callback to keep correct callback order\n        callbacks.push(resetKA);\n        proto.ping();\n      } else {\n        clearInterval(katimer);\n      }\n    };\n    function resetKA() {\n      if (kainterval > 0) {\n        kacount = 0;\n        clearInterval(katimer);\n        if (isWritable(sock))\n          katimer = setInterval(sendKA, kainterval);\n      }\n    }\n    this._resetKA = resetKA;\n\n    const onDone = (() => {\n      let called = false;\n      return () => {\n        if (called)\n          return;\n        called = true;\n        if (wasConnected && !sawHeader) {\n          const err =\n            makeError('Connection lost before handshake', 'protocol', true);\n          this.emit('error', err);\n        }\n      };\n    })();\n    const onConnect = (() => {\n      let called = false;\n      return () => {\n        if (called)\n          return;\n        called = true;\n\n        wasConnected = true;\n        debug && debug('Socket connected');\n        this.emit('connect');\n\n        cryptoInit.then(() => {\n          proto.start();\n          sock.on('data', (data) => {\n            try {\n              proto.parse(data, 0, data.length);\n            } catch (ex) {\n              this.emit('error', ex);\n              try {\n                if (isWritable(sock))\n                  sock.end();\n              } catch {}\n            }\n          });\n\n          // Drain stderr if we are connection hopping using an exec stream\n          if (sock.stderr && typeof sock.stderr.resume === 'function')\n            sock.stderr.resume();\n\n          sock.resume();\n        }).catch((err) => {\n          this.emit('error', err);\n          try {\n            if (isWritable(sock))\n              sock.end();\n          } catch {}\n        });\n      };\n    })();\n    let wasConnected = false;\n    sock.on('connect', onConnect)\n        .on('timeout', () => {\n      this.emit('timeout');\n    }).on('error', (err) => {\n      debug && debug(`Socket error: ${err.message}`);\n      clearTimeout(this._readyTimeout);\n      err.level = 'client-socket';\n      this.emit('error', err);\n    }).on('end', () => {\n      debug && debug('Socket ended');\n      onDone();\n      proto.cleanup();\n      clearTimeout(this._readyTimeout);\n      clearInterval(katimer);\n      this.emit('end');\n    }).on('close', () => {\n      debug && debug('Socket closed');\n      onDone();\n      proto.cleanup();\n      clearTimeout(this._readyTimeout);\n      clearInterval(katimer);\n      this.emit('close');\n\n      // Notify outstanding channel requests of disconnection ...\n      const callbacks_ = callbacks;\n      callbacks = this._callbacks = [];\n      const err = new Error('No response from server');\n      for (let i = 0; i < callbacks_.length; ++i)\n        callbacks_[i](err);\n\n      // Simulate error for any channels waiting to be opened\n      this._chanMgr.cleanup(err);\n    });\n\n    // Begin authentication handling ===========================================\n    let curAuth;\n    let curPartial = null;\n    let curAuthsLeft = null;\n    const authsAllowed = ['none'];\n    if (this.config.password !== undefined)\n      authsAllowed.push('password');\n    if (privateKey !== undefined)\n      authsAllowed.push('publickey');\n    if (this._agent !== undefined)\n      authsAllowed.push('agent');\n    if (this.config.tryKeyboard)\n      authsAllowed.push('keyboard-interactive');\n    if (privateKey !== undefined\n        && this.config.localHostname !== undefined\n        && this.config.localUsername !== undefined) {\n      authsAllowed.push('hostbased');\n    }\n\n    if (Array.isArray(authHandler))\n      authHandler = makeSimpleAuthHandler(authHandler);\n    else if (typeof authHandler !== 'function')\n      authHandler = makeSimpleAuthHandler(authsAllowed);\n\n    let hasSentAuth = false;\n    const doNextAuth = (nextAuth) => {\n      if (hasSentAuth)\n        return;\n      hasSentAuth = true;\n\n      if (nextAuth === false) {\n        const err = new Error('All configured authentication methods failed');\n        err.level = 'client-authentication';\n        this.emit('error', err);\n        this.end();\n        return;\n      }\n\n      if (typeof nextAuth === 'string') {\n        // Remain backwards compatible with original `authHandler()` usage,\n        // which only supported passing names of next method to try using data\n        // from the `connect()` config object\n\n        const type = nextAuth;\n        if (authsAllowed.indexOf(type) === -1)\n          return skipAuth(`Authentication method not allowed: ${type}`);\n\n        const username = this.config.username;\n        switch (type) {\n          case 'password':\n            nextAuth = { type, username, password: this.config.password };\n            break;\n          case 'publickey':\n            nextAuth = { type, username, key: privateKey };\n            break;\n          case 'hostbased':\n            nextAuth = {\n              type,\n              username,\n              key: privateKey,\n              localHostname: this.config.localHostname,\n              localUsername: this.config.localUsername,\n            };\n            break;\n          case 'agent':\n            nextAuth = {\n              type,\n              username,\n              agentCtx: new AgentContext(this._agent),\n            };\n            break;\n          case 'keyboard-interactive':\n            nextAuth = {\n              type,\n              username,\n              prompt: (...args) => this.emit('keyboard-interactive', ...args),\n            };\n            break;\n          case 'none':\n            nextAuth = { type, username };\n            break;\n          default:\n            return skipAuth(\n              `Skipping unsupported authentication method: ${nextAuth}`\n            );\n        }\n      } else if (typeof nextAuth !== 'object' || nextAuth === null) {\n        return skipAuth(\n          `Skipping invalid authentication attempt: ${nextAuth}`\n        );\n      } else {\n        const username = nextAuth.username;\n        if (typeof username !== 'string') {\n          return skipAuth(\n            `Skipping invalid authentication attempt: ${nextAuth}`\n          );\n        }\n        const type = nextAuth.type;\n        switch (type) {\n          case 'password': {\n            const { password } = nextAuth;\n            if (typeof password !== 'string' && !Buffer.isBuffer(password))\n              return skipAuth('Skipping invalid password auth attempt');\n            nextAuth = { type, username, password };\n            break;\n          }\n          case 'publickey': {\n            const key = parseKey(nextAuth.key, nextAuth.passphrase);\n            if (key instanceof Error)\n              return skipAuth('Skipping invalid key auth attempt');\n            if (!key.isPrivateKey())\n              return skipAuth('Skipping non-private key');\n            nextAuth = { type, username, key };\n            break;\n          }\n          case 'hostbased': {\n            const { localHostname, localUsername } = nextAuth;\n            const key = parseKey(nextAuth.key, nextAuth.passphrase);\n            if (key instanceof Error\n                || typeof localHostname !== 'string'\n                || typeof localUsername !== 'string') {\n              return skipAuth('Skipping invalid hostbased auth attempt');\n            }\n            if (!key.isPrivateKey())\n              return skipAuth('Skipping non-private key');\n            nextAuth = { type, username, key, localHostname, localUsername };\n            break;\n          }\n          case 'agent': {\n            let agent = nextAuth.agent;\n            if (typeof agent === 'string' && agent.length) {\n              agent = createAgent(agent);\n            } else if (!isAgent(agent)) {\n              return skipAuth(\n                `Skipping invalid agent: ${nextAuth.agent}`\n              );\n            }\n            nextAuth = { type, username, agentCtx: new AgentContext(agent) };\n            break;\n          }\n          case 'keyboard-interactive': {\n            const { prompt } = nextAuth;\n            if (typeof prompt !== 'function') {\n              return skipAuth(\n                'Skipping invalid keyboard-interactive auth attempt'\n              );\n            }\n            nextAuth = { type, username, prompt };\n            break;\n          }\n          case 'none':\n            nextAuth = { type, username };\n            break;\n          default:\n            return skipAuth(\n              `Skipping unsupported authentication method: ${nextAuth}`\n            );\n        }\n      }\n      curAuth = nextAuth;\n\n      // Begin authentication method's process\n      try {\n        const username = curAuth.username;\n        switch (curAuth.type) {\n          case 'password':\n            proto.authPassword(username, curAuth.password);\n            break;\n          case 'publickey': {\n            let keyAlgo;\n            curAuth.keyAlgos = getKeyAlgos(this, curAuth.key, serverSigAlgs);\n            if (curAuth.keyAlgos) {\n              if (curAuth.keyAlgos.length) {\n                keyAlgo = curAuth.keyAlgos[0][0];\n              } else {\n                return skipAuth(\n                  'Skipping key authentication (no mutual hash algorithm)'\n                );\n              }\n            }\n            proto.authPK(username, curAuth.key, keyAlgo);\n            break;\n          }\n          case 'hostbased': {\n            let keyAlgo;\n            let hashAlgo;\n            curAuth.keyAlgos = getKeyAlgos(this, curAuth.key, serverSigAlgs);\n            if (curAuth.keyAlgos) {\n              if (curAuth.keyAlgos.length) {\n                [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];\n              } else {\n                return skipAuth(\n                  'Skipping hostbased authentication (no mutual hash algorithm)'\n                );\n              }\n            }\n\n            proto.authHostbased(username,\n                                curAuth.key,\n                                curAuth.localHostname,\n                                curAuth.localUsername,\n                                keyAlgo,\n                                (buf, cb) => {\n              const signature = curAuth.key.sign(buf, hashAlgo);\n              if (signature instanceof Error) {\n                signature.message =\n                  `Error while signing with key: ${signature.message}`;\n                signature.level = 'client-authentication';\n                this.emit('error', signature);\n                return tryNextAuth();\n              }\n\n              cb(signature);\n            });\n            break;\n          }\n          case 'agent':\n            curAuth.agentCtx.init((err) => {\n              if (err) {\n                err.level = 'agent';\n                this.emit('error', err);\n                return tryNextAuth();\n              }\n              tryNextAgentKey();\n            });\n            break;\n          case 'keyboard-interactive':\n            proto.authKeyboard(username);\n            break;\n          case 'none':\n            proto.authNone(username);\n            break;\n        }\n      } finally {\n        hasSentAuth = false;\n      }\n    };\n\n    function skipAuth(msg) {\n      debug && debug(msg);\n      process.nextTick(tryNextAuth);\n    }\n\n    function tryNextAuth() {\n      hasSentAuth = false;\n      const auth = authHandler(curAuthsLeft, curPartial, doNextAuth);\n      if (hasSentAuth || auth === undefined)\n        return;\n      doNextAuth(auth);\n    }\n\n    const tryNextAgentKey = () => {\n      if (curAuth.type === 'agent') {\n        const key = curAuth.agentCtx.nextKey();\n        if (key === false) {\n          debug && debug('Agent: No more keys left to try');\n          debug && debug('Client: agent auth failed');\n          tryNextAuth();\n        } else {\n          const pos = curAuth.agentCtx.pos();\n          let keyAlgo;\n          curAuth.keyAlgos = getKeyAlgos(this, key, serverSigAlgs);\n          if (curAuth.keyAlgos) {\n            if (curAuth.keyAlgos.length) {\n              keyAlgo = curAuth.keyAlgos[0][0];\n            } else {\n              debug && debug(\n                `Agent: Skipping key #${pos + 1} (no mutual hash algorithm)`\n              );\n              tryNextAgentKey();\n              return;\n            }\n          }\n          debug && debug(`Agent: Trying key #${pos + 1}`);\n          proto.authPK(curAuth.username, key, keyAlgo);\n        }\n      }\n    };\n\n    const startTimeout = () => {\n      if (this.config.readyTimeout > 0) {\n        this._readyTimeout = setTimeout(() => {\n          const err = new Error('Timed out while waiting for handshake');\n          err.level = 'client-timeout';\n          this.emit('error', err);\n          sock.destroy();\n        }, this.config.readyTimeout);\n      }\n    };\n\n    if (!cfg.sock) {\n      let host = this.config.host;\n      const forceIPv4 = this.config.forceIPv4;\n      const forceIPv6 = this.config.forceIPv6;\n\n      debug && debug(`Client: Trying ${host} on port ${this.config.port} ...`);\n\n      const doConnect = () => {\n        startTimeout();\n        sock.connect({\n          host,\n          port: this.config.port,\n          localAddress: this.config.localAddress,\n          localPort: this.config.localPort\n        });\n        sock.setMaxListeners(0);\n        sock.setTimeout(typeof cfg.timeout === 'number' ? cfg.timeout : 0);\n      };\n\n      if ((!forceIPv4 && !forceIPv6) || (forceIPv4 && forceIPv6)) {\n        doConnect();\n      } else {\n        dnsLookup(host, (forceIPv4 ? 4 : 6), (err, address, family) => {\n          if (err) {\n            const type = (forceIPv4 ? 'IPv4' : 'IPv6');\n            const error = new Error(\n              `Error while looking up ${type} address for '${host}': ${err}`\n            );\n            clearTimeout(this._readyTimeout);\n            error.level = 'client-dns';\n            this.emit('error', error);\n            this.emit('close');\n            return;\n          }\n          host = address;\n          doConnect();\n        });\n      }\n    } else {\n      // Custom socket passed in\n      startTimeout();\n      if (typeof sock.connecting === 'boolean') {\n        // net.Socket\n\n        if (!sock.connecting) {\n          // Already connected\n          onConnect();\n        }\n      } else {\n        // Assume socket/stream is already \"connected\"\n        onConnect();\n      }\n    }\n\n    return this;\n  }\n\n  end() {\n    if (this._sock && isWritable(this._sock)) {\n      this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n      this._sock.end();\n    }\n    return this;\n  }\n\n  destroy() {\n    this._sock && isWritable(this._sock) && this._sock.destroy();\n    return this;\n  }\n\n  exec(cmd, opts, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    if (typeof opts === 'function') {\n      cb = opts;\n      opts = {};\n    }\n\n    const extraOpts = { allowHalfOpen: (opts.allowHalfOpen !== false) };\n\n    openChannel(this, 'session', extraOpts, (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      const todo = [];\n\n      function reqCb(err) {\n        if (err) {\n          chan.close();\n          cb(err);\n          return;\n        }\n        if (todo.length)\n          todo.shift()();\n      }\n\n      if (this.config.allowAgentFwd === true\n          || (opts\n              && opts.agentForward === true\n              && this._agent !== undefined)) {\n        todo.push(() => reqAgentFwd(chan, reqCb));\n      }\n\n      if (typeof opts === 'object' && opts !== null) {\n        if (typeof opts.env === 'object' && opts.env !== null)\n          reqEnv(chan, opts.env);\n        if ((typeof opts.pty === 'object' && opts.pty !== null)\n            || opts.pty === true) {\n          todo.push(() => reqPty(chan, opts.pty, reqCb));\n        }\n        if ((typeof opts.x11 === 'object' && opts.x11 !== null)\n            || opts.x11 === 'number'\n            || opts.x11 === true) {\n          todo.push(() => reqX11(chan, opts.x11, reqCb));\n        }\n      }\n\n      todo.push(() => reqExec(chan, cmd, opts, cb));\n      todo.shift()();\n    });\n\n    return this;\n  }\n\n  shell(wndopts, opts, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    if (typeof wndopts === 'function') {\n      cb = wndopts;\n      wndopts = opts = undefined;\n    } else if (typeof opts === 'function') {\n      cb = opts;\n      opts = undefined;\n    }\n    if (wndopts && (wndopts.x11 !== undefined || wndopts.env !== undefined)) {\n      opts = wndopts;\n      wndopts = undefined;\n    }\n\n    openChannel(this, 'session', (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      const todo = [];\n\n      function reqCb(err) {\n        if (err) {\n          chan.close();\n          cb(err);\n          return;\n        }\n        if (todo.length)\n          todo.shift()();\n      }\n\n      if (this.config.allowAgentFwd === true\n          || (opts\n              && opts.agentForward === true\n              && this._agent !== undefined)) {\n        todo.push(() => reqAgentFwd(chan, reqCb));\n      }\n\n      if (wndopts !== false)\n        todo.push(() => reqPty(chan, wndopts, reqCb));\n\n      if (typeof opts === 'object' && opts !== null) {\n        if (typeof opts.env === 'object' && opts.env !== null)\n          reqEnv(chan, opts.env);\n        if ((typeof opts.x11 === 'object' && opts.x11 !== null)\n            || opts.x11 === 'number'\n            || opts.x11 === true) {\n          todo.push(() => reqX11(chan, opts.x11, reqCb));\n        }\n      }\n\n      todo.push(() => reqShell(chan, cb));\n      todo.shift()();\n    });\n\n    return this;\n  }\n\n  subsys(name, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    openChannel(this, 'session', (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      reqSubsystem(chan, name, (err, stream) => {\n        if (err) {\n          cb(err);\n          return;\n        }\n\n        cb(undefined, stream);\n      });\n    });\n\n    return this;\n  }\n\n  forwardIn(bindAddr, bindPort, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    // Send a request for the server to start forwarding TCP connections to us\n    // on a particular address and port\n\n    const wantReply = (typeof cb === 'function');\n\n    if (wantReply) {\n      this._callbacks.push((had_err, data) => {\n        if (had_err) {\n          cb(had_err !== true\n             ? had_err\n             : new Error(`Unable to bind to ${bindAddr}:${bindPort}`));\n          return;\n        }\n\n        let realPort = bindPort;\n        if (bindPort === 0 && data && data.length >= 4) {\n          realPort = readUInt32BE(data, 0);\n          if (!(this._protocol._compatFlags & COMPAT.DYN_RPORT_BUG))\n            bindPort = realPort;\n        }\n\n        this._forwarding[`${bindAddr}:${bindPort}`] = realPort;\n\n        cb(undefined, realPort);\n      });\n    }\n\n    this._protocol.tcpipForward(bindAddr, bindPort, wantReply);\n\n    return this;\n  }\n\n  unforwardIn(bindAddr, bindPort, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    // Send a request to stop forwarding us new connections for a particular\n    // address and port\n\n    const wantReply = (typeof cb === 'function');\n\n    if (wantReply) {\n      this._callbacks.push((had_err) => {\n        if (had_err) {\n          cb(had_err !== true\n             ? had_err\n             : new Error(`Unable to unbind from ${bindAddr}:${bindPort}`));\n          return;\n        }\n\n        delete this._forwarding[`${bindAddr}:${bindPort}`];\n\n        cb();\n      });\n    }\n\n    this._protocol.cancelTcpipForward(bindAddr, bindPort, wantReply);\n\n    return this;\n  }\n\n  forwardOut(srcIP, srcPort, dstIP, dstPort, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    // Send a request to forward a TCP connection to the server\n\n    const cfg = {\n      srcIP: srcIP,\n      srcPort: srcPort,\n      dstIP: dstIP,\n      dstPort: dstPort\n    };\n\n    if (typeof cb !== 'function')\n      cb = noop;\n\n    openChannel(this, 'direct-tcpip', cfg, cb);\n\n    return this;\n  }\n\n  openssh_noMoreSessions(cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    const wantReply = (typeof cb === 'function');\n\n    if (!this.config.strictVendor\n        || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n      if (wantReply) {\n        this._callbacks.push((had_err) => {\n          if (had_err) {\n            cb(had_err !== true\n               ? had_err\n               : new Error('Unable to disable future sessions'));\n            return;\n          }\n\n          cb();\n        });\n      }\n\n      this._protocol.openssh_noMoreSessions(wantReply);\n      return this;\n    }\n\n    if (!wantReply)\n      return this;\n\n    process.nextTick(\n      cb,\n      new Error(\n        'strictVendor enabled and server is not OpenSSH or compatible version'\n      )\n    );\n\n    return this;\n  }\n\n  openssh_forwardInStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    const wantReply = (typeof cb === 'function');\n\n    if (!this.config.strictVendor\n        || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n      if (wantReply) {\n        this._callbacks.push((had_err) => {\n          if (had_err) {\n            cb(had_err !== true\n               ? had_err\n               : new Error(`Unable to bind to ${socketPath}`));\n            return;\n          }\n          this._forwardingUnix[socketPath] = true;\n          cb();\n        });\n      }\n\n      this._protocol.openssh_streamLocalForward(socketPath, wantReply);\n      return this;\n    }\n\n    if (!wantReply)\n      return this;\n\n    process.nextTick(\n      cb,\n      new Error(\n        'strictVendor enabled and server is not OpenSSH or compatible version'\n      )\n    );\n\n    return this;\n  }\n\n  openssh_unforwardInStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    const wantReply = (typeof cb === 'function');\n\n    if (!this.config.strictVendor\n        || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n      if (wantReply) {\n        this._callbacks.push((had_err) => {\n          if (had_err) {\n            cb(had_err !== true\n               ? had_err\n               : new Error(`Unable to unbind from ${socketPath}`));\n            return;\n          }\n          delete this._forwardingUnix[socketPath];\n          cb();\n        });\n      }\n\n      this._protocol.openssh_cancelStreamLocalForward(socketPath, wantReply);\n      return this;\n    }\n\n    if (!wantReply)\n      return this;\n\n    process.nextTick(\n      cb,\n      new Error(\n        'strictVendor enabled and server is not OpenSSH or compatible version'\n      )\n    );\n\n    return this;\n  }\n\n  openssh_forwardOutStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    if (typeof cb !== 'function')\n      cb = noop;\n\n    if (!this.config.strictVendor\n        || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n      openChannel(this, 'direct-streamlocal@openssh.com', { socketPath }, cb);\n      return this;\n    }\n    process.nextTick(\n      cb,\n      new Error(\n        'strictVendor enabled and server is not OpenSSH or compatible version'\n      )\n    );\n\n    return this;\n  }\n\n  sftp(cb) {\n    if (!this._sock || !isWritable(this._sock))\n      throw new Error('Not connected');\n\n    openChannel(this, 'sftp', (err, sftp) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      reqSubsystem(sftp, 'sftp', (err, sftp_) => {\n        if (err) {\n          cb(err);\n          return;\n        }\n\n        function removeListeners() {\n          sftp.removeListener('ready', onReady);\n          sftp.removeListener('error', onError);\n          sftp.removeListener('exit', onExit);\n          sftp.removeListener('close', onExit);\n        }\n\n        function onReady() {\n          // TODO: do not remove exit/close in case remote end closes the\n          // channel abruptly and we need to notify outstanding callbacks\n          removeListeners();\n          cb(undefined, sftp);\n        }\n\n        function onError(err) {\n          removeListeners();\n          cb(err);\n        }\n\n        function onExit(code, signal) {\n          removeListeners();\n          let msg;\n          if (typeof code === 'number')\n            msg = `Received exit code ${code} while establishing SFTP session`;\n          else if (signal !== undefined)\n            msg = `Received signal ${signal} while establishing SFTP session`;\n          else\n            msg = 'Received unexpected SFTP session termination';\n          const err = new Error(msg);\n          err.code = code;\n          err.signal = signal;\n          cb(err);\n        }\n\n        sftp.on('ready', onReady)\n            .on('error', onError)\n            .on('exit', onExit)\n            .on('close', onExit);\n\n        sftp._init();\n      });\n    });\n\n    return this;\n  }\n\n  setNoDelay(noDelay) {\n    if (this._sock && typeof this._sock.setNoDelay === 'function')\n      this._sock.setNoDelay(noDelay);\n\n    return this;\n  }\n}\n\nfunction openChannel(self, type, opts, cb) {\n  // Ask the server to open a channel for some purpose\n  // (e.g. session (sftp, exec, shell), or forwarding a TCP connection\n  const initWindow = MAX_WINDOW;\n  const maxPacket = PACKET_SIZE;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  const wrapper = (err, stream) => {\n    cb(err, stream);\n  };\n  wrapper.type = type;\n\n  const localChan = self._chanMgr.add(wrapper);\n\n  if (localChan === -1) {\n    cb(new Error('No free channels available'));\n    return;\n  }\n\n  switch (type) {\n    case 'session':\n    case 'sftp':\n      self._protocol.session(localChan, initWindow, maxPacket);\n      break;\n    case 'direct-tcpip':\n      self._protocol.directTcpip(localChan, initWindow, maxPacket, opts);\n      break;\n    case 'direct-streamlocal@openssh.com':\n      self._protocol.openssh_directStreamLocal(\n        localChan, initWindow, maxPacket, opts\n      );\n      break;\n    default:\n      throw new Error(`Unsupported channel type: ${type}`);\n  }\n}\n\nfunction reqX11(chan, screen, cb) {\n  // Asks server to start sending us X11 connections\n  const cfg = {\n    single: false,\n    protocol: 'MIT-MAGIC-COOKIE-1',\n    cookie: undefined,\n    screen: 0\n  };\n\n  if (typeof screen === 'function') {\n    cb = screen;\n  } else if (typeof screen === 'object' && screen !== null) {\n    if (typeof screen.single === 'boolean')\n      cfg.single = screen.single;\n    if (typeof screen.screen === 'number')\n      cfg.screen = screen.screen;\n    if (typeof screen.protocol === 'string')\n      cfg.protocol = screen.protocol;\n    if (typeof screen.cookie === 'string')\n      cfg.cookie = screen.cookie;\n    else if (Buffer.isBuffer(screen.cookie))\n      cfg.cookie = screen.cookie.hexSlice(0, screen.cookie.length);\n  }\n  if (cfg.cookie === undefined)\n    cfg.cookie = randomCookie();\n\n  const wantReply = (typeof cb === 'function');\n\n  if (chan.outgoing.state !== 'open') {\n    if (wantReply)\n      cb(new Error('Channel is not open'));\n    return;\n  }\n\n  if (wantReply) {\n    chan._callbacks.push((had_err) => {\n      if (had_err) {\n        cb(had_err !== true ? had_err : new Error('Unable to request X11'));\n        return;\n      }\n\n      chan._hasX11 = true;\n      ++chan._client._acceptX11;\n      chan.once('close', () => {\n        if (chan._client._acceptX11)\n          --chan._client._acceptX11;\n      });\n\n      cb();\n    });\n  }\n\n  chan._client._protocol.x11Forward(chan.outgoing.id, cfg, wantReply);\n}\n\nfunction reqPty(chan, opts, cb) {\n  let rows = 24;\n  let cols = 80;\n  let width = 640;\n  let height = 480;\n  let term = 'vt100';\n  let modes = null;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n  } else if (typeof opts === 'object' && opts !== null) {\n    if (typeof opts.rows === 'number')\n      rows = opts.rows;\n    if (typeof opts.cols === 'number')\n      cols = opts.cols;\n    if (typeof opts.width === 'number')\n      width = opts.width;\n    if (typeof opts.height === 'number')\n      height = opts.height;\n    if (typeof opts.term === 'string')\n      term = opts.term;\n    if (typeof opts.modes === 'object')\n      modes = opts.modes;\n  }\n\n  const wantReply = (typeof cb === 'function');\n\n  if (chan.outgoing.state !== 'open') {\n    if (wantReply)\n      cb(new Error('Channel is not open'));\n    return;\n  }\n\n  if (wantReply) {\n    chan._callbacks.push((had_err) => {\n      if (had_err) {\n        cb(had_err !== true\n           ? had_err\n           : new Error('Unable to request a pseudo-terminal'));\n        return;\n      }\n      cb();\n    });\n  }\n\n  chan._client._protocol.pty(chan.outgoing.id,\n                             rows,\n                             cols,\n                             height,\n                             width,\n                             term,\n                             modes,\n                             wantReply);\n}\n\nfunction reqAgentFwd(chan, cb) {\n  const wantReply = (typeof cb === 'function');\n\n  if (chan.outgoing.state !== 'open') {\n    wantReply && cb(new Error('Channel is not open'));\n    return;\n  }\n  if (chan._client._agentFwdEnabled) {\n    wantReply && cb(false);\n    return;\n  }\n\n  chan._client._agentFwdEnabled = true;\n\n  chan._callbacks.push((had_err) => {\n    if (had_err) {\n      chan._client._agentFwdEnabled = false;\n      if (wantReply) {\n        cb(had_err !== true\n           ? had_err\n           : new Error('Unable to request agent forwarding'));\n      }\n      return;\n    }\n\n    if (wantReply)\n      cb();\n  });\n\n  chan._client._protocol.openssh_agentForward(chan.outgoing.id, true);\n}\n\nfunction reqShell(chan, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n\n  chan._callbacks.push((had_err) => {\n    if (had_err) {\n      cb(had_err !== true ? had_err : new Error('Unable to open shell'));\n      return;\n    }\n    chan.subtype = 'shell';\n    cb(undefined, chan);\n  });\n\n  chan._client._protocol.shell(chan.outgoing.id, true);\n}\n\nfunction reqExec(chan, cmd, opts, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n\n  chan._callbacks.push((had_err) => {\n    if (had_err) {\n      cb(had_err !== true ? had_err : new Error('Unable to exec'));\n      return;\n    }\n    chan.subtype = 'exec';\n    chan.allowHalfOpen = (opts.allowHalfOpen !== false);\n    cb(undefined, chan);\n  });\n\n  chan._client._protocol.exec(chan.outgoing.id, cmd, true);\n}\n\nfunction reqEnv(chan, env) {\n  if (chan.outgoing.state !== 'open')\n    return;\n\n  const keys = Object.keys(env || {});\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    const val = env[key];\n    chan._client._protocol.env(chan.outgoing.id, key, val, false);\n  }\n}\n\nfunction reqSubsystem(chan, name, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n\n  chan._callbacks.push((had_err) => {\n    if (had_err) {\n      cb(had_err !== true\n         ? had_err\n         : new Error(`Unable to start subsystem: ${name}`));\n      return;\n    }\n    chan.subtype = 'subsystem';\n    cb(undefined, chan);\n  });\n\n  chan._client._protocol.subsystem(chan.outgoing.id, name, true);\n}\n\n// TODO: inline implementation into single call site\nfunction onCHANNEL_OPEN(self, info) {\n  // The server is trying to open a channel with us, this is usually when\n  // we asked the server to forward us connections on some port and now they\n  // are asking us to accept/deny an incoming connection on their side\n\n  let localChan = -1;\n  let reason;\n\n  const accept = () => {\n    const chanInfo = {\n      type: info.type,\n      incoming: {\n        id: localChan,\n        window: MAX_WINDOW,\n        packetSize: PACKET_SIZE,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n    const stream = new Channel(self, chanInfo);\n    self._chanMgr.update(localChan, stream);\n\n    self._protocol.channelOpenConfirm(info.sender,\n                                      localChan,\n                                      MAX_WINDOW,\n                                      PACKET_SIZE);\n    return stream;\n  };\n  const reject = () => {\n    if (reason === undefined) {\n      if (localChan === -1)\n        reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n      else\n        reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;\n    }\n\n    if (localChan !== -1)\n      self._chanMgr.remove(localChan);\n\n    self._protocol.channelOpenFail(info.sender, reason, '');\n  };\n  const reserveChannel = () => {\n    localChan = self._chanMgr.add();\n\n    if (localChan === -1) {\n      reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n      if (self.config.debug) {\n        self.config.debug(\n          'Client: Automatic rejection of incoming channel open: '\n            + 'no channels available'\n        );\n      }\n    }\n\n    return (localChan !== -1);\n  };\n\n  const data = info.data;\n  switch (info.type) {\n    case 'forwarded-tcpip': {\n      const val = self._forwarding[`${data.destIP}:${data.destPort}`];\n      if (val !== undefined && reserveChannel()) {\n        if (data.destPort === 0)\n          data.destPort = val;\n        self.emit('tcp connection', data, accept, reject);\n        return;\n      }\n      break;\n    }\n    case 'forwarded-streamlocal@openssh.com':\n      if (self._forwardingUnix[data.socketPath] !== undefined\n          && reserveChannel()) {\n        self.emit('unix connection', data, accept, reject);\n        return;\n      }\n      break;\n    case 'auth-agent@openssh.com':\n      if (self._agentFwdEnabled\n          && typeof self._agent.getStream === 'function'\n          && reserveChannel()) {\n        self._agent.getStream((err, stream) => {\n          if (err)\n            return reject();\n\n          const upstream = accept();\n          upstream.pipe(stream).pipe(upstream);\n        });\n        return;\n      }\n      break;\n    case 'x11':\n      if (self._acceptX11 !== 0 && reserveChannel()) {\n        self.emit('x11', data, accept, reject);\n        return;\n      }\n      break;\n    default:\n      // Automatically reject any unsupported channel open requests\n      reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;\n      if (self.config.debug) {\n        self.config.debug(\n          'Client: Automatic rejection of unsupported incoming channel open '\n            + `type: ${info.type}`\n        );\n      }\n  }\n\n  if (reason === undefined) {\n    reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n    if (self.config.debug) {\n       self.config.debug(\n        'Client: Automatic rejection of unexpected incoming channel open for: '\n          + info.type\n      );\n    }\n  }\n\n  reject();\n}\n\nconst randomCookie = (() => {\n  const buffer = Buffer.allocUnsafe(16);\n  return () => {\n    randomFillSync(buffer, 0, 16);\n    return buffer.hexSlice(0, 16);\n  };\n})();\n\nfunction makeSimpleAuthHandler(authList) {\n  if (!Array.isArray(authList))\n    throw new Error('authList must be an array');\n\n  let a = 0;\n  return (authsLeft, partialSuccess, cb) => {\n    if (a === authList.length)\n      return false;\n    return authList[a++];\n  };\n}\n\nfunction hostKeysProve(client, keys_, cb) {\n  if (!client._sock || !isWritable(client._sock))\n    return;\n\n  if (typeof cb !== 'function')\n    cb = noop;\n\n  if (!Array.isArray(keys_))\n    throw new TypeError('Invalid keys argument type');\n\n  const keys = [];\n  for (const key of keys_) {\n    const parsed = parseKey(key);\n    if (parsed instanceof Error)\n      throw parsed;\n    keys.push(parsed);\n  }\n\n  if (!client.config.strictVendor\n      || (client.config.strictVendor && RE_OPENSSH.test(client._remoteVer))) {\n    client._callbacks.push((had_err, data) => {\n      if (had_err) {\n        cb(had_err !== true\n           ? had_err\n           : new Error('Server failed to prove supplied keys'));\n        return;\n      }\n\n      // TODO: move all of this parsing/verifying logic out of the client?\n      const ret = [];\n      let keyIdx = 0;\n      bufferParser.init(data, 0);\n      while (bufferParser.avail()) {\n        if (keyIdx === keys.length)\n          break;\n        const key = keys[keyIdx++];\n        const keyPublic = key.getPublicSSH();\n\n        const sigEntry = bufferParser.readString();\n        sigParser.init(sigEntry, 0);\n        const type = sigParser.readString(true);\n        let value = sigParser.readString();\n\n        let algo;\n        if (type !== key.type) {\n          if (key.type === 'ssh-rsa') {\n            switch (type) {\n              case 'rsa-sha2-256':\n                algo = 'sha256';\n                break;\n              case 'rsa-sha2-512':\n                algo = 'sha512';\n                break;\n              default:\n                continue;\n            }\n          } else {\n            continue;\n          }\n        }\n\n        const sessionID = client._protocol._kex.sessionID;\n        const verifyData = Buffer.allocUnsafe(\n          4 + 29 + 4 + sessionID.length + 4 + keyPublic.length\n        );\n        let p = 0;\n        writeUInt32BE(verifyData, 29, p);\n        verifyData.utf8Write('hostkeys-prove-00@openssh.com', p += 4, 29);\n        writeUInt32BE(verifyData, sessionID.length, p += 29);\n        bufferCopy(sessionID, verifyData, 0, sessionID.length, p += 4);\n        writeUInt32BE(verifyData, keyPublic.length, p += sessionID.length);\n        bufferCopy(keyPublic, verifyData, 0, keyPublic.length, p += 4);\n\n        if (!(value = sigSSHToASN1(value, type)))\n          continue;\n        if (key.verify(verifyData, value, algo) === true)\n          ret.push(key);\n      }\n      sigParser.clear();\n      bufferParser.clear();\n\n      cb(null, ret);\n    });\n\n    client._protocol.openssh_hostKeysProve(keys);\n    return;\n  }\n\n  process.nextTick(\n    cb,\n    new Error(\n      'strictVendor enabled and server is not OpenSSH or compatible version'\n    )\n  );\n}\n\nfunction getKeyAlgos(client, key, serverSigAlgs) {\n  switch (key.type) {\n    case 'ssh-rsa':\n      if (client._protocol._compatFlags & COMPAT.IMPLY_RSA_SHA2_SIGALGS) {\n        if (!Array.isArray(serverSigAlgs))\n          serverSigAlgs = ['rsa-sha2-256', 'rsa-sha2-512'];\n        else\n          serverSigAlgs = ['rsa-sha2-256', 'rsa-sha2-512', ...serverSigAlgs];\n      }\n      if (Array.isArray(serverSigAlgs)) {\n        if (serverSigAlgs.indexOf('rsa-sha2-256') !== -1)\n          return [['rsa-sha2-256', 'sha256']];\n        if (serverSigAlgs.indexOf('rsa-sha2-512') !== -1)\n          return [['rsa-sha2-512', 'sha512']];\n        if (serverSigAlgs.indexOf('ssh-rsa') === -1)\n          return [];\n      }\n      return [['ssh-rsa', 'sha1']];\n  }\n}\n\nmodule.exports = Client;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AAEZ,MAAM;EACJA,UAAU;EACVC,SAAS;EACTC;AACF,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;AACrB,MAAM;EAAEC;AAAO,CAAC,GAAGD,OAAO,CAAC,KAAK,CAAC;AACjC,MAAM;EAAEE,MAAM,EAAEC;AAAU,CAAC,GAAGH,OAAO,CAAC,KAAK,CAAC;AAC5C,MAAMI,YAAY,GAAGJ,OAAO,CAAC,QAAQ,CAAC;AACtC,MAAMK,MAAM,GAAGP,SAAS,EAAE;AAE1B,MAAM;EACJQ,MAAM;EACNC,yBAAyB,EAAE;IAAEC;EAAO,CAAC;EACrCC,oBAAoB;EACpBC,cAAc;EACdC,mBAAmB;EACnBC,WAAW;EACXC,WAAW;EACXC,uBAAuB;EACvBC,iBAAiB;EACjBC,0BAA0B;EAC1BC,gBAAgB;EAChBC,qBAAqB;EACrBC,aAAa;EACbC,aAAa;EACbC;AACF,CAAC,GAAGrB,OAAO,CAAC,yBAAyB,CAAC;AACtC,MAAM;EAAEsB,IAAI,EAAEC;AAAW,CAAC,GAAGvB,OAAO,CAAC,sBAAsB,CAAC;AAC5D,MAAMwB,QAAQ,GAAGxB,OAAO,CAAC,wBAAwB,CAAC;AAClD,MAAM;EAAEyB;AAAS,CAAC,GAAGzB,OAAO,CAAC,yBAAyB,CAAC;AACvD,MAAM;EAAE0B;AAAK,CAAC,GAAG1B,OAAO,CAAC,oBAAoB,CAAC;AAC9C,MAAM;EACJ2B,UAAU;EACVC,gBAAgB;EAChBC,SAAS;EACTC,YAAY;EACZC,YAAY;EACZC;AACF,CAAC,GAAGhC,OAAO,CAAC,qBAAqB,CAAC;AAElC,MAAM;EAAEiC,YAAY;EAAEC,WAAW;EAAEC;AAAQ,CAAC,GAAGnC,OAAO,CAAC,YAAY,CAAC;AACpE,MAAM;EACJoC,OAAO;EACPC,UAAU;EACVC,WAAW;EACXC,YAAY;EACZC;AACF,CAAC,GAAGxC,OAAO,CAAC,cAAc,CAAC;AAC3B,MAAM;EACJyC,cAAc;EACdC,qBAAqB;EACrBC,UAAU;EACVC,oBAAoB;EACpBC;AACF,CAAC,GAAG7C,OAAO,CAAC,YAAY,CAAC;AAEzB,MAAM8C,YAAY,GAAGlB,gBAAgB,EAAE;AACvC,MAAMmB,SAAS,GAAGnB,gBAAgB,EAAE;AACpC,MAAMoB,UAAU,GAAG,qCAAqC;AACxD,MAAMC,IAAI,GAAIC,GAAG,IAAK,CAAC,CAAC;AAExB,MAAMC,MAAM,SAAS/C,YAAY,CAAC;EAChCgD,WAAWA,CAAA,EAAG;IACZ,KAAK,EAAE;IAEP,IAAI,CAACC,MAAM,GAAG;MACZC,IAAI,EAAEC,SAAS;MACfC,IAAI,EAAED,SAAS;MACfE,YAAY,EAAEF,SAAS;MACvBG,SAAS,EAAEH,SAAS;MACpBI,SAAS,EAAEJ,SAAS;MACpBK,SAAS,EAAEL,SAAS;MACpBM,iBAAiB,EAAEN,SAAS;MAC5BO,iBAAiB,EAAEP,SAAS;MAC5BQ,YAAY,EAAER,SAAS;MACvBS,KAAK,EAAET,SAAS;MAEhBU,QAAQ,EAAEV,SAAS;MACnBW,QAAQ,EAAEX,SAAS;MACnBY,UAAU,EAAEZ,SAAS;MACrBa,WAAW,EAAEb,SAAS;MACtBc,KAAK,EAAEd,SAAS;MAChBe,aAAa,EAAEf,SAAS;MACxBgB,WAAW,EAAEhB,SAAS;MAEtBiB,YAAY,EAAEjB,SAAS;MACvBkB,UAAU,EAAElB,SAAS;MACrBmB,YAAY,EAAEnB,SAAS;MACvBoB,KAAK,EAAEpB;IACT,CAAC;IAED,IAAI,CAACqB,MAAM,GAAGrB,SAAS;IACvB,IAAI,CAACsB,aAAa,GAAGtB,SAAS;IAC9B,IAAI,CAACuB,QAAQ,GAAGvB,SAAS;IACzB,IAAI,CAACwB,UAAU,GAAGxB,SAAS;IAC3B,IAAI,CAACyB,WAAW,GAAGzB,SAAS;IAC5B,IAAI,CAAC0B,eAAe,GAAG1B,SAAS;IAChC,IAAI,CAAC2B,UAAU,GAAG3B,SAAS;IAC3B,IAAI,CAAC4B,gBAAgB,GAAG5B,SAAS;IACjC,IAAI,CAAC6B,UAAU,GAAG7B,SAAS;IAE3B,IAAI,CAAC8B,SAAS,GAAG9B,SAAS;IAC1B,IAAI,CAAC+B,KAAK,GAAG/B,SAAS;IACtB,IAAI,CAACgC,QAAQ,GAAGhC,SAAS;EAC3B;EAEAiC,OAAOA,CAACC,GAAG,EAAE;IAAA,IAAAC,KAAA;IACX,IAAI,IAAI,CAACJ,KAAK,IAAI3C,UAAU,CAAC,IAAI,CAAC2C,KAAK,CAAC,EAAE;MACxC,IAAI,CAACK,IAAI,CAAC,OAAO,EAAE,MAAM;QACvB,IAAI,CAACH,OAAO,CAACC,GAAG,CAAC;MACnB,CAAC,CAAC;MACF,IAAI,CAACG,GAAG,EAAE;MACV,OAAO,IAAI;IACb;IAEA,IAAI,CAACvC,MAAM,CAACC,IAAI,GAAGmC,GAAG,CAACI,QAAQ,IAAIJ,GAAG,CAACnC,IAAI,IAAI,WAAW;IAC1D,IAAI,CAACD,MAAM,CAACG,IAAI,GAAGiC,GAAG,CAACjC,IAAI,IAAI,EAAE;IACjC,IAAI,CAACH,MAAM,CAACI,YAAY,GAAI,OAAOgC,GAAG,CAAChC,YAAY,KAAK,QAAQ,GAClCgC,GAAG,CAAChC,YAAY,GAChBF,SAAU;IACxC,IAAI,CAACF,MAAM,CAACK,SAAS,GAAI,OAAO+B,GAAG,CAAC/B,SAAS,KAAK,QAAQ,IAC9B,OAAO+B,GAAG,CAAC/B,SAAS,KAAK,QAAQ,GAClC+B,GAAG,CAAC/B,SAAS,GACbH,SAAU;IACrC,IAAI,CAACF,MAAM,CAACM,SAAS,GAAG8B,GAAG,CAAC9B,SAAS,IAAI,KAAK;IAC9C,IAAI,CAACN,MAAM,CAACO,SAAS,GAAG6B,GAAG,CAAC7B,SAAS,IAAI,KAAK;IAC9C,IAAI,CAACP,MAAM,CAACQ,iBAAiB,GAAI,OAAO4B,GAAG,CAAC5B,iBAAiB,KAAK,QAAQ,IACtC4B,GAAG,CAAC5B,iBAAiB,IAAI,CAAC,GAC3B4B,GAAG,CAAC5B,iBAAiB,GACrB,CAAE;IACrC,IAAI,CAACR,MAAM,CAACS,iBAAiB,GAAI,OAAO2B,GAAG,CAAC3B,iBAAiB,KAAK,QAAQ,IACtC2B,GAAG,CAAC3B,iBAAiB,GAAG,CAAC,GAC1B2B,GAAG,CAAC3B,iBAAiB,GACrB,CAAE;IACrC,IAAI,CAACT,MAAM,CAACU,YAAY,GAAI,OAAO0B,GAAG,CAAC1B,YAAY,KAAK,QAAQ,IACjC0B,GAAG,CAAC1B,YAAY,IAAI,CAAC,GACtB0B,GAAG,CAAC1B,YAAY,GAChB,KAAM;IACpC,IAAI,CAACV,MAAM,CAACW,KAAK,GAAI,OAAOyB,GAAG,CAACzB,KAAK,KAAK,QAAQ,IAC1B8B,MAAM,CAACC,QAAQ,CAACN,GAAG,CAACzB,KAAK,CAAC,GAC3ByB,GAAG,CAACzB,KAAK,GACTT,SAAU;IAEjC,MAAMyC,UAAU,GAAG;MACjBC,GAAG,EAAE1C,SAAS;MACd2C,aAAa,EAAE3C,SAAS;MACxB4C,EAAE,EAAE;QACFC,MAAM,EAAE7C,SAAS;QACjB8C,GAAG,EAAE9C,SAAS;QACd+C,QAAQ,EAAE/C,SAAS;QACnBgD,IAAI,EAAE;MACR,CAAC;MACDC,EAAE,EAAEjD;IACN,CAAC;IACD,IAAIkD,gBAAgB,GAAG,IAAI;IAC3B,IAAI,OAAOhB,GAAG,CAACO,UAAU,KAAK,QAAQ,IAAIP,GAAG,CAACO,UAAU,KAAK,IAAI,EAAE;MACjEA,UAAU,CAACC,GAAG,GAAGvD,qBAAqB,CAAC+C,GAAG,CAACO,UAAU,CAACC,GAAG,EAClBrF,WAAW,EACXO,aAAa,CAAC;MACrD,IAAI6E,UAAU,CAACC,GAAG,KAAKrF,WAAW,EAChC6F,gBAAgB,GAAG,KAAK;MAE1BT,UAAU,CAACE,aAAa,GACtBxD,qBAAqB,CAAC+C,GAAG,CAACO,UAAU,CAACE,aAAa,EAC5BpF,uBAAuB,EACvBO,yBAAyB,CAAC;MAClD,IAAI2E,UAAU,CAACE,aAAa,KAAKpF,uBAAuB,EACtD2F,gBAAgB,GAAG,KAAK;MAE1BT,UAAU,CAACG,EAAE,CAACC,MAAM,GAAG1D,qBAAqB,CAAC+C,GAAG,CAACO,UAAU,CAACI,MAAM,EACrB1F,cAAc,EACdO,gBAAgB,CAAC;MAC9D,IAAI+E,UAAU,CAACG,EAAE,CAACC,MAAM,KAAK1F,cAAc,EACzC+F,gBAAgB,GAAG,KAAK;MAE1BT,UAAU,CAACG,EAAE,CAACE,GAAG,GAAG3D,qBAAqB,CAAC+C,GAAG,CAACO,UAAU,CAACU,IAAI,EACnB7F,WAAW,EACXO,aAAa,CAAC;MACxD,IAAI4E,UAAU,CAACG,EAAE,CAACE,GAAG,KAAKxF,WAAW,EACnC4F,gBAAgB,GAAG,KAAK;MAE1BT,UAAU,CAACG,EAAE,CAACG,QAAQ,GAAG5D,qBAAqB,CAAC+C,GAAG,CAACO,UAAU,CAACM,QAAQ,EACvB3F,mBAAmB,EACnBO,qBAAqB,CAAC;MACrE,IAAI8E,UAAU,CAACG,EAAE,CAACG,QAAQ,KAAK3F,mBAAmB,EAChD8F,gBAAgB,GAAG,KAAK;MAE1B,IAAI,CAACA,gBAAgB,EACnBT,UAAU,CAACQ,EAAE,GAAGR,UAAU,CAACG,EAAE;IACjC;IAEA,IAAI,OAAOV,GAAG,CAACxB,QAAQ,KAAK,QAAQ,EAClC,IAAI,CAACZ,MAAM,CAACY,QAAQ,GAAGwB,GAAG,CAACxB,QAAQ,CAAC,KACjC,IAAI,OAAOwB,GAAG,CAACkB,IAAI,KAAK,QAAQ,EACnC,IAAI,CAACtD,MAAM,CAACY,QAAQ,GAAGwB,GAAG,CAACkB,IAAI,CAAC,KAEhC,MAAM,IAAIC,KAAK,CAAC,kBAAkB,CAAC;IAErC,IAAI,CAACvD,MAAM,CAACa,QAAQ,GAAI,OAAOuB,GAAG,CAACvB,QAAQ,KAAK,QAAQ,GAC9BuB,GAAG,CAACvB,QAAQ,GACZX,SAAU;IACpC,IAAI,CAACF,MAAM,CAACc,UAAU,GAAI,OAAOsB,GAAG,CAACtB,UAAU,KAAK,QAAQ,IAC/B2B,MAAM,CAACC,QAAQ,CAACN,GAAG,CAACtB,UAAU,CAAC,GAChCsB,GAAG,CAACtB,UAAU,GACdZ,SAAU;IACtC,IAAI,CAACF,MAAM,CAACwD,aAAa,GAAI,OAAOpB,GAAG,CAACoB,aAAa,KAAK,QAAQ,GACnCpB,GAAG,CAACoB,aAAa,GACjBtD,SAAU;IACzC,IAAI,CAACF,MAAM,CAACyD,aAAa,GAAI,OAAOrB,GAAG,CAACqB,aAAa,KAAK,QAAQ,GACnCrB,GAAG,CAACqB,aAAa,GACjBvD,SAAU;IACzC,IAAI,CAACF,MAAM,CAACe,WAAW,GAAIqB,GAAG,CAACrB,WAAW,KAAK,IAAK;IACpD,IAAI,OAAOqB,GAAG,CAACpB,KAAK,KAAK,QAAQ,IAAIoB,GAAG,CAACpB,KAAK,CAAC0C,MAAM,EACnD,IAAI,CAAC1D,MAAM,CAACgB,KAAK,GAAGnC,WAAW,CAACuD,GAAG,CAACpB,KAAK,CAAC,CAAC,KACxC,IAAIlC,OAAO,CAACsD,GAAG,CAACpB,KAAK,CAAC,EACzB,IAAI,CAAChB,MAAM,CAACgB,KAAK,GAAGoB,GAAG,CAACpB,KAAK,CAAC,KAE9B,IAAI,CAAChB,MAAM,CAACgB,KAAK,GAAGd,SAAS;IAC/B,IAAI,CAACF,MAAM,CAACiB,aAAa,GAAImB,GAAG,CAACuB,YAAY,KAAK,IAAI,IACtB,IAAI,CAAC3D,MAAM,CAACgB,KAAK,KAAKd,SAAU;IAChE,IAAIgB,WAAW,GAAG,IAAI,CAAClB,MAAM,CAACkB,WAAW,GACvC,OAAOkB,GAAG,CAAClB,WAAW,KAAK,UAAU,IAClC0C,KAAK,CAACC,OAAO,CAACzB,GAAG,CAAClB,WAAW,CAAC,GAC/BkB,GAAG,CAAClB,WAAW,GACfhB,SACH;IAED,IAAI,CAACF,MAAM,CAACqB,YAAY,GAAI,OAAOe,GAAG,CAACf,YAAY,KAAK,SAAS,GACnCe,GAAG,CAACf,YAAY,GAChB,IAAK;IAEnC,MAAMC,KAAK,GAAG,IAAI,CAACtB,MAAM,CAACsB,KAAK,GAAI,OAAOc,GAAG,CAACd,KAAK,KAAK,UAAU,GAC7Bc,GAAG,CAACd,KAAK,GACTpB,SAAU;IAE/C,IAAIkC,GAAG,CAACuB,YAAY,KAAK,IAAI,IAAI,CAAC,IAAI,CAAC3D,MAAM,CAACiB,aAAa,EAAE;MAC3D,MAAM,IAAIsC,KAAK,CACb,2DAA2D,CAC5D;IACH;IAEA,IAAIO,SAAS,GAAG,IAAI,CAACpC,UAAU,GAAG,EAAE;IACpC,IAAI,CAACD,QAAQ,GAAG,IAAIrC,cAAc,CAAC,IAAI,CAAC;IACxC,IAAI,CAACuC,WAAW,GAAG,CAAC,CAAC;IACrB,IAAI,CAACC,eAAe,GAAG,CAAC,CAAC;IACzB,IAAI,CAACC,UAAU,GAAG,CAAC;IACnB,IAAI,CAACC,gBAAgB,GAAG,KAAK;IAC7B,IAAI,CAACP,MAAM,GAAI,IAAI,CAACvB,MAAM,CAACgB,KAAK,GAAG,IAAI,CAAChB,MAAM,CAACgB,KAAK,GAAGd,SAAU;IACjE,IAAI,CAAC6B,UAAU,GAAG7B,SAAS;IAC3B,IAAIY,UAAU;IAEd,IAAI,IAAI,CAACd,MAAM,CAACc,UAAU,EAAE;MAC1BA,UAAU,GAAG1C,QAAQ,CAAC,IAAI,CAAC4B,MAAM,CAACc,UAAU,EAAEsB,GAAG,CAAC2B,UAAU,CAAC;MAC7D,IAAIjD,UAAU,YAAYyC,KAAK,EAC7B,MAAM,IAAIA,KAAK,CAAE,4BAA2BzC,UAAU,CAACkD,OAAQ,EAAC,CAAC;MACnE,IAAIJ,KAAK,CAACC,OAAO,CAAC/C,UAAU,CAAC,EAAE;QAC7B;QACAA,UAAU,GAAGA,UAAU,CAAC,CAAC,CAAC;MAC5B;MACA,IAAIA,UAAU,CAACmD,aAAa,EAAE,KAAK,IAAI,EAAE;QACvC,MAAM,IAAIV,KAAK,CACb,yDAAyD,CAC1D;MACH;IACF;IAEA,IAAIW,YAAY;IAChB,IAAI,OAAO9B,GAAG,CAAC8B,YAAY,KAAK,UAAU,EAAE;MAC1C,MAAMC,MAAM,GAAG/B,GAAG,CAAC8B,YAAY;MAC/B,IAAIE,MAAM;MACV,IAAIpH,MAAM,CAACqH,OAAO,CAACjC,GAAG,CAACkC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE;QACvC;QACAF,MAAM,GAAG5H,UAAU,CAAC4F,GAAG,CAACkC,QAAQ,CAAC;MACnC;MACAJ,YAAY,GAAGA,CAACK,GAAG,EAAEC,MAAM,KAAK;QAC9B,IAAIJ,MAAM,EAAE;UACVA,MAAM,CAACK,MAAM,CAACF,GAAG,CAAC;UAClBA,GAAG,GAAGH,MAAM,CAACM,MAAM,CAAC,KAAK,CAAC;QAC5B;QACA,MAAMC,GAAG,GAAGR,MAAM,CAACI,GAAG,EAAEC,MAAM,CAAC;QAC/B,IAAIG,GAAG,KAAKzE,SAAS,EACnBsE,MAAM,CAACG,GAAG,CAAC;MACf,CAAC;IACH;IAEA,MAAMC,IAAI,GAAG,IAAI,CAAC3C,KAAK,GAAIG,GAAG,CAACwC,IAAI,IAAI,IAAIhI,MAAM,EAAG;IACpD,IAAIiI,KAAK,GAAG,KAAK;IACjB,IAAIC,SAAS,GAAG,KAAK;IACrB,IAAI,IAAI,CAAC9C,SAAS,EAChB,IAAI,CAACA,SAAS,CAAC+C,OAAO,EAAE;IAC1B,MAAMC,aAAa,GAAI,CAAC1D,KAAK,GAAGpB,SAAS,GAAG,CAAC+E,CAAC,EAAEC,OAAO,EAAEC,GAAG,KAAK;MAC/D7D,KAAK,CAAE,6BAA4B8D,IAAI,CAACC,SAAS,CAACF,GAAG,CAAE,EAAC,CAAC;IAC3D,CAAE;IACF,IAAIG,aAAa;IACjB,MAAMC,KAAK,GAAG,IAAI,CAACvD,SAAS,GAAG,IAAI7D,QAAQ,CAAC;MAC1CwC,KAAK,EAAE,IAAI,CAACX,MAAM,CAACW,KAAK;MACxB6E,KAAK,EAAGpC,gBAAgB,GAAGlD,SAAS,GAAGyC,UAAW;MAClD8C,OAAO,EAAGC,IAAI,IAAK;QACjB,IAAIpG,UAAU,CAACsF,IAAI,CAAC,EAClBA,IAAI,CAACe,KAAK,CAACD,IAAI,CAAC;MACpB,CAAC;MACDE,OAAO,EAAG/F,GAAG,IAAK;QAChB,IAAIA,GAAG,CAACgG,KAAK,KAAK,WAAW,EAC3BC,YAAY,CAAC,IAAI,CAACtE,aAAa,CAAC;QAClC,IAAI,CAAC+D,KAAK,CAACQ,SAAS,EAClBnB,IAAI,CAACoB,kBAAkB,CAAC,MAAM,CAAC;QACjC,IAAI,CAACC,IAAI,CAAC,OAAO,EAAEpG,GAAG,CAAC;QACvB,IAAI;UACF+E,IAAI,CAACrC,GAAG,EAAE;QACZ,CAAC,CAAC,MAAM,CAAC;MACX,CAAC;MACD2D,QAAQ,EAAGC,MAAM,IAAK;QACpBrB,SAAS,GAAG,IAAI;QAChB,IAAI,CAAC/C,UAAU,GAAGoE,MAAM,CAACC,QAAQ,CAACC,QAAQ;QAC1C,IAAIF,MAAM,CAACG,QAAQ,EACjB,IAAI,CAACL,IAAI,CAAC,UAAU,EAAEE,MAAM,CAACG,QAAQ,CAAC;MAC1C,CAAC;MACDC,mBAAmB,EAAGC,UAAU,IAAK;QACnC,IAAI,CAACP,IAAI,CAAC,WAAW,EAAEO,UAAU,CAAC;QAClC,IAAI,CAAC3B,KAAK,EAAE;UACVA,KAAK,GAAG,IAAI;UACZU,KAAK,CAACkB,OAAO,CAAC,cAAc,CAAC;QAC/B;MACF,CAAC;MACDnF,KAAK;MACL4C,YAAY;MACZwC,eAAe,EAAE;QACfC,KAAK,EAAE3B,aAAa;QACpB4B,UAAU,EAAEA,CAAC3B,CAAC,EAAE4B,MAAM,EAAEC,IAAI,KAAK;UAC/B,IAAID,MAAM,KAAKnJ,iBAAiB,CAACqJ,cAAc,EAAE;YAC/C,IAAI,CAACD,IAAI,EAAE;cACTA,IAAI,GAAGnJ,0BAA0B,CAACkJ,MAAM,CAAC;cACzC,IAAIC,IAAI,KAAK5G,SAAS,EACpB4G,IAAI,GAAI,oCAAmCD,MAAO,EAAC;YACvD;YACA,MAAMhH,GAAG,GAAG,IAAI0D,KAAK,CAACuD,IAAI,CAAC;YAC3BjH,GAAG,CAACmH,IAAI,GAAGH,MAAM;YACjB,IAAI,CAACZ,IAAI,CAAC,OAAO,EAAEpG,GAAG,CAAC;UACzB;UACA+E,IAAI,CAACrC,GAAG,EAAE;QACZ,CAAC;QACD0E,cAAc,EAAEA,CAAChC,CAAC,EAAEiC,IAAI,KAAK;UAC3B,IAAIA,IAAI,KAAK,cAAc,EACzBC,WAAW,EAAE;QACjB,CAAC;QACDC,QAAQ,EAAEA,CAACnC,CAAC,EAAEoC,IAAI,KAAK;UACrB,IAAI/B,aAAa,KAAKpF,SAAS,EAAE;YAC/B,KAAK,MAAMoH,GAAG,IAAID,IAAI,EAAE;cACtB,IAAIC,GAAG,CAACJ,IAAI,KAAK,iBAAiB,EAAE;gBAClC5B,aAAa,GAAGgC,GAAG,CAACC,IAAI;gBACxB;cACF;YACF;YACAjC,aAAa,GAAG,IAAI;UACtB;QACF,CAAC;QACDkC,eAAe,EAAEA,CAACvC,CAAC,EAAEE,GAAG,KAAK;UAC3B,IAAI,CAACc,IAAI,CAAC,QAAQ,EAAEd,GAAG,CAAC;QAC1B,CAAC;QACDsC,gBAAgB,EAAGxC,CAAC,IAAK;UACvB;UACAyC,OAAO,EAAE;UAET5B,YAAY,CAAC,IAAI,CAACtE,aAAa,CAAC;UAEhC,IAAI,CAACyE,IAAI,CAAC,OAAO,CAAC;QACpB,CAAC;QACD0B,gBAAgB,EAAEA,CAAC1C,CAAC,EAAE2C,WAAW,EAAEC,cAAc,KAAK;UACpD;UACA;UACA,IAAIC,OAAO,CAACC,QAAQ,EAAE;YACpB,MAAMC,UAAU,GAAGF,OAAO,CAACC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACzC,IAAIzG,KAAK,EACPA,KAAK,CAAE,WAAUwG,OAAO,CAACG,IAAK,KAAID,UAAW,eAAc,CAAC;YAC9DF,OAAO,CAACC,QAAQ,CAACG,KAAK,EAAE;YACxB,IAAIJ,OAAO,CAACC,QAAQ,CAACrE,MAAM,EAAE;cAC3B,MAAM,CAACyE,OAAO,EAAEC,QAAQ,CAAC,GAAGN,OAAO,CAACC,QAAQ,CAAC,CAAC,CAAC;cAC/C,QAAQD,OAAO,CAACG,IAAI;gBAClB,KAAK,OAAO;kBACV1C,KAAK,CAAC8C,MAAM,CACVP,OAAO,CAAClH,QAAQ,EAChBkH,OAAO,CAACQ,QAAQ,CAACC,UAAU,EAAE,EAC7BJ,OAAO,CACR;kBACD;gBACF,KAAK,WAAW;kBACd5C,KAAK,CAAC8C,MAAM,CAACP,OAAO,CAAClH,QAAQ,EAAEkH,OAAO,CAACvD,GAAG,EAAE4D,OAAO,CAAC;kBACpD;gBACF,KAAK,WAAW;kBACd5C,KAAK,CAACiD,aAAa,CAACV,OAAO,CAAClH,QAAQ,EAChBkH,OAAO,CAACvD,GAAG,EACXuD,OAAO,CAACtE,aAAa,EACrBsE,OAAO,CAACrE,aAAa,EACrB0E,OAAO,EACP,CAACM,GAAG,EAAEC,EAAE,KAAK;oBAC/B,MAAMC,SAAS,GAAGb,OAAO,CAACvD,GAAG,CAACqE,IAAI,CAACH,GAAG,EAAEL,QAAQ,CAAC;oBACjD,IAAIO,SAAS,YAAYpF,KAAK,EAAE;sBAC9BoF,SAAS,CAAC3E,OAAO,GACd,iCAAgC2E,SAAS,CAAC3E,OAAQ,EAAC;sBACtD2E,SAAS,CAAC9C,KAAK,GAAG,uBAAuB;sBACzC,IAAI,CAACI,IAAI,CAAC,OAAO,EAAE0C,SAAS,CAAC;sBAC7B,OAAOxB,WAAW,EAAE;oBACtB;oBAEAuB,EAAE,CAACC,SAAS,CAAC;kBACf,CAAC,CAAC;kBACF;cAAO;YAEb,CAAC,MAAM;cACLb,OAAO,CAACC,QAAQ,GAAG7H,SAAS;YAC9B;UACF;UAEA,IAAI4H,OAAO,CAACG,IAAI,KAAK,OAAO,EAAE;YAC5B,MAAMY,GAAG,GAAGf,OAAO,CAACQ,QAAQ,CAACO,GAAG,EAAE;YAClCvH,KAAK,IAAIA,KAAK,CAAE,sBAAqBuH,GAAG,GAAG,CAAE,SAAQ,CAAC;YACtD,OAAOC,eAAe,EAAE;UAC1B;UAEAxH,KAAK,IAAIA,KAAK,CAAE,WAAUwG,OAAO,CAACG,IAAK,cAAa,CAAC;UAErDc,UAAU,GAAGlB,cAAc;UAC3BmB,YAAY,GAAGpB,WAAW;UAC1BT,WAAW,EAAE;QACf,CAAC;QACD8B,yBAAyB,EAAEA,CAAChE,CAAC,EAAEiE,MAAM,KAAK;UACxC,IAAIpB,OAAO,CAACG,IAAI,KAAK,UAAU,EAAE;YAC/B;YACA;YACA,IAAI,CAAChC,IAAI,CAAC,iBAAiB,EAAEiD,MAAM,EAAGC,WAAW,IAAK;cACpD5D,KAAK,CAAC6D,YAAY,CAChB,IAAI,CAACpJ,MAAM,CAACY,QAAQ,EACpB,IAAI,CAACZ,MAAM,CAACa,QAAQ,EACpBsI,WAAW,CACZ;YACH,CAAC,CAAC;UACJ;QACF,CAAC;QACDE,cAAc,EAAGpE,CAAC,IAAK;UACrB,IAAIkD,OAAO;UACX,IAAIC,QAAQ;UACZ,IAAIN,OAAO,CAACC,QAAQ,EAClB,CAACI,OAAO,EAAEC,QAAQ,CAAC,GAAGN,OAAO,CAACC,QAAQ,CAAC,CAAC,CAAC;UAC3C,IAAID,OAAO,CAACG,IAAI,KAAK,OAAO,EAAE;YAC5B,MAAM1D,GAAG,GAAGuD,OAAO,CAACQ,QAAQ,CAACC,UAAU,EAAE;YACzChD,KAAK,CAAC8C,MAAM,CAACP,OAAO,CAAClH,QAAQ,EAAE2D,GAAG,EAAE4D,OAAO,EAAE,CAACM,GAAG,EAAEC,EAAE,KAAK;cACxD,MAAMY,IAAI,GAAG;gBAAEC,IAAI,EAAEnB;cAAS,CAAC;cAC/BN,OAAO,CAACQ,QAAQ,CAACM,IAAI,CAACrE,GAAG,EAAEkE,GAAG,EAAEa,IAAI,EAAE,CAACzJ,GAAG,EAAE2J,MAAM,KAAK;gBACrD,IAAI3J,GAAG,EAAE;kBACPA,GAAG,CAACgG,KAAK,GAAG,OAAO;kBACnB,IAAI,CAACI,IAAI,CAAC,OAAO,EAAEpG,GAAG,CAAC;gBACzB,CAAC,MAAM;kBACL,OAAO6I,EAAE,CAACc,MAAM,CAAC;gBACnB;gBAEAV,eAAe,EAAE;cACnB,CAAC,CAAC;YACJ,CAAC,CAAC;UACJ,CAAC,MAAM,IAAIhB,OAAO,CAACG,IAAI,KAAK,WAAW,EAAE;YACvC1C,KAAK,CAAC8C,MAAM,CAACP,OAAO,CAAClH,QAAQ,EAAEkH,OAAO,CAACvD,GAAG,EAAE4D,OAAO,EAAE,CAACM,GAAG,EAAEC,EAAE,KAAK;cAChE,MAAMC,SAAS,GAAGb,OAAO,CAACvD,GAAG,CAACqE,IAAI,CAACH,GAAG,EAAEL,QAAQ,CAAC;cACjD,IAAIO,SAAS,YAAYpF,KAAK,EAAE;gBAC9BoF,SAAS,CAAC3E,OAAO,GACd,gCAA+B2E,SAAS,CAAC3E,OAAQ,EAAC;gBACrD2E,SAAS,CAAC9C,KAAK,GAAG,uBAAuB;gBACzC,IAAI,CAACI,IAAI,CAAC,OAAO,EAAE0C,SAAS,CAAC;gBAC7B,OAAOxB,WAAW,EAAE;cACtB;cACAuB,EAAE,CAACC,SAAS,CAAC;YACf,CAAC,CAAC;UACJ;QACF,CAAC;QACDc,qBAAqB,EAAEA,CAACxE,CAAC,EAAEiC,IAAI,EAAEwC,YAAY,EAAEC,OAAO,KAAK;UACzD,IAAI7B,OAAO,CAACG,IAAI,KAAK,sBAAsB,EAAE;YAC3C,MAAM2B,QAAQ,GAAIhG,KAAK,CAACC,OAAO,CAAC8F,OAAO,CAAC,GAAGA,OAAO,CAACjG,MAAM,GAAG,CAAE;YAC9D,IAAIkG,QAAQ,KAAK,CAAC,EAAE;cAClBtI,KAAK,IAAIA,KAAK,CACZ,kDAAkD,CACnD;cACDiE,KAAK,CAACsE,WAAW,EAAE;cACnB;YACF;YACA;YACA;YACA;YACA/B,OAAO,CAACoB,MAAM,CACZhC,IAAI,EACJwC,YAAY,EACZ,EAAE,EACFC,OAAO,EACNG,OAAO,IAAK;cACXvE,KAAK,CAACsE,WAAW,CAACC,OAAO,CAAC;YAC5B,CAAC,CACF;UACH;QACF,CAAC;QACDC,eAAe,EAAEA,CAAC9E,CAAC,EAAES,IAAI,KAAK;UAC5B,IAAI5B,SAAS,CAACJ,MAAM,EAClBI,SAAS,CAACoE,KAAK,EAAE,CAAC,KAAK,EAAExC,IAAI,CAAC;QAClC,CAAC;QACDsE,eAAe,EAAG/E,CAAC,IAAK;UACtB,IAAInB,SAAS,CAACJ,MAAM,EAClBI,SAAS,CAACoE,KAAK,EAAE,CAAC,IAAI,CAAC;QAC3B,CAAC;QACD+B,cAAc,EAAEA,CAAChF,CAAC,EAAEiC,IAAI,EAAEgD,SAAS,EAAExE,IAAI,KAAK;UAC5C,QAAQwB,IAAI;YACV,KAAK,yBAAyB;cAC5B;cACAiD,aAAa,CAAC,IAAI,EAAEzE,IAAI,EAAE,CAAC7F,GAAG,EAAEuK,IAAI,KAAK;gBACvC,IAAIvK,GAAG,EACL;gBACF,IAAI,CAACoG,IAAI,CAAC,UAAU,EAAEmE,IAAI,CAAC;cAC7B,CAAC,CAAC;cACF,IAAIF,SAAS,EACX3E,KAAK,CAAC8E,cAAc,EAAE;cACxB;YACF;cACE;cACA;cACA;cACA,IAAIH,SAAS,EACX3E,KAAK,CAAC+E,cAAc,EAAE;UAAC;QAE/B,CAAC;QACDC,YAAY,EAAEA,CAACtF,CAAC,EAAEuF,IAAI,KAAK;UACzB;UACA;UACAC,cAAc,CAAC,IAAI,EAAED,IAAI,CAAC;QAC5B,CAAC;QACDE,yBAAyB,EAAEA,CAACzF,CAAC,EAAEuF,IAAI,KAAK;UACtC,MAAMG,OAAO,GAAG,IAAI,CAAClJ,QAAQ,CAACmJ,GAAG,CAACJ,IAAI,CAACK,SAAS,CAAC;UACjD,IAAI,OAAOF,OAAO,KAAK,UAAU,EAC/B;UAEF,MAAMG,MAAM,GAAIH,OAAO,CAAC1C,IAAI,KAAK,MAAO;UACxC,MAAMA,IAAI,GAAI6C,MAAM,GAAG,SAAS,GAAGH,OAAO,CAAC1C,IAAK;UAChD,MAAM8C,QAAQ,GAAG;YACf9C,IAAI;YACJ+C,QAAQ,EAAE;cACRC,EAAE,EAAET,IAAI,CAACK,SAAS;cAClBK,MAAM,EAAElM,UAAU;cAClBmM,UAAU,EAAElM,WAAW;cACvBmM,KAAK,EAAE;YACT,CAAC;YACDC,QAAQ,EAAE;cACRJ,EAAE,EAAET,IAAI,CAACc,MAAM;cACfJ,MAAM,EAAEV,IAAI,CAACU,MAAM;cACnBC,UAAU,EAAEX,IAAI,CAACW,UAAU;cAC3BC,KAAK,EAAE;YACT;UACF,CAAC;UACD,MAAMG,QAAQ,GACZT,MAAM,GACJ,IAAIzM,IAAI,CAAC,IAAI,EAAE0M,QAAQ,EAAE;YAAEzJ;UAAM,CAAC,CAAC,GACnC,IAAIvC,OAAO,CAAC,IAAI,EAAEgM,QAAQ,CAC7B;UACD,IAAI,CAACtJ,QAAQ,CAACgD,MAAM,CAAC+F,IAAI,CAACK,SAAS,EAAEU,QAAQ,CAAC;UAC9CZ,OAAO,CAACzK,SAAS,EAAEqL,QAAQ,CAAC;QAC9B,CAAC;QACDnO,oBAAoB,EAAEA,CAAC6H,CAAC,EAAE4F,SAAS,EAAEhE,MAAM,EAAE2E,WAAW,KAAK;UAC3D,MAAMb,OAAO,GAAG,IAAI,CAAClJ,QAAQ,CAACmJ,GAAG,CAACC,SAAS,CAAC;UAC5C,IAAI,OAAOF,OAAO,KAAK,UAAU,EAC/B;UAEF,MAAMH,IAAI,GAAG;YAAE3D,MAAM;YAAE2E;UAAY,CAAC;UACpCjM,oBAAoB,CAAC,IAAI,EAAEsL,SAAS,EAAEL,IAAI,EAAEG,OAAO,CAAC;QACtD,CAAC;QACDc,YAAY,EAAEA,CAACxG,CAAC,EAAE4F,SAAS,EAAEnF,IAAI,KAAK;UACpC,MAAMiF,OAAO,GAAG,IAAI,CAAClJ,QAAQ,CAACmJ,GAAG,CAACC,SAAS,CAAC;UAC5C,IAAI,OAAOF,OAAO,KAAK,QAAQ,IAAIA,OAAO,KAAK,IAAI,EACjD;;UAEF;UACA;UACA;UACA,IAAIA,OAAO,CAACK,QAAQ,CAACE,MAAM,KAAK,CAAC,EAC/B;UAEFP,OAAO,CAACK,QAAQ,CAACE,MAAM,IAAIxF,IAAI,CAAChC,MAAM;UAEtC,IAAIiH,OAAO,CAACe,IAAI,CAAChG,IAAI,CAAC,KAAK,KAAK,EAAE;YAChCiF,OAAO,CAACgB,cAAc,GAAG,IAAI;YAC7B;UACF;UAEA,IAAIhB,OAAO,CAACK,QAAQ,CAACE,MAAM,IAAI/L,gBAAgB,EAC7CD,YAAY,CAACyL,OAAO,CAAC;QACzB,CAAC;QACDiB,qBAAqB,EAAEA,CAAC3G,CAAC,EAAE4F,SAAS,EAAEnF,IAAI,EAAEuC,IAAI,KAAK;UACnD,IAAIA,IAAI,KAAK9K,MAAM,EACjB;UAEF,MAAMwN,OAAO,GAAG,IAAI,CAAClJ,QAAQ,CAACmJ,GAAG,CAACC,SAAS,CAAC;UAC5C,IAAI,OAAOF,OAAO,KAAK,QAAQ,IAAIA,OAAO,KAAK,IAAI,EACjD;;UAEF;UACA;UACA;UACA,IAAIA,OAAO,CAACK,QAAQ,CAACE,MAAM,KAAK,CAAC,EAC/B;UAEFP,OAAO,CAACK,QAAQ,CAACE,MAAM,IAAIxF,IAAI,CAAChC,MAAM;UAEtC,IAAI,CAACiH,OAAO,CAACkB,MAAM,CAACH,IAAI,CAAChG,IAAI,CAAC,EAAE;YAC9BiF,OAAO,CAACgB,cAAc,GAAG,IAAI;YAC7B;UACF;UAEA,IAAIhB,OAAO,CAACK,QAAQ,CAACE,MAAM,IAAI/L,gBAAgB,EAC7CD,YAAY,CAACyL,OAAO,CAAC;QACzB,CAAC;QACDmB,qBAAqB,EAAEA,CAAC7G,CAAC,EAAE4F,SAAS,EAAEkB,MAAM,KAAK;UAC/C,MAAMpB,OAAO,GAAG,IAAI,CAAClJ,QAAQ,CAACmJ,GAAG,CAACC,SAAS,CAAC;UAC5C,IAAI,OAAOF,OAAO,KAAK,QAAQ,IAAIA,OAAO,KAAK,IAAI,EACjD;;UAEF;UACAA,OAAO,CAACU,QAAQ,CAACH,MAAM,IAAIa,MAAM;UAEjC,IAAIpB,OAAO,CAACqB,WAAW,EAAE;YACvBrB,OAAO,CAACqB,WAAW,GAAG,KAAK;YAE3B,IAAIrB,OAAO,CAACsB,MAAM,EAAE;cAClBtB,OAAO,CAACuB,MAAM,CAACvB,OAAO,CAACsB,MAAM,EAAE,IAAI,EAAEtB,OAAO,CAACwB,QAAQ,CAAC;YACxD,CAAC,MAAM,IAAIxB,OAAO,CAACwB,QAAQ,EAAE;cAC3BxB,OAAO,CAACwB,QAAQ,EAAE;YACpB,CAAC,MAAM,IAAIxB,OAAO,CAACyB,SAAS,EAAE;cAC5BzB,OAAO,CAACkB,MAAM,CAACK,MAAM,CAACvB,OAAO,CAACyB,SAAS,EACjB,IAAI,EACJzB,OAAO,CAAC0B,WAAW,CAAC;YAC5C,CAAC,MAAM,IAAI1B,OAAO,CAAC0B,WAAW,EAAE;cAC9B1B,OAAO,CAAC0B,WAAW,EAAE;YACvB;UACF;QACF,CAAC;QACDC,eAAe,EAAEA,CAACrH,CAAC,EAAE4F,SAAS,KAAK;UACjC,MAAMF,OAAO,GAAG,IAAI,CAAClJ,QAAQ,CAACmJ,GAAG,CAACC,SAAS,CAAC;UAC5C,IAAI,OAAOF,OAAO,KAAK,QAAQ,IAAIA,OAAO,KAAK,IAAI,EACjD;UAEF,IAAI,CAACzI,QAAQ,EAAE;UAEf,IAAIyI,OAAO,CAACjJ,UAAU,CAACgC,MAAM,EAC3BiH,OAAO,CAACjJ,UAAU,CAACwG,KAAK,EAAE,CAAC,KAAK,CAAC;QACrC,CAAC;QACDqE,eAAe,EAAEA,CAACtH,CAAC,EAAE4F,SAAS,KAAK;UACjC,MAAMF,OAAO,GAAG,IAAI,CAAClJ,QAAQ,CAACmJ,GAAG,CAACC,SAAS,CAAC;UAC5C,IAAI,OAAOF,OAAO,KAAK,QAAQ,IAAIA,OAAO,KAAK,IAAI,EACjD;UAEF,IAAI,CAACzI,QAAQ,EAAE;UAEf,IAAIyI,OAAO,CAACjJ,UAAU,CAACgC,MAAM,EAC3BiH,OAAO,CAACjJ,UAAU,CAACwG,KAAK,EAAE,CAAC,IAAI,CAAC;QACpC,CAAC;QACDsE,eAAe,EAAEA,CAACvH,CAAC,EAAE4F,SAAS,EAAE5C,IAAI,EAAEiC,SAAS,EAAExE,IAAI,KAAK;UACxD,MAAMiF,OAAO,GAAG,IAAI,CAAClJ,QAAQ,CAACmJ,GAAG,CAACC,SAAS,CAAC;UAC5C,IAAI,OAAOF,OAAO,KAAK,QAAQ,IAAIA,OAAO,KAAK,IAAI,EACjD;UAEF,MAAM8B,IAAI,GAAG9B,OAAO,CAAC+B,KAAK;UAC1B,IAAID,IAAI,CAACzF,IAAI,KAAK9G,SAAS,EACzB;UACF,QAAQ+H,IAAI;YACV,KAAK,aAAa;cAChB0C,OAAO,CAAC1E,IAAI,CAAC,MAAM,EAAEwG,IAAI,CAACzF,IAAI,GAAGtB,IAAI,CAAC;cACtC;YACF,KAAK,aAAa;cAChBiF,OAAO,CAAC1E,IAAI,CAAC,MAAM,EACNwG,IAAI,CAACzF,IAAI,GAAG,IAAI,EAChByF,IAAI,CAACE,MAAM,GAAI,MAAKjH,IAAI,CAACiH,MAAO,EAAC,EACjCF,IAAI,CAACG,IAAI,GAAGlH,IAAI,CAACmH,UAAU,EAC3BJ,IAAI,CAAC3F,IAAI,GAAGpB,IAAI,CAACoH,YAAY,CAAC;cAC3C;UAAO;;UAGX;UACA;;UAEA,IAAI5C,SAAS,EACXjF,CAAC,CAAC8H,cAAc,CAACpC,OAAO,CAACU,QAAQ,CAACJ,EAAE,CAAC;QACzC,CAAC;QACD+B,WAAW,EAAEA,CAAC/H,CAAC,EAAE4F,SAAS,KAAK;UAC7B,MAAMF,OAAO,GAAG,IAAI,CAAClJ,QAAQ,CAACmJ,GAAG,CAACC,SAAS,CAAC;UAC5C,IAAI,OAAOF,OAAO,KAAK,QAAQ,IAAIA,OAAO,KAAK,IAAI,EACjD;UAEF,IAAIA,OAAO,CAACK,QAAQ,CAACI,KAAK,KAAK,MAAM,EACnC;UACFT,OAAO,CAACK,QAAQ,CAACI,KAAK,GAAG,KAAK;UAE9B,IAAIT,OAAO,CAACsC,QAAQ,EAClBtC,OAAO,CAACe,IAAI,CAAC,IAAI,CAAC;UACpB,IAAIf,OAAO,CAACkB,MAAM,CAACoB,QAAQ,EACzBtC,OAAO,CAACkB,MAAM,CAACH,IAAI,CAAC,IAAI,CAAC;QAC7B,CAAC;QACDwB,aAAa,EAAEA,CAACjI,CAAC,EAAE4F,SAAS,KAAK;UAC/BrL,eAAe,CAAC,IAAI,EAAEqL,SAAS,EAAE,IAAI,CAACpJ,QAAQ,CAACmJ,GAAG,CAACC,SAAS,CAAC,CAAC;QAChE;MACF;IACF,CAAC,CAAC;IAEFjG,IAAI,CAACuI,KAAK,EAAE;;IAEZ;IACA;IACA,MAAMC,UAAU,GAAG,IAAI,CAACpN,MAAM,CAACS,iBAAiB;IAChD,MAAM4M,UAAU,GAAG,IAAI,CAACrN,MAAM,CAACQ,iBAAiB;IAChD,IAAI8M,OAAO,GAAG,CAAC;IACf,IAAIC,OAAO;IACX,MAAMC,MAAM,GAAGA,CAAA,KAAM;MACnB,IAAI,EAAEF,OAAO,GAAGD,UAAU,EAAE;QAC1BI,aAAa,CAACF,OAAO,CAAC;QACtB,IAAI3I,IAAI,CAACqI,QAAQ,EAAE;UACjB,MAAMpN,GAAG,GAAG,IAAI0D,KAAK,CAAC,mBAAmB,CAAC;UAC1C1D,GAAG,CAACgG,KAAK,GAAG,gBAAgB;UAC5B,IAAI,CAACI,IAAI,CAAC,OAAO,EAAEpG,GAAG,CAAC;UACvB+E,IAAI,CAAC8I,OAAO,EAAE;QAChB;QACA;MACF;MACA,IAAIpO,UAAU,CAACsF,IAAI,CAAC,EAAE;QACpB;QACAd,SAAS,CAAC4H,IAAI,CAAChE,OAAO,CAAC;QACvBnC,KAAK,CAACoI,IAAI,EAAE;MACd,CAAC,MAAM;QACLF,aAAa,CAACF,OAAO,CAAC;MACxB;IACF,CAAC;IACD,SAAS7F,OAAOA,CAAA,EAAG;MACjB,IAAI0F,UAAU,GAAG,CAAC,EAAE;QAClBE,OAAO,GAAG,CAAC;QACXG,aAAa,CAACF,OAAO,CAAC;QACtB,IAAIjO,UAAU,CAACsF,IAAI,CAAC,EAClB2I,OAAO,GAAGK,WAAW,CAACJ,MAAM,EAAEJ,UAAU,CAAC;MAC7C;IACF;IACA,IAAI,CAAClL,QAAQ,GAAGwF,OAAO;IAEvB,MAAMmG,MAAM,GAAG,CAAC,MAAM;MACpB,IAAIC,MAAM,GAAG,KAAK;MAClB,OAAO,MAAM;QACX,IAAIA,MAAM,EACR;QACFA,MAAM,GAAG,IAAI;QACb,IAAIC,YAAY,IAAI,CAACjJ,SAAS,EAAE;UAC9B,MAAMjF,GAAG,GACPrB,SAAS,CAAC,kCAAkC,EAAE,UAAU,EAAE,IAAI,CAAC;UACjE,IAAI,CAACyH,IAAI,CAAC,OAAO,EAAEpG,GAAG,CAAC;QACzB;MACF,CAAC;IACH,CAAC,GAAG;IACJ,MAAMmO,SAAS,GAAG,CAAC,MAAM;MACvB,IAAIF,MAAM,GAAG,KAAK;MAClB,OAAO,MAAM;QACX,IAAIA,MAAM,EACR;QACFA,MAAM,GAAG,IAAI;QAEbC,YAAY,GAAG,IAAI;QACnBzM,KAAK,IAAIA,KAAK,CAAC,kBAAkB,CAAC;QAClC,IAAI,CAAC2E,IAAI,CAAC,SAAS,CAAC;QAEpB/H,UAAU,CAAC+P,IAAI,CAAC,MAAM;UACpB1I,KAAK,CAAC2I,KAAK,EAAE;UACbtJ,IAAI,CAACuJ,EAAE,CAAC,MAAM,EAAGzI,IAAI,IAAK;YACxB,IAAI;cACFH,KAAK,CAAC6I,KAAK,CAAC1I,IAAI,EAAE,CAAC,EAAEA,IAAI,CAAChC,MAAM,CAAC;YACnC,CAAC,CAAC,OAAO2K,EAAE,EAAE;cACX,IAAI,CAACpI,IAAI,CAAC,OAAO,EAAEoI,EAAE,CAAC;cACtB,IAAI;gBACF,IAAI/O,UAAU,CAACsF,IAAI,CAAC,EAClBA,IAAI,CAACrC,GAAG,EAAE;cACd,CAAC,CAAC,MAAM,CAAC;YACX;UACF,CAAC,CAAC;;UAEF;UACA,IAAIqC,IAAI,CAACiH,MAAM,IAAI,OAAOjH,IAAI,CAACiH,MAAM,CAACyC,MAAM,KAAK,UAAU,EACzD1J,IAAI,CAACiH,MAAM,CAACyC,MAAM,EAAE;UAEtB1J,IAAI,CAAC0J,MAAM,EAAE;QACf,CAAC,CAAC,CAACC,KAAK,CAAE1O,GAAG,IAAK;UAChB,IAAI,CAACoG,IAAI,CAAC,OAAO,EAAEpG,GAAG,CAAC;UACvB,IAAI;YACF,IAAIP,UAAU,CAACsF,IAAI,CAAC,EAClBA,IAAI,CAACrC,GAAG,EAAE;UACd,CAAC,CAAC,MAAM,CAAC;QACX,CAAC,CAAC;MACJ,CAAC;IACH,CAAC,GAAG;IACJ,IAAIwL,YAAY,GAAG,KAAK;IACxBnJ,IAAI,CAACuJ,EAAE,CAAC,SAAS,EAAEH,SAAS,CAAC,CACxBG,EAAE,CAAC,SAAS,EAAE,MAAM;MACvB,IAAI,CAAClI,IAAI,CAAC,SAAS,CAAC;IACtB,CAAC,CAAC,CAACkI,EAAE,CAAC,OAAO,EAAGtO,GAAG,IAAK;MACtByB,KAAK,IAAIA,KAAK,CAAE,iBAAgBzB,GAAG,CAACmE,OAAQ,EAAC,CAAC;MAC9C8B,YAAY,CAAC,IAAI,CAACtE,aAAa,CAAC;MAChC3B,GAAG,CAACgG,KAAK,GAAG,eAAe;MAC3B,IAAI,CAACI,IAAI,CAAC,OAAO,EAAEpG,GAAG,CAAC;IACzB,CAAC,CAAC,CAACsO,EAAE,CAAC,KAAK,EAAE,MAAM;MACjB7M,KAAK,IAAIA,KAAK,CAAC,cAAc,CAAC;MAC9BuM,MAAM,EAAE;MACRtI,KAAK,CAACR,OAAO,EAAE;MACfe,YAAY,CAAC,IAAI,CAACtE,aAAa,CAAC;MAChCiM,aAAa,CAACF,OAAO,CAAC;MACtB,IAAI,CAACtH,IAAI,CAAC,KAAK,CAAC;IAClB,CAAC,CAAC,CAACkI,EAAE,CAAC,OAAO,EAAE,MAAM;MACnB7M,KAAK,IAAIA,KAAK,CAAC,eAAe,CAAC;MAC/BuM,MAAM,EAAE;MACRtI,KAAK,CAACR,OAAO,EAAE;MACfe,YAAY,CAAC,IAAI,CAACtE,aAAa,CAAC;MAChCiM,aAAa,CAACF,OAAO,CAAC;MACtB,IAAI,CAACtH,IAAI,CAAC,OAAO,CAAC;;MAElB;MACA,MAAMuI,UAAU,GAAG1K,SAAS;MAC5BA,SAAS,GAAG,IAAI,CAACpC,UAAU,GAAG,EAAE;MAChC,MAAM7B,GAAG,GAAG,IAAI0D,KAAK,CAAC,yBAAyB,CAAC;MAChD,KAAK,IAAIkL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,UAAU,CAAC9K,MAAM,EAAE,EAAE+K,CAAC,EACxCD,UAAU,CAACC,CAAC,CAAC,CAAC5O,GAAG,CAAC;;MAEpB;MACA,IAAI,CAAC4B,QAAQ,CAACsD,OAAO,CAAClF,GAAG,CAAC;IAC5B,CAAC,CAAC;;IAEF;IACA,IAAIiI,OAAO;IACX,IAAIiB,UAAU,GAAG,IAAI;IACrB,IAAIC,YAAY,GAAG,IAAI;IACvB,MAAM0F,YAAY,GAAG,CAAC,MAAM,CAAC;IAC7B,IAAI,IAAI,CAAC1O,MAAM,CAACa,QAAQ,KAAKX,SAAS,EACpCwO,YAAY,CAAChD,IAAI,CAAC,UAAU,CAAC;IAC/B,IAAI5K,UAAU,KAAKZ,SAAS,EAC1BwO,YAAY,CAAChD,IAAI,CAAC,WAAW,CAAC;IAChC,IAAI,IAAI,CAACnK,MAAM,KAAKrB,SAAS,EAC3BwO,YAAY,CAAChD,IAAI,CAAC,OAAO,CAAC;IAC5B,IAAI,IAAI,CAAC1L,MAAM,CAACe,WAAW,EACzB2N,YAAY,CAAChD,IAAI,CAAC,sBAAsB,CAAC;IAC3C,IAAI5K,UAAU,KAAKZ,SAAS,IACrB,IAAI,CAACF,MAAM,CAACwD,aAAa,KAAKtD,SAAS,IACvC,IAAI,CAACF,MAAM,CAACyD,aAAa,KAAKvD,SAAS,EAAE;MAC9CwO,YAAY,CAAChD,IAAI,CAAC,WAAW,CAAC;IAChC;IAEA,IAAI9H,KAAK,CAACC,OAAO,CAAC3C,WAAW,CAAC,EAC5BA,WAAW,GAAGyN,qBAAqB,CAACzN,WAAW,CAAC,CAAC,KAC9C,IAAI,OAAOA,WAAW,KAAK,UAAU,EACxCA,WAAW,GAAGyN,qBAAqB,CAACD,YAAY,CAAC;IAEnD,IAAIE,WAAW,GAAG,KAAK;IACvB,MAAMC,UAAU,GAAIC,QAAQ,IAAK;MAC/B,IAAIF,WAAW,EACb;MACFA,WAAW,GAAG,IAAI;MAElB,IAAIE,QAAQ,KAAK,KAAK,EAAE;QACtB,MAAMjP,GAAG,GAAG,IAAI0D,KAAK,CAAC,8CAA8C,CAAC;QACrE1D,GAAG,CAACgG,KAAK,GAAG,uBAAuB;QACnC,IAAI,CAACI,IAAI,CAAC,OAAO,EAAEpG,GAAG,CAAC;QACvB,IAAI,CAAC0C,GAAG,EAAE;QACV;MACF;MAEA,IAAI,OAAOuM,QAAQ,KAAK,QAAQ,EAAE;QAChC;QACA;QACA;;QAEA,MAAM7G,IAAI,GAAG6G,QAAQ;QACrB,IAAIJ,YAAY,CAACrK,OAAO,CAAC4D,IAAI,CAAC,KAAK,CAAC,CAAC,EACnC,OAAO8G,QAAQ,CAAE,sCAAqC9G,IAAK,EAAC,CAAC;QAE/D,MAAMrH,QAAQ,GAAG,IAAI,CAACZ,MAAM,CAACY,QAAQ;QACrC,QAAQqH,IAAI;UACV,KAAK,UAAU;YACb6G,QAAQ,GAAG;cAAE7G,IAAI;cAAErH,QAAQ;cAAEC,QAAQ,EAAE,IAAI,CAACb,MAAM,CAACa;YAAS,CAAC;YAC7D;UACF,KAAK,WAAW;YACdiO,QAAQ,GAAG;cAAE7G,IAAI;cAAErH,QAAQ;cAAE2D,GAAG,EAAEzD;YAAW,CAAC;YAC9C;UACF,KAAK,WAAW;YACdgO,QAAQ,GAAG;cACT7G,IAAI;cACJrH,QAAQ;cACR2D,GAAG,EAAEzD,UAAU;cACf0C,aAAa,EAAE,IAAI,CAACxD,MAAM,CAACwD,aAAa;cACxCC,aAAa,EAAE,IAAI,CAACzD,MAAM,CAACyD;YAC7B,CAAC;YACD;UACF,KAAK,OAAO;YACVqL,QAAQ,GAAG;cACT7G,IAAI;cACJrH,QAAQ;cACR0H,QAAQ,EAAE,IAAI1J,YAAY,CAAC,IAAI,CAAC2C,MAAM;YACxC,CAAC;YACD;UACF,KAAK,sBAAsB;YACzBuN,QAAQ,GAAG;cACT7G,IAAI;cACJrH,QAAQ;cACRsI,MAAM,EAAE,SAAAA,CAAA;gBAAA,SAAA8F,IAAA,GAAAC,SAAA,CAAAvL,MAAA,EAAIwL,IAAI,OAAAtL,KAAA,CAAAoL,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;kBAAJD,IAAI,CAAAC,IAAA,IAAAF,SAAA,CAAAE,IAAA;gBAAA;gBAAA,OAAK9M,KAAI,CAAC4D,IAAI,CAAC,sBAAsB,EAAE,GAAGiJ,IAAI,CAAC;cAAA;YACjE,CAAC;YACD;UACF,KAAK,MAAM;YACTJ,QAAQ,GAAG;cAAE7G,IAAI;cAAErH;YAAS,CAAC;YAC7B;UACF;YACE,OAAOmO,QAAQ,CACZ,+CAA8CD,QAAS,EAAC,CAC1D;QAAC;MAER,CAAC,MAAM,IAAI,OAAOA,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,KAAK,IAAI,EAAE;QAC5D,OAAOC,QAAQ,CACZ,4CAA2CD,QAAS,EAAC,CACvD;MACH,CAAC,MAAM;QACL,MAAMlO,QAAQ,GAAGkO,QAAQ,CAAClO,QAAQ;QAClC,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;UAChC,OAAOmO,QAAQ,CACZ,4CAA2CD,QAAS,EAAC,CACvD;QACH;QACA,MAAM7G,IAAI,GAAG6G,QAAQ,CAAC7G,IAAI;QAC1B,QAAQA,IAAI;UACV,KAAK,UAAU;YAAE;cACf,MAAM;gBAAEpH;cAAS,CAAC,GAAGiO,QAAQ;cAC7B,IAAI,OAAOjO,QAAQ,KAAK,QAAQ,IAAI,CAAC4B,MAAM,CAACC,QAAQ,CAAC7B,QAAQ,CAAC,EAC5D,OAAOkO,QAAQ,CAAC,wCAAwC,CAAC;cAC3DD,QAAQ,GAAG;gBAAE7G,IAAI;gBAAErH,QAAQ;gBAAEC;cAAS,CAAC;cACvC;YACF;UACA,KAAK,WAAW;YAAE;cAChB,MAAM0D,GAAG,GAAGnG,QAAQ,CAAC0Q,QAAQ,CAACvK,GAAG,EAAEuK,QAAQ,CAAC/K,UAAU,CAAC;cACvD,IAAIQ,GAAG,YAAYhB,KAAK,EACtB,OAAOwL,QAAQ,CAAC,mCAAmC,CAAC;cACtD,IAAI,CAACxK,GAAG,CAAC6K,YAAY,EAAE,EACrB,OAAOL,QAAQ,CAAC,0BAA0B,CAAC;cAC7CD,QAAQ,GAAG;gBAAE7G,IAAI;gBAAErH,QAAQ;gBAAE2D;cAAI,CAAC;cAClC;YACF;UACA,KAAK,WAAW;YAAE;cAChB,MAAM;gBAAEf,aAAa;gBAAEC;cAAc,CAAC,GAAGqL,QAAQ;cACjD,MAAMvK,GAAG,GAAGnG,QAAQ,CAAC0Q,QAAQ,CAACvK,GAAG,EAAEuK,QAAQ,CAAC/K,UAAU,CAAC;cACvD,IAAIQ,GAAG,YAAYhB,KAAK,IACjB,OAAOC,aAAa,KAAK,QAAQ,IACjC,OAAOC,aAAa,KAAK,QAAQ,EAAE;gBACxC,OAAOsL,QAAQ,CAAC,yCAAyC,CAAC;cAC5D;cACA,IAAI,CAACxK,GAAG,CAAC6K,YAAY,EAAE,EACrB,OAAOL,QAAQ,CAAC,0BAA0B,CAAC;cAC7CD,QAAQ,GAAG;gBAAE7G,IAAI;gBAAErH,QAAQ;gBAAE2D,GAAG;gBAAEf,aAAa;gBAAEC;cAAc,CAAC;cAChE;YACF;UACA,KAAK,OAAO;YAAE;cACZ,IAAIzC,KAAK,GAAG8N,QAAQ,CAAC9N,KAAK;cAC1B,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,CAAC0C,MAAM,EAAE;gBAC7C1C,KAAK,GAAGnC,WAAW,CAACmC,KAAK,CAAC;cAC5B,CAAC,MAAM,IAAI,CAAClC,OAAO,CAACkC,KAAK,CAAC,EAAE;gBAC1B,OAAO+N,QAAQ,CACZ,2BAA0BD,QAAQ,CAAC9N,KAAM,EAAC,CAC5C;cACH;cACA8N,QAAQ,GAAG;gBAAE7G,IAAI;gBAAErH,QAAQ;gBAAE0H,QAAQ,EAAE,IAAI1J,YAAY,CAACoC,KAAK;cAAE,CAAC;cAChE;YACF;UACA,KAAK,sBAAsB;YAAE;cAC3B,MAAM;gBAAEkI;cAAO,CAAC,GAAG4F,QAAQ;cAC3B,IAAI,OAAO5F,MAAM,KAAK,UAAU,EAAE;gBAChC,OAAO6F,QAAQ,CACb,oDAAoD,CACrD;cACH;cACAD,QAAQ,GAAG;gBAAE7G,IAAI;gBAAErH,QAAQ;gBAAEsI;cAAO,CAAC;cACrC;YACF;UACA,KAAK,MAAM;YACT4F,QAAQ,GAAG;cAAE7G,IAAI;cAAErH;YAAS,CAAC;YAC7B;UACF;YACE,OAAOmO,QAAQ,CACZ,+CAA8CD,QAAS,EAAC,CAC1D;QAAC;MAER;MACAhH,OAAO,GAAGgH,QAAQ;;MAElB;MACA,IAAI;QACF,MAAMlO,QAAQ,GAAGkH,OAAO,CAAClH,QAAQ;QACjC,QAAQkH,OAAO,CAACG,IAAI;UAClB,KAAK,UAAU;YACb1C,KAAK,CAAC6D,YAAY,CAACxI,QAAQ,EAAEkH,OAAO,CAACjH,QAAQ,CAAC;YAC9C;UACF,KAAK,WAAW;YAAE;cAChB,IAAIsH,OAAO;cACXL,OAAO,CAACC,QAAQ,GAAGsH,WAAW,CAAC,IAAI,EAAEvH,OAAO,CAACvD,GAAG,EAAEe,aAAa,CAAC;cAChE,IAAIwC,OAAO,CAACC,QAAQ,EAAE;gBACpB,IAAID,OAAO,CAACC,QAAQ,CAACrE,MAAM,EAAE;kBAC3ByE,OAAO,GAAGL,OAAO,CAACC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAClC,CAAC,MAAM;kBACL,OAAOgH,QAAQ,CACb,wDAAwD,CACzD;gBACH;cACF;cACAxJ,KAAK,CAAC8C,MAAM,CAACzH,QAAQ,EAAEkH,OAAO,CAACvD,GAAG,EAAE4D,OAAO,CAAC;cAC5C;YACF;UACA,KAAK,WAAW;YAAE;cAChB,IAAIA,OAAO;cACX,IAAIC,QAAQ;cACZN,OAAO,CAACC,QAAQ,GAAGsH,WAAW,CAAC,IAAI,EAAEvH,OAAO,CAACvD,GAAG,EAAEe,aAAa,CAAC;cAChE,IAAIwC,OAAO,CAACC,QAAQ,EAAE;gBACpB,IAAID,OAAO,CAACC,QAAQ,CAACrE,MAAM,EAAE;kBAC3B,CAACyE,OAAO,EAAEC,QAAQ,CAAC,GAAGN,OAAO,CAACC,QAAQ,CAAC,CAAC,CAAC;gBAC3C,CAAC,MAAM;kBACL,OAAOgH,QAAQ,CACb,8DAA8D,CAC/D;gBACH;cACF;cAEAxJ,KAAK,CAACiD,aAAa,CAAC5H,QAAQ,EACRkH,OAAO,CAACvD,GAAG,EACXuD,OAAO,CAACtE,aAAa,EACrBsE,OAAO,CAACrE,aAAa,EACrB0E,OAAO,EACP,CAACM,GAAG,EAAEC,EAAE,KAAK;gBAC/B,MAAMC,SAAS,GAAGb,OAAO,CAACvD,GAAG,CAACqE,IAAI,CAACH,GAAG,EAAEL,QAAQ,CAAC;gBACjD,IAAIO,SAAS,YAAYpF,KAAK,EAAE;kBAC9BoF,SAAS,CAAC3E,OAAO,GACd,iCAAgC2E,SAAS,CAAC3E,OAAQ,EAAC;kBACtD2E,SAAS,CAAC9C,KAAK,GAAG,uBAAuB;kBACzC,IAAI,CAACI,IAAI,CAAC,OAAO,EAAE0C,SAAS,CAAC;kBAC7B,OAAOxB,WAAW,EAAE;gBACtB;gBAEAuB,EAAE,CAACC,SAAS,CAAC;cACf,CAAC,CAAC;cACF;YACF;UACA,KAAK,OAAO;YACVb,OAAO,CAACQ,QAAQ,CAACrK,IAAI,CAAE4B,GAAG,IAAK;cAC7B,IAAIA,GAAG,EAAE;gBACPA,GAAG,CAACgG,KAAK,GAAG,OAAO;gBACnB,IAAI,CAACI,IAAI,CAAC,OAAO,EAAEpG,GAAG,CAAC;gBACvB,OAAOsH,WAAW,EAAE;cACtB;cACA2B,eAAe,EAAE;YACnB,CAAC,CAAC;YACF;UACF,KAAK,sBAAsB;YACzBvD,KAAK,CAAC+J,YAAY,CAAC1O,QAAQ,CAAC;YAC5B;UACF,KAAK,MAAM;YACT2E,KAAK,CAACgK,QAAQ,CAAC3O,QAAQ,CAAC;YACxB;QAAM;MAEZ,CAAC,SAAS;QACRgO,WAAW,GAAG,KAAK;MACrB;IACF,CAAC;IAED,SAASG,QAAQA,CAAC5J,GAAG,EAAE;MACrB7D,KAAK,IAAIA,KAAK,CAAC6D,GAAG,CAAC;MACnBqK,OAAO,CAACC,QAAQ,CAACtI,WAAW,CAAC;IAC/B;IAEA,SAASA,WAAWA,CAAA,EAAG;MACrByH,WAAW,GAAG,KAAK;MACnB,MAAMc,IAAI,GAAGxO,WAAW,CAAC8H,YAAY,EAAED,UAAU,EAAE8F,UAAU,CAAC;MAC9D,IAAID,WAAW,IAAIc,IAAI,KAAKxP,SAAS,EACnC;MACF2O,UAAU,CAACa,IAAI,CAAC;IAClB;IAEA,MAAM5G,eAAe,GAAGA,CAAA,KAAM;MAC5B,IAAIhB,OAAO,CAACG,IAAI,KAAK,OAAO,EAAE;QAC5B,MAAM1D,GAAG,GAAGuD,OAAO,CAACQ,QAAQ,CAACqH,OAAO,EAAE;QACtC,IAAIpL,GAAG,KAAK,KAAK,EAAE;UACjBjD,KAAK,IAAIA,KAAK,CAAC,iCAAiC,CAAC;UACjDA,KAAK,IAAIA,KAAK,CAAC,2BAA2B,CAAC;UAC3C6F,WAAW,EAAE;QACf,CAAC,MAAM;UACL,MAAM0B,GAAG,GAAGf,OAAO,CAACQ,QAAQ,CAACO,GAAG,EAAE;UAClC,IAAIV,OAAO;UACXL,OAAO,CAACC,QAAQ,GAAGsH,WAAW,CAAC,IAAI,EAAE9K,GAAG,EAAEe,aAAa,CAAC;UACxD,IAAIwC,OAAO,CAACC,QAAQ,EAAE;YACpB,IAAID,OAAO,CAACC,QAAQ,CAACrE,MAAM,EAAE;cAC3ByE,OAAO,GAAGL,OAAO,CAACC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAClC,CAAC,MAAM;cACLzG,KAAK,IAAIA,KAAK,CACX,wBAAuBuH,GAAG,GAAG,CAAE,6BAA4B,CAC7D;cACDC,eAAe,EAAE;cACjB;YACF;UACF;UACAxH,KAAK,IAAIA,KAAK,CAAE,sBAAqBuH,GAAG,GAAG,CAAE,EAAC,CAAC;UAC/CtD,KAAK,CAAC8C,MAAM,CAACP,OAAO,CAAClH,QAAQ,EAAE2D,GAAG,EAAE4D,OAAO,CAAC;QAC9C;MACF;IACF,CAAC;IAED,MAAMyH,YAAY,GAAGA,CAAA,KAAM;MACzB,IAAI,IAAI,CAAC5P,MAAM,CAACU,YAAY,GAAG,CAAC,EAAE;QAChC,IAAI,CAACc,aAAa,GAAGqO,UAAU,CAAC,MAAM;UACpC,MAAMhQ,GAAG,GAAG,IAAI0D,KAAK,CAAC,uCAAuC,CAAC;UAC9D1D,GAAG,CAACgG,KAAK,GAAG,gBAAgB;UAC5B,IAAI,CAACI,IAAI,CAAC,OAAO,EAAEpG,GAAG,CAAC;UACvB+E,IAAI,CAAC8I,OAAO,EAAE;QAChB,CAAC,EAAE,IAAI,CAAC1N,MAAM,CAACU,YAAY,CAAC;MAC9B;IACF,CAAC;IAED,IAAI,CAAC0B,GAAG,CAACwC,IAAI,EAAE;MACb,IAAI3E,IAAI,GAAG,IAAI,CAACD,MAAM,CAACC,IAAI;MAC3B,MAAMK,SAAS,GAAG,IAAI,CAACN,MAAM,CAACM,SAAS;MACvC,MAAMC,SAAS,GAAG,IAAI,CAACP,MAAM,CAACO,SAAS;MAEvCe,KAAK,IAAIA,KAAK,CAAE,kBAAiBrB,IAAK,YAAW,IAAI,CAACD,MAAM,CAACG,IAAK,MAAK,CAAC;MAExE,MAAM2P,SAAS,GAAGA,CAAA,KAAM;QACtBF,YAAY,EAAE;QACdhL,IAAI,CAACzC,OAAO,CAAC;UACXlC,IAAI;UACJE,IAAI,EAAE,IAAI,CAACH,MAAM,CAACG,IAAI;UACtBC,YAAY,EAAE,IAAI,CAACJ,MAAM,CAACI,YAAY;UACtCC,SAAS,EAAE,IAAI,CAACL,MAAM,CAACK;QACzB,CAAC,CAAC;QACFuE,IAAI,CAACmL,eAAe,CAAC,CAAC,CAAC;QACvBnL,IAAI,CAACiL,UAAU,CAAC,OAAOzN,GAAG,CAAC4N,OAAO,KAAK,QAAQ,GAAG5N,GAAG,CAAC4N,OAAO,GAAG,CAAC,CAAC;MACpE,CAAC;MAED,IAAK,CAAC1P,SAAS,IAAI,CAACC,SAAS,IAAMD,SAAS,IAAIC,SAAU,EAAE;QAC1DuP,SAAS,EAAE;MACb,CAAC,MAAM;QACLhT,SAAS,CAACmD,IAAI,EAAGK,SAAS,GAAG,CAAC,GAAG,CAAC,EAAG,CAACT,GAAG,EAAEoQ,OAAO,EAAEC,MAAM,KAAK;UAC7D,IAAIrQ,GAAG,EAAE;YACP,MAAMoI,IAAI,GAAI3H,SAAS,GAAG,MAAM,GAAG,MAAO;YAC1C,MAAM6P,KAAK,GAAG,IAAI5M,KAAK,CACpB,0BAAyB0E,IAAK,iBAAgBhI,IAAK,MAAKJ,GAAI,EAAC,CAC/D;YACDiG,YAAY,CAAC,IAAI,CAACtE,aAAa,CAAC;YAChC2O,KAAK,CAACtK,KAAK,GAAG,YAAY;YAC1B,IAAI,CAACI,IAAI,CAAC,OAAO,EAAEkK,KAAK,CAAC;YACzB,IAAI,CAAClK,IAAI,CAAC,OAAO,CAAC;YAClB;UACF;UACAhG,IAAI,GAAGgQ,OAAO;UACdH,SAAS,EAAE;QACb,CAAC,CAAC;MACJ;IACF,CAAC,MAAM;MACL;MACAF,YAAY,EAAE;MACd,IAAI,OAAOhL,IAAI,CAACwL,UAAU,KAAK,SAAS,EAAE;QACxC;;QAEA,IAAI,CAACxL,IAAI,CAACwL,UAAU,EAAE;UACpB;UACApC,SAAS,EAAE;QACb;MACF,CAAC,MAAM;QACL;QACAA,SAAS,EAAE;MACb;IACF;IAEA,OAAO,IAAI;EACb;EAEAzL,GAAGA,CAAA,EAAG;IACJ,IAAI,IAAI,CAACN,KAAK,IAAI3C,UAAU,CAAC,IAAI,CAAC2C,KAAK,CAAC,EAAE;MACxC,IAAI,CAACD,SAAS,CAACqO,UAAU,CAAC3S,iBAAiB,CAACqJ,cAAc,CAAC;MAC3D,IAAI,CAAC9E,KAAK,CAACM,GAAG,EAAE;IAClB;IACA,OAAO,IAAI;EACb;EAEAmL,OAAOA,CAAA,EAAG;IACR,IAAI,CAACzL,KAAK,IAAI3C,UAAU,CAAC,IAAI,CAAC2C,KAAK,CAAC,IAAI,IAAI,CAACA,KAAK,CAACyL,OAAO,EAAE;IAC5D,OAAO,IAAI;EACb;EAEA4C,IAAIA,CAACC,GAAG,EAAEjH,IAAI,EAAEZ,EAAE,EAAE;IAClB,IAAI,CAAC,IAAI,CAACzG,KAAK,IAAI,CAAC3C,UAAU,CAAC,IAAI,CAAC2C,KAAK,CAAC,EACxC,MAAM,IAAIsB,KAAK,CAAC,eAAe,CAAC;IAElC,IAAI,OAAO+F,IAAI,KAAK,UAAU,EAAE;MAC9BZ,EAAE,GAAGY,IAAI;MACTA,IAAI,GAAG,CAAC,CAAC;IACX;IAEA,MAAMkH,SAAS,GAAG;MAAEC,aAAa,EAAGnH,IAAI,CAACmH,aAAa,KAAK;IAAO,CAAC;IAEnEC,WAAW,CAAC,IAAI,EAAE,SAAS,EAAEF,SAAS,EAAE,CAAC3Q,GAAG,EAAE8Q,IAAI,KAAK;MACrD,IAAI9Q,GAAG,EAAE;QACP6I,EAAE,CAAC7I,GAAG,CAAC;QACP;MACF;MAEA,MAAM+Q,IAAI,GAAG,EAAE;MAEf,SAASC,KAAKA,CAAChR,GAAG,EAAE;QAClB,IAAIA,GAAG,EAAE;UACP8Q,IAAI,CAACG,KAAK,EAAE;UACZpI,EAAE,CAAC7I,GAAG,CAAC;UACP;QACF;QACA,IAAI+Q,IAAI,CAAClN,MAAM,EACbkN,IAAI,CAAC1I,KAAK,EAAE,EAAE;MAClB;MAEA,IAAI,IAAI,CAAClI,MAAM,CAACiB,aAAa,KAAK,IAAI,IAC9BqI,IAAI,IACDA,IAAI,CAAC3F,YAAY,KAAK,IAAI,IAC1B,IAAI,CAACpC,MAAM,KAAKrB,SAAU,EAAE;QACrC0Q,IAAI,CAAClF,IAAI,CAAC,MAAMqF,WAAW,CAACJ,IAAI,EAAEE,KAAK,CAAC,CAAC;MAC3C;MAEA,IAAI,OAAOvH,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,IAAI,EAAE;QAC7C,IAAI,OAAOA,IAAI,CAAC0H,GAAG,KAAK,QAAQ,IAAI1H,IAAI,CAAC0H,GAAG,KAAK,IAAI,EACnDC,MAAM,CAACN,IAAI,EAAErH,IAAI,CAAC0H,GAAG,CAAC;QACxB,IAAK,OAAO1H,IAAI,CAAC4H,GAAG,KAAK,QAAQ,IAAI5H,IAAI,CAAC4H,GAAG,KAAK,IAAI,IAC/C5H,IAAI,CAAC4H,GAAG,KAAK,IAAI,EAAE;UACxBN,IAAI,CAAClF,IAAI,CAAC,MAAMyF,MAAM,CAACR,IAAI,EAAErH,IAAI,CAAC4H,GAAG,EAAEL,KAAK,CAAC,CAAC;QAChD;QACA,IAAK,OAAOvH,IAAI,CAAC8H,GAAG,KAAK,QAAQ,IAAI9H,IAAI,CAAC8H,GAAG,KAAK,IAAI,IAC/C9H,IAAI,CAAC8H,GAAG,KAAK,QAAQ,IACrB9H,IAAI,CAAC8H,GAAG,KAAK,IAAI,EAAE;UACxBR,IAAI,CAAClF,IAAI,CAAC,MAAM2F,MAAM,CAACV,IAAI,EAAErH,IAAI,CAAC8H,GAAG,EAAEP,KAAK,CAAC,CAAC;QAChD;MACF;MAEAD,IAAI,CAAClF,IAAI,CAAC,MAAM4F,OAAO,CAACX,IAAI,EAAEJ,GAAG,EAAEjH,IAAI,EAAEZ,EAAE,CAAC,CAAC;MAC7CkI,IAAI,CAAC1I,KAAK,EAAE,EAAE;IAChB,CAAC,CAAC;IAEF,OAAO,IAAI;EACb;EAEAqJ,KAAKA,CAACC,OAAO,EAAElI,IAAI,EAAEZ,EAAE,EAAE;IACvB,IAAI,CAAC,IAAI,CAACzG,KAAK,IAAI,CAAC3C,UAAU,CAAC,IAAI,CAAC2C,KAAK,CAAC,EACxC,MAAM,IAAIsB,KAAK,CAAC,eAAe,CAAC;IAElC,IAAI,OAAOiO,OAAO,KAAK,UAAU,EAAE;MACjC9I,EAAE,GAAG8I,OAAO;MACZA,OAAO,GAAGlI,IAAI,GAAGpJ,SAAS;IAC5B,CAAC,MAAM,IAAI,OAAOoJ,IAAI,KAAK,UAAU,EAAE;MACrCZ,EAAE,GAAGY,IAAI;MACTA,IAAI,GAAGpJ,SAAS;IAClB;IACA,IAAIsR,OAAO,KAAKA,OAAO,CAACJ,GAAG,KAAKlR,SAAS,IAAIsR,OAAO,CAACR,GAAG,KAAK9Q,SAAS,CAAC,EAAE;MACvEoJ,IAAI,GAAGkI,OAAO;MACdA,OAAO,GAAGtR,SAAS;IACrB;IAEAwQ,WAAW,CAAC,IAAI,EAAE,SAAS,EAAE,CAAC7Q,GAAG,EAAE8Q,IAAI,KAAK;MAC1C,IAAI9Q,GAAG,EAAE;QACP6I,EAAE,CAAC7I,GAAG,CAAC;QACP;MACF;MAEA,MAAM+Q,IAAI,GAAG,EAAE;MAEf,SAASC,KAAKA,CAAChR,GAAG,EAAE;QAClB,IAAIA,GAAG,EAAE;UACP8Q,IAAI,CAACG,KAAK,EAAE;UACZpI,EAAE,CAAC7I,GAAG,CAAC;UACP;QACF;QACA,IAAI+Q,IAAI,CAAClN,MAAM,EACbkN,IAAI,CAAC1I,KAAK,EAAE,EAAE;MAClB;MAEA,IAAI,IAAI,CAAClI,MAAM,CAACiB,aAAa,KAAK,IAAI,IAC9BqI,IAAI,IACDA,IAAI,CAAC3F,YAAY,KAAK,IAAI,IAC1B,IAAI,CAACpC,MAAM,KAAKrB,SAAU,EAAE;QACrC0Q,IAAI,CAAClF,IAAI,CAAC,MAAMqF,WAAW,CAACJ,IAAI,EAAEE,KAAK,CAAC,CAAC;MAC3C;MAEA,IAAIW,OAAO,KAAK,KAAK,EACnBZ,IAAI,CAAClF,IAAI,CAAC,MAAMyF,MAAM,CAACR,IAAI,EAAEa,OAAO,EAAEX,KAAK,CAAC,CAAC;MAE/C,IAAI,OAAOvH,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,IAAI,EAAE;QAC7C,IAAI,OAAOA,IAAI,CAAC0H,GAAG,KAAK,QAAQ,IAAI1H,IAAI,CAAC0H,GAAG,KAAK,IAAI,EACnDC,MAAM,CAACN,IAAI,EAAErH,IAAI,CAAC0H,GAAG,CAAC;QACxB,IAAK,OAAO1H,IAAI,CAAC8H,GAAG,KAAK,QAAQ,IAAI9H,IAAI,CAAC8H,GAAG,KAAK,IAAI,IAC/C9H,IAAI,CAAC8H,GAAG,KAAK,QAAQ,IACrB9H,IAAI,CAAC8H,GAAG,KAAK,IAAI,EAAE;UACxBR,IAAI,CAAClF,IAAI,CAAC,MAAM2F,MAAM,CAACV,IAAI,EAAErH,IAAI,CAAC8H,GAAG,EAAEP,KAAK,CAAC,CAAC;QAChD;MACF;MAEAD,IAAI,CAAClF,IAAI,CAAC,MAAM+F,QAAQ,CAACd,IAAI,EAAEjI,EAAE,CAAC,CAAC;MACnCkI,IAAI,CAAC1I,KAAK,EAAE,EAAE;IAChB,CAAC,CAAC;IAEF,OAAO,IAAI;EACb;EAEAwJ,MAAMA,CAACxK,IAAI,EAAEwB,EAAE,EAAE;IACf,IAAI,CAAC,IAAI,CAACzG,KAAK,IAAI,CAAC3C,UAAU,CAAC,IAAI,CAAC2C,KAAK,CAAC,EACxC,MAAM,IAAIsB,KAAK,CAAC,eAAe,CAAC;IAElCmN,WAAW,CAAC,IAAI,EAAE,SAAS,EAAE,CAAC7Q,GAAG,EAAE8Q,IAAI,KAAK;MAC1C,IAAI9Q,GAAG,EAAE;QACP6I,EAAE,CAAC7I,GAAG,CAAC;QACP;MACF;MAEA8R,YAAY,CAAChB,IAAI,EAAEzJ,IAAI,EAAE,CAACrH,GAAG,EAAE+R,MAAM,KAAK;QACxC,IAAI/R,GAAG,EAAE;UACP6I,EAAE,CAAC7I,GAAG,CAAC;UACP;QACF;QAEA6I,EAAE,CAACxI,SAAS,EAAE0R,MAAM,CAAC;MACvB,CAAC,CAAC;IACJ,CAAC,CAAC;IAEF,OAAO,IAAI;EACb;EAEAC,SAASA,CAACC,QAAQ,EAAEC,QAAQ,EAAErJ,EAAE,EAAE;IAChC,IAAI,CAAC,IAAI,CAACzG,KAAK,IAAI,CAAC3C,UAAU,CAAC,IAAI,CAAC2C,KAAK,CAAC,EACxC,MAAM,IAAIsB,KAAK,CAAC,eAAe,CAAC;;IAElC;IACA;;IAEA,MAAM2G,SAAS,GAAI,OAAOxB,EAAE,KAAK,UAAW;IAE5C,IAAIwB,SAAS,EAAE;MACb,IAAI,CAACxI,UAAU,CAACgK,IAAI,CAAC,CAACsG,OAAO,EAAEtM,IAAI,KAAK;QACtC,IAAIsM,OAAO,EAAE;UACXtJ,EAAE,CAACsJ,OAAO,KAAK,IAAI,GACdA,OAAO,GACP,IAAIzO,KAAK,CAAE,qBAAoBuO,QAAS,IAAGC,QAAS,EAAC,CAAC,CAAC;UAC5D;QACF;QAEA,IAAIE,QAAQ,GAAGF,QAAQ;QACvB,IAAIA,QAAQ,KAAK,CAAC,IAAIrM,IAAI,IAAIA,IAAI,CAAChC,MAAM,IAAI,CAAC,EAAE;UAC9CuO,QAAQ,GAAGxT,YAAY,CAACiH,IAAI,EAAE,CAAC,CAAC;UAChC,IAAI,EAAE,IAAI,CAAC1D,SAAS,CAACkQ,YAAY,GAAGjV,MAAM,CAACkV,aAAa,CAAC,EACvDJ,QAAQ,GAAGE,QAAQ;QACvB;QAEA,IAAI,CAACtQ,WAAW,CAAE,GAAEmQ,QAAS,IAAGC,QAAS,EAAC,CAAC,GAAGE,QAAQ;QAEtDvJ,EAAE,CAACxI,SAAS,EAAE+R,QAAQ,CAAC;MACzB,CAAC,CAAC;IACJ;IAEA,IAAI,CAACjQ,SAAS,CAACoQ,YAAY,CAACN,QAAQ,EAAEC,QAAQ,EAAE7H,SAAS,CAAC;IAE1D,OAAO,IAAI;EACb;EAEAmI,WAAWA,CAACP,QAAQ,EAAEC,QAAQ,EAAErJ,EAAE,EAAE;IAClC,IAAI,CAAC,IAAI,CAACzG,KAAK,IAAI,CAAC3C,UAAU,CAAC,IAAI,CAAC2C,KAAK,CAAC,EACxC,MAAM,IAAIsB,KAAK,CAAC,eAAe,CAAC;;IAElC;IACA;;IAEA,MAAM2G,SAAS,GAAI,OAAOxB,EAAE,KAAK,UAAW;IAE5C,IAAIwB,SAAS,EAAE;MACb,IAAI,CAACxI,UAAU,CAACgK,IAAI,CAAEsG,OAAO,IAAK;QAChC,IAAIA,OAAO,EAAE;UACXtJ,EAAE,CAACsJ,OAAO,KAAK,IAAI,GACdA,OAAO,GACP,IAAIzO,KAAK,CAAE,yBAAwBuO,QAAS,IAAGC,QAAS,EAAC,CAAC,CAAC;UAChE;QACF;QAEA,OAAO,IAAI,CAACpQ,WAAW,CAAE,GAAEmQ,QAAS,IAAGC,QAAS,EAAC,CAAC;QAElDrJ,EAAE,EAAE;MACN,CAAC,CAAC;IACJ;IAEA,IAAI,CAAC1G,SAAS,CAACsQ,kBAAkB,CAACR,QAAQ,EAAEC,QAAQ,EAAE7H,SAAS,CAAC;IAEhE,OAAO,IAAI;EACb;EAEAqI,UAAUA,CAACC,KAAK,EAAEC,OAAO,EAAEC,KAAK,EAAEC,OAAO,EAAEjK,EAAE,EAAE;IAC7C,IAAI,CAAC,IAAI,CAACzG,KAAK,IAAI,CAAC3C,UAAU,CAAC,IAAI,CAAC2C,KAAK,CAAC,EACxC,MAAM,IAAIsB,KAAK,CAAC,eAAe,CAAC;;IAElC;;IAEA,MAAMnB,GAAG,GAAG;MACVoQ,KAAK,EAAEA,KAAK;MACZC,OAAO,EAAEA,OAAO;MAChBC,KAAK,EAAEA,KAAK;MACZC,OAAO,EAAEA;IACX,CAAC;IAED,IAAI,OAAOjK,EAAE,KAAK,UAAU,EAC1BA,EAAE,GAAG9I,IAAI;IAEX8Q,WAAW,CAAC,IAAI,EAAE,cAAc,EAAEtO,GAAG,EAAEsG,EAAE,CAAC;IAE1C,OAAO,IAAI;EACb;EAEAkK,sBAAsBA,CAAClK,EAAE,EAAE;IACzB,IAAI,CAAC,IAAI,CAACzG,KAAK,IAAI,CAAC3C,UAAU,CAAC,IAAI,CAAC2C,KAAK,CAAC,EACxC,MAAM,IAAIsB,KAAK,CAAC,eAAe,CAAC;IAElC,MAAM2G,SAAS,GAAI,OAAOxB,EAAE,KAAK,UAAW;IAE5C,IAAI,CAAC,IAAI,CAAC1I,MAAM,CAACqB,YAAY,IACrB,IAAI,CAACrB,MAAM,CAACqB,YAAY,IAAI1B,UAAU,CAACkT,IAAI,CAAC,IAAI,CAAC9Q,UAAU,CAAE,EAAE;MACrE,IAAImI,SAAS,EAAE;QACb,IAAI,CAACxI,UAAU,CAACgK,IAAI,CAAEsG,OAAO,IAAK;UAChC,IAAIA,OAAO,EAAE;YACXtJ,EAAE,CAACsJ,OAAO,KAAK,IAAI,GACdA,OAAO,GACP,IAAIzO,KAAK,CAAC,mCAAmC,CAAC,CAAC;YACpD;UACF;UAEAmF,EAAE,EAAE;QACN,CAAC,CAAC;MACJ;MAEA,IAAI,CAAC1G,SAAS,CAAC4Q,sBAAsB,CAAC1I,SAAS,CAAC;MAChD,OAAO,IAAI;IACb;IAEA,IAAI,CAACA,SAAS,EACZ,OAAO,IAAI;IAEbsF,OAAO,CAACC,QAAQ,CACd/G,EAAE,EACF,IAAInF,KAAK,CACP,sEAAsE,CACvE,CACF;IAED,OAAO,IAAI;EACb;EAEAuP,4BAA4BA,CAACC,UAAU,EAAErK,EAAE,EAAE;IAC3C,IAAI,CAAC,IAAI,CAACzG,KAAK,IAAI,CAAC3C,UAAU,CAAC,IAAI,CAAC2C,KAAK,CAAC,EACxC,MAAM,IAAIsB,KAAK,CAAC,eAAe,CAAC;IAElC,MAAM2G,SAAS,GAAI,OAAOxB,EAAE,KAAK,UAAW;IAE5C,IAAI,CAAC,IAAI,CAAC1I,MAAM,CAACqB,YAAY,IACrB,IAAI,CAACrB,MAAM,CAACqB,YAAY,IAAI1B,UAAU,CAACkT,IAAI,CAAC,IAAI,CAAC9Q,UAAU,CAAE,EAAE;MACrE,IAAImI,SAAS,EAAE;QACb,IAAI,CAACxI,UAAU,CAACgK,IAAI,CAAEsG,OAAO,IAAK;UAChC,IAAIA,OAAO,EAAE;YACXtJ,EAAE,CAACsJ,OAAO,KAAK,IAAI,GACdA,OAAO,GACP,IAAIzO,KAAK,CAAE,qBAAoBwP,UAAW,EAAC,CAAC,CAAC;YAClD;UACF;UACA,IAAI,CAACnR,eAAe,CAACmR,UAAU,CAAC,GAAG,IAAI;UACvCrK,EAAE,EAAE;QACN,CAAC,CAAC;MACJ;MAEA,IAAI,CAAC1G,SAAS,CAACgR,0BAA0B,CAACD,UAAU,EAAE7I,SAAS,CAAC;MAChE,OAAO,IAAI;IACb;IAEA,IAAI,CAACA,SAAS,EACZ,OAAO,IAAI;IAEbsF,OAAO,CAACC,QAAQ,CACd/G,EAAE,EACF,IAAInF,KAAK,CACP,sEAAsE,CACvE,CACF;IAED,OAAO,IAAI;EACb;EAEA0P,8BAA8BA,CAACF,UAAU,EAAErK,EAAE,EAAE;IAC7C,IAAI,CAAC,IAAI,CAACzG,KAAK,IAAI,CAAC3C,UAAU,CAAC,IAAI,CAAC2C,KAAK,CAAC,EACxC,MAAM,IAAIsB,KAAK,CAAC,eAAe,CAAC;IAElC,MAAM2G,SAAS,GAAI,OAAOxB,EAAE,KAAK,UAAW;IAE5C,IAAI,CAAC,IAAI,CAAC1I,MAAM,CAACqB,YAAY,IACrB,IAAI,CAACrB,MAAM,CAACqB,YAAY,IAAI1B,UAAU,CAACkT,IAAI,CAAC,IAAI,CAAC9Q,UAAU,CAAE,EAAE;MACrE,IAAImI,SAAS,EAAE;QACb,IAAI,CAACxI,UAAU,CAACgK,IAAI,CAAEsG,OAAO,IAAK;UAChC,IAAIA,OAAO,EAAE;YACXtJ,EAAE,CAACsJ,OAAO,KAAK,IAAI,GACdA,OAAO,GACP,IAAIzO,KAAK,CAAE,yBAAwBwP,UAAW,EAAC,CAAC,CAAC;YACtD;UACF;UACA,OAAO,IAAI,CAACnR,eAAe,CAACmR,UAAU,CAAC;UACvCrK,EAAE,EAAE;QACN,CAAC,CAAC;MACJ;MAEA,IAAI,CAAC1G,SAAS,CAACkR,gCAAgC,CAACH,UAAU,EAAE7I,SAAS,CAAC;MACtE,OAAO,IAAI;IACb;IAEA,IAAI,CAACA,SAAS,EACZ,OAAO,IAAI;IAEbsF,OAAO,CAACC,QAAQ,CACd/G,EAAE,EACF,IAAInF,KAAK,CACP,sEAAsE,CACvE,CACF;IAED,OAAO,IAAI;EACb;EAEA4P,6BAA6BA,CAACJ,UAAU,EAAErK,EAAE,EAAE;IAC5C,IAAI,CAAC,IAAI,CAACzG,KAAK,IAAI,CAAC3C,UAAU,CAAC,IAAI,CAAC2C,KAAK,CAAC,EACxC,MAAM,IAAIsB,KAAK,CAAC,eAAe,CAAC;IAElC,IAAI,OAAOmF,EAAE,KAAK,UAAU,EAC1BA,EAAE,GAAG9I,IAAI;IAEX,IAAI,CAAC,IAAI,CAACI,MAAM,CAACqB,YAAY,IACrB,IAAI,CAACrB,MAAM,CAACqB,YAAY,IAAI1B,UAAU,CAACkT,IAAI,CAAC,IAAI,CAAC9Q,UAAU,CAAE,EAAE;MACrE2O,WAAW,CAAC,IAAI,EAAE,gCAAgC,EAAE;QAAEqC;MAAW,CAAC,EAAErK,EAAE,CAAC;MACvE,OAAO,IAAI;IACb;IACA8G,OAAO,CAACC,QAAQ,CACd/G,EAAE,EACF,IAAInF,KAAK,CACP,sEAAsE,CACvE,CACF;IAED,OAAO,IAAI;EACb;EAEA6P,IAAIA,CAAC1K,EAAE,EAAE;IACP,IAAI,CAAC,IAAI,CAACzG,KAAK,IAAI,CAAC3C,UAAU,CAAC,IAAI,CAAC2C,KAAK,CAAC,EACxC,MAAM,IAAIsB,KAAK,CAAC,eAAe,CAAC;IAElCmN,WAAW,CAAC,IAAI,EAAE,MAAM,EAAE,CAAC7Q,GAAG,EAAEuT,IAAI,KAAK;MACvC,IAAIvT,GAAG,EAAE;QACP6I,EAAE,CAAC7I,GAAG,CAAC;QACP;MACF;MAEA8R,YAAY,CAACyB,IAAI,EAAE,MAAM,EAAE,CAACvT,GAAG,EAAEwT,KAAK,KAAK;QACzC,IAAIxT,GAAG,EAAE;UACP6I,EAAE,CAAC7I,GAAG,CAAC;UACP;QACF;QAEA,SAASyT,eAAeA,CAAA,EAAG;UACzBF,IAAI,CAACG,cAAc,CAAC,OAAO,EAAEC,OAAO,CAAC;UACrCJ,IAAI,CAACG,cAAc,CAAC,OAAO,EAAE3N,OAAO,CAAC;UACrCwN,IAAI,CAACG,cAAc,CAAC,MAAM,EAAEE,MAAM,CAAC;UACnCL,IAAI,CAACG,cAAc,CAAC,OAAO,EAAEE,MAAM,CAAC;QACtC;QAEA,SAASD,OAAOA,CAAA,EAAG;UACjB;UACA;UACAF,eAAe,EAAE;UACjB5K,EAAE,CAACxI,SAAS,EAAEkT,IAAI,CAAC;QACrB;QAEA,SAASxN,OAAOA,CAAC/F,GAAG,EAAE;UACpByT,eAAe,EAAE;UACjB5K,EAAE,CAAC7I,GAAG,CAAC;QACT;QAEA,SAAS4T,MAAMA,CAACzM,IAAI,EAAE2F,MAAM,EAAE;UAC5B2G,eAAe,EAAE;UACjB,IAAInO,GAAG;UACP,IAAI,OAAO6B,IAAI,KAAK,QAAQ,EAC1B7B,GAAG,GAAI,sBAAqB6B,IAAK,kCAAiC,CAAC,KAChE,IAAI2F,MAAM,KAAKzM,SAAS,EAC3BiF,GAAG,GAAI,mBAAkBwH,MAAO,kCAAiC,CAAC,KAElExH,GAAG,GAAG,8CAA8C;UACtD,MAAMtF,GAAG,GAAG,IAAI0D,KAAK,CAAC4B,GAAG,CAAC;UAC1BtF,GAAG,CAACmH,IAAI,GAAGA,IAAI;UACfnH,GAAG,CAAC8M,MAAM,GAAGA,MAAM;UACnBjE,EAAE,CAAC7I,GAAG,CAAC;QACT;QAEAuT,IAAI,CAACjF,EAAE,CAAC,OAAO,EAAEqF,OAAO,CAAC,CACpBrF,EAAE,CAAC,OAAO,EAAEvI,OAAO,CAAC,CACpBuI,EAAE,CAAC,MAAM,EAAEsF,MAAM,CAAC,CAClBtF,EAAE,CAAC,OAAO,EAAEsF,MAAM,CAAC;QAExBL,IAAI,CAACM,KAAK,EAAE;MACd,CAAC,CAAC;IACJ,CAAC,CAAC;IAEF,OAAO,IAAI;EACb;EAEAC,UAAUA,CAACC,OAAO,EAAE;IAClB,IAAI,IAAI,CAAC3R,KAAK,IAAI,OAAO,IAAI,CAACA,KAAK,CAAC0R,UAAU,KAAK,UAAU,EAC3D,IAAI,CAAC1R,KAAK,CAAC0R,UAAU,CAACC,OAAO,CAAC;IAEhC,OAAO,IAAI;EACb;AACF;AAEA,SAASlD,WAAWA,CAACmD,IAAI,EAAE5L,IAAI,EAAEqB,IAAI,EAAEZ,EAAE,EAAE;EACzC;EACA;EACA,MAAMoL,UAAU,GAAG9U,UAAU;EAC7B,MAAM+U,SAAS,GAAG9U,WAAW;EAE7B,IAAI,OAAOqK,IAAI,KAAK,UAAU,EAAE;IAC9BZ,EAAE,GAAGY,IAAI;IACTA,IAAI,GAAG,CAAC,CAAC;EACX;EAEA,MAAM0K,OAAO,GAAGA,CAACnU,GAAG,EAAE+R,MAAM,KAAK;IAC/BlJ,EAAE,CAAC7I,GAAG,EAAE+R,MAAM,CAAC;EACjB,CAAC;EACDoC,OAAO,CAAC/L,IAAI,GAAGA,IAAI;EAEnB,MAAMgM,SAAS,GAAGJ,IAAI,CAACpS,QAAQ,CAACyS,GAAG,CAACF,OAAO,CAAC;EAE5C,IAAIC,SAAS,KAAK,CAAC,CAAC,EAAE;IACpBvL,EAAE,CAAC,IAAInF,KAAK,CAAC,4BAA4B,CAAC,CAAC;IAC3C;EACF;EAEA,QAAQ0E,IAAI;IACV,KAAK,SAAS;IACd,KAAK,MAAM;MACT4L,IAAI,CAAC7R,SAAS,CAACmS,OAAO,CAACF,SAAS,EAAEH,UAAU,EAAEC,SAAS,CAAC;MACxD;IACF,KAAK,cAAc;MACjBF,IAAI,CAAC7R,SAAS,CAACoS,WAAW,CAACH,SAAS,EAAEH,UAAU,EAAEC,SAAS,EAAEzK,IAAI,CAAC;MAClE;IACF,KAAK,gCAAgC;MACnCuK,IAAI,CAAC7R,SAAS,CAACqS,yBAAyB,CACtCJ,SAAS,EAAEH,UAAU,EAAEC,SAAS,EAAEzK,IAAI,CACvC;MACD;IACF;MACE,MAAM,IAAI/F,KAAK,CAAE,6BAA4B0E,IAAK,EAAC,CAAC;EAAC;AAE3D;AAEA,SAASoJ,MAAMA,CAACV,IAAI,EAAE2D,MAAM,EAAE5L,EAAE,EAAE;EAChC;EACA,MAAMtG,GAAG,GAAG;IACVmS,MAAM,EAAE,KAAK;IACbC,QAAQ,EAAE,oBAAoB;IAC9BC,MAAM,EAAEvU,SAAS;IACjBoU,MAAM,EAAE;EACV,CAAC;EAED,IAAI,OAAOA,MAAM,KAAK,UAAU,EAAE;IAChC5L,EAAE,GAAG4L,MAAM;EACb,CAAC,MAAM,IAAI,OAAOA,MAAM,KAAK,QAAQ,IAAIA,MAAM,KAAK,IAAI,EAAE;IACxD,IAAI,OAAOA,MAAM,CAACC,MAAM,KAAK,SAAS,EACpCnS,GAAG,CAACmS,MAAM,GAAGD,MAAM,CAACC,MAAM;IAC5B,IAAI,OAAOD,MAAM,CAACA,MAAM,KAAK,QAAQ,EACnClS,GAAG,CAACkS,MAAM,GAAGA,MAAM,CAACA,MAAM;IAC5B,IAAI,OAAOA,MAAM,CAACE,QAAQ,KAAK,QAAQ,EACrCpS,GAAG,CAACoS,QAAQ,GAAGF,MAAM,CAACE,QAAQ;IAChC,IAAI,OAAOF,MAAM,CAACG,MAAM,KAAK,QAAQ,EACnCrS,GAAG,CAACqS,MAAM,GAAGH,MAAM,CAACG,MAAM,CAAC,KACxB,IAAIhS,MAAM,CAACC,QAAQ,CAAC4R,MAAM,CAACG,MAAM,CAAC,EACrCrS,GAAG,CAACqS,MAAM,GAAGH,MAAM,CAACG,MAAM,CAACC,QAAQ,CAAC,CAAC,EAAEJ,MAAM,CAACG,MAAM,CAAC/Q,MAAM,CAAC;EAChE;EACA,IAAItB,GAAG,CAACqS,MAAM,KAAKvU,SAAS,EAC1BkC,GAAG,CAACqS,MAAM,GAAGE,YAAY,EAAE;EAE7B,MAAMzK,SAAS,GAAI,OAAOxB,EAAE,KAAK,UAAW;EAE5C,IAAIiI,IAAI,CAACtF,QAAQ,CAACD,KAAK,KAAK,MAAM,EAAE;IAClC,IAAIlB,SAAS,EACXxB,EAAE,CAAC,IAAInF,KAAK,CAAC,qBAAqB,CAAC,CAAC;IACtC;EACF;EAEA,IAAI2G,SAAS,EAAE;IACbyG,IAAI,CAACjP,UAAU,CAACgK,IAAI,CAAEsG,OAAO,IAAK;MAChC,IAAIA,OAAO,EAAE;QACXtJ,EAAE,CAACsJ,OAAO,KAAK,IAAI,GAAGA,OAAO,GAAG,IAAIzO,KAAK,CAAC,uBAAuB,CAAC,CAAC;QACnE;MACF;MAEAoN,IAAI,CAACiE,OAAO,GAAG,IAAI;MACnB,EAAEjE,IAAI,CAACkE,OAAO,CAAChT,UAAU;MACzB8O,IAAI,CAACrO,IAAI,CAAC,OAAO,EAAE,MAAM;QACvB,IAAIqO,IAAI,CAACkE,OAAO,CAAChT,UAAU,EACzB,EAAE8O,IAAI,CAACkE,OAAO,CAAChT,UAAU;MAC7B,CAAC,CAAC;MAEF6G,EAAE,EAAE;IACN,CAAC,CAAC;EACJ;EAEAiI,IAAI,CAACkE,OAAO,CAAC7S,SAAS,CAAC8S,UAAU,CAACnE,IAAI,CAACtF,QAAQ,CAACJ,EAAE,EAAE7I,GAAG,EAAE8H,SAAS,CAAC;AACrE;AAEA,SAASiH,MAAMA,CAACR,IAAI,EAAErH,IAAI,EAAEZ,EAAE,EAAE;EAC9B,IAAIqM,IAAI,GAAG,EAAE;EACb,IAAIC,IAAI,GAAG,EAAE;EACb,IAAIC,KAAK,GAAG,GAAG;EACf,IAAIC,MAAM,GAAG,GAAG;EAChB,IAAIC,IAAI,GAAG,OAAO;EAClB,IAAIC,KAAK,GAAG,IAAI;EAEhB,IAAI,OAAO9L,IAAI,KAAK,UAAU,EAAE;IAC9BZ,EAAE,GAAGY,IAAI;EACX,CAAC,MAAM,IAAI,OAAOA,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,IAAI,EAAE;IACpD,IAAI,OAAOA,IAAI,CAACyL,IAAI,KAAK,QAAQ,EAC/BA,IAAI,GAAGzL,IAAI,CAACyL,IAAI;IAClB,IAAI,OAAOzL,IAAI,CAAC0L,IAAI,KAAK,QAAQ,EAC/BA,IAAI,GAAG1L,IAAI,CAAC0L,IAAI;IAClB,IAAI,OAAO1L,IAAI,CAAC2L,KAAK,KAAK,QAAQ,EAChCA,KAAK,GAAG3L,IAAI,CAAC2L,KAAK;IACpB,IAAI,OAAO3L,IAAI,CAAC4L,MAAM,KAAK,QAAQ,EACjCA,MAAM,GAAG5L,IAAI,CAAC4L,MAAM;IACtB,IAAI,OAAO5L,IAAI,CAAC6L,IAAI,KAAK,QAAQ,EAC/BA,IAAI,GAAG7L,IAAI,CAAC6L,IAAI;IAClB,IAAI,OAAO7L,IAAI,CAAC8L,KAAK,KAAK,QAAQ,EAChCA,KAAK,GAAG9L,IAAI,CAAC8L,KAAK;EACtB;EAEA,MAAMlL,SAAS,GAAI,OAAOxB,EAAE,KAAK,UAAW;EAE5C,IAAIiI,IAAI,CAACtF,QAAQ,CAACD,KAAK,KAAK,MAAM,EAAE;IAClC,IAAIlB,SAAS,EACXxB,EAAE,CAAC,IAAInF,KAAK,CAAC,qBAAqB,CAAC,CAAC;IACtC;EACF;EAEA,IAAI2G,SAAS,EAAE;IACbyG,IAAI,CAACjP,UAAU,CAACgK,IAAI,CAAEsG,OAAO,IAAK;MAChC,IAAIA,OAAO,EAAE;QACXtJ,EAAE,CAACsJ,OAAO,KAAK,IAAI,GACdA,OAAO,GACP,IAAIzO,KAAK,CAAC,qCAAqC,CAAC,CAAC;QACtD;MACF;MACAmF,EAAE,EAAE;IACN,CAAC,CAAC;EACJ;EAEAiI,IAAI,CAACkE,OAAO,CAAC7S,SAAS,CAACkP,GAAG,CAACP,IAAI,CAACtF,QAAQ,CAACJ,EAAE,EAChB8J,IAAI,EACJC,IAAI,EACJE,MAAM,EACND,KAAK,EACLE,IAAI,EACJC,KAAK,EACLlL,SAAS,CAAC;AACvC;AAEA,SAAS6G,WAAWA,CAACJ,IAAI,EAAEjI,EAAE,EAAE;EAC7B,MAAMwB,SAAS,GAAI,OAAOxB,EAAE,KAAK,UAAW;EAE5C,IAAIiI,IAAI,CAACtF,QAAQ,CAACD,KAAK,KAAK,MAAM,EAAE;IAClClB,SAAS,IAAIxB,EAAE,CAAC,IAAInF,KAAK,CAAC,qBAAqB,CAAC,CAAC;IACjD;EACF;EACA,IAAIoN,IAAI,CAACkE,OAAO,CAAC/S,gBAAgB,EAAE;IACjCoI,SAAS,IAAIxB,EAAE,CAAC,KAAK,CAAC;IACtB;EACF;EAEAiI,IAAI,CAACkE,OAAO,CAAC/S,gBAAgB,GAAG,IAAI;EAEpC6O,IAAI,CAACjP,UAAU,CAACgK,IAAI,CAAEsG,OAAO,IAAK;IAChC,IAAIA,OAAO,EAAE;MACXrB,IAAI,CAACkE,OAAO,CAAC/S,gBAAgB,GAAG,KAAK;MACrC,IAAIoI,SAAS,EAAE;QACbxB,EAAE,CAACsJ,OAAO,KAAK,IAAI,GACdA,OAAO,GACP,IAAIzO,KAAK,CAAC,oCAAoC,CAAC,CAAC;MACvD;MACA;IACF;IAEA,IAAI2G,SAAS,EACXxB,EAAE,EAAE;EACR,CAAC,CAAC;EAEFiI,IAAI,CAACkE,OAAO,CAAC7S,SAAS,CAACqT,oBAAoB,CAAC1E,IAAI,CAACtF,QAAQ,CAACJ,EAAE,EAAE,IAAI,CAAC;AACrE;AAEA,SAASwG,QAAQA,CAACd,IAAI,EAAEjI,EAAE,EAAE;EAC1B,IAAIiI,IAAI,CAACtF,QAAQ,CAACD,KAAK,KAAK,MAAM,EAAE;IAClC1C,EAAE,CAAC,IAAInF,KAAK,CAAC,qBAAqB,CAAC,CAAC;IACpC;EACF;EAEAoN,IAAI,CAACjP,UAAU,CAACgK,IAAI,CAAEsG,OAAO,IAAK;IAChC,IAAIA,OAAO,EAAE;MACXtJ,EAAE,CAACsJ,OAAO,KAAK,IAAI,GAAGA,OAAO,GAAG,IAAIzO,KAAK,CAAC,sBAAsB,CAAC,CAAC;MAClE;IACF;IACAoN,IAAI,CAAC2E,OAAO,GAAG,OAAO;IACtB5M,EAAE,CAACxI,SAAS,EAAEyQ,IAAI,CAAC;EACrB,CAAC,CAAC;EAEFA,IAAI,CAACkE,OAAO,CAAC7S,SAAS,CAACuP,KAAK,CAACZ,IAAI,CAACtF,QAAQ,CAACJ,EAAE,EAAE,IAAI,CAAC;AACtD;AAEA,SAASqG,OAAOA,CAACX,IAAI,EAAEJ,GAAG,EAAEjH,IAAI,EAAEZ,EAAE,EAAE;EACpC,IAAIiI,IAAI,CAACtF,QAAQ,CAACD,KAAK,KAAK,MAAM,EAAE;IAClC1C,EAAE,CAAC,IAAInF,KAAK,CAAC,qBAAqB,CAAC,CAAC;IACpC;EACF;EAEAoN,IAAI,CAACjP,UAAU,CAACgK,IAAI,CAAEsG,OAAO,IAAK;IAChC,IAAIA,OAAO,EAAE;MACXtJ,EAAE,CAACsJ,OAAO,KAAK,IAAI,GAAGA,OAAO,GAAG,IAAIzO,KAAK,CAAC,gBAAgB,CAAC,CAAC;MAC5D;IACF;IACAoN,IAAI,CAAC2E,OAAO,GAAG,MAAM;IACrB3E,IAAI,CAACF,aAAa,GAAInH,IAAI,CAACmH,aAAa,KAAK,KAAM;IACnD/H,EAAE,CAACxI,SAAS,EAAEyQ,IAAI,CAAC;EACrB,CAAC,CAAC;EAEFA,IAAI,CAACkE,OAAO,CAAC7S,SAAS,CAACsO,IAAI,CAACK,IAAI,CAACtF,QAAQ,CAACJ,EAAE,EAAEsF,GAAG,EAAE,IAAI,CAAC;AAC1D;AAEA,SAASU,MAAMA,CAACN,IAAI,EAAEK,GAAG,EAAE;EACzB,IAAIL,IAAI,CAACtF,QAAQ,CAACD,KAAK,KAAK,MAAM,EAChC;EAEF,MAAMhB,IAAI,GAAGmL,MAAM,CAACnL,IAAI,CAAC4G,GAAG,IAAI,CAAC,CAAC,CAAC;EAEnC,KAAK,IAAIvC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrE,IAAI,CAAC1G,MAAM,EAAE,EAAE+K,CAAC,EAAE;IACpC,MAAMlK,GAAG,GAAG6F,IAAI,CAACqE,CAAC,CAAC;IACnB,MAAM+G,GAAG,GAAGxE,GAAG,CAACzM,GAAG,CAAC;IACpBoM,IAAI,CAACkE,OAAO,CAAC7S,SAAS,CAACgP,GAAG,CAACL,IAAI,CAACtF,QAAQ,CAACJ,EAAE,EAAE1G,GAAG,EAAEiR,GAAG,EAAE,KAAK,CAAC;EAC/D;AACF;AAEA,SAAS7D,YAAYA,CAAChB,IAAI,EAAEzJ,IAAI,EAAEwB,EAAE,EAAE;EACpC,IAAIiI,IAAI,CAACtF,QAAQ,CAACD,KAAK,KAAK,MAAM,EAAE;IAClC1C,EAAE,CAAC,IAAInF,KAAK,CAAC,qBAAqB,CAAC,CAAC;IACpC;EACF;EAEAoN,IAAI,CAACjP,UAAU,CAACgK,IAAI,CAAEsG,OAAO,IAAK;IAChC,IAAIA,OAAO,EAAE;MACXtJ,EAAE,CAACsJ,OAAO,KAAK,IAAI,GACdA,OAAO,GACP,IAAIzO,KAAK,CAAE,8BAA6B2D,IAAK,EAAC,CAAC,CAAC;MACrD;IACF;IACAyJ,IAAI,CAAC2E,OAAO,GAAG,WAAW;IAC1B5M,EAAE,CAACxI,SAAS,EAAEyQ,IAAI,CAAC;EACrB,CAAC,CAAC;EAEFA,IAAI,CAACkE,OAAO,CAAC7S,SAAS,CAACyT,SAAS,CAAC9E,IAAI,CAACtF,QAAQ,CAACJ,EAAE,EAAE/D,IAAI,EAAE,IAAI,CAAC;AAChE;;AAEA;AACA,SAASuD,cAAcA,CAACoJ,IAAI,EAAErJ,IAAI,EAAE;EAClC;EACA;EACA;;EAEA,IAAIyJ,SAAS,GAAG,CAAC,CAAC;EAClB,IAAIpN,MAAM;EAEV,MAAM6O,MAAM,GAAGA,CAAA,KAAM;IACnB,MAAM3K,QAAQ,GAAG;MACf9C,IAAI,EAAEuC,IAAI,CAACvC,IAAI;MACf+C,QAAQ,EAAE;QACRC,EAAE,EAAEgJ,SAAS;QACb/I,MAAM,EAAElM,UAAU;QAClBmM,UAAU,EAAElM,WAAW;QACvBmM,KAAK,EAAE;MACT,CAAC;MACDC,QAAQ,EAAE;QACRJ,EAAE,EAAET,IAAI,CAACc,MAAM;QACfJ,MAAM,EAAEV,IAAI,CAACU,MAAM;QACnBC,UAAU,EAAEX,IAAI,CAACW,UAAU;QAC3BC,KAAK,EAAE;MACT;IACF,CAAC;IACD,MAAMwG,MAAM,GAAG,IAAI7S,OAAO,CAAC8U,IAAI,EAAE9I,QAAQ,CAAC;IAC1C8I,IAAI,CAACpS,QAAQ,CAACgD,MAAM,CAACwP,SAAS,EAAErC,MAAM,CAAC;IAEvCiC,IAAI,CAAC7R,SAAS,CAAC2T,kBAAkB,CAACnL,IAAI,CAACc,MAAM,EACX2I,SAAS,EACTjV,UAAU,EACVC,WAAW,CAAC;IAC9C,OAAO2S,MAAM;EACf,CAAC;EACD,MAAMgE,MAAM,GAAGA,CAAA,KAAM;IACnB,IAAI/O,MAAM,KAAK3G,SAAS,EAAE;MACxB,IAAI+T,SAAS,KAAK,CAAC,CAAC,EAClBpN,MAAM,GAAGzJ,oBAAoB,CAACyY,iBAAiB,CAAC,KAEhDhP,MAAM,GAAGzJ,oBAAoB,CAAC0Y,cAAc;IAChD;IAEA,IAAI7B,SAAS,KAAK,CAAC,CAAC,EAClBJ,IAAI,CAACpS,QAAQ,CAACsU,MAAM,CAAC9B,SAAS,CAAC;IAEjCJ,IAAI,CAAC7R,SAAS,CAACgU,eAAe,CAACxL,IAAI,CAACc,MAAM,EAAEzE,MAAM,EAAE,EAAE,CAAC;EACzD,CAAC;EACD,MAAMoP,cAAc,GAAGA,CAAA,KAAM;IAC3BhC,SAAS,GAAGJ,IAAI,CAACpS,QAAQ,CAACyS,GAAG,EAAE;IAE/B,IAAID,SAAS,KAAK,CAAC,CAAC,EAAE;MACpBpN,MAAM,GAAGzJ,oBAAoB,CAACyY,iBAAiB;MAC/C,IAAIhC,IAAI,CAAC7T,MAAM,CAACsB,KAAK,EAAE;QACrBuS,IAAI,CAAC7T,MAAM,CAACsB,KAAK,CACf,wDAAwD,GACpD,uBAAuB,CAC5B;MACH;IACF;IAEA,OAAQ2S,SAAS,KAAK,CAAC,CAAC;EAC1B,CAAC;EAED,MAAMvO,IAAI,GAAG8E,IAAI,CAAC9E,IAAI;EACtB,QAAQ8E,IAAI,CAACvC,IAAI;IACf,KAAK,iBAAiB;MAAE;QACtB,MAAMuN,GAAG,GAAG3B,IAAI,CAAClS,WAAW,CAAE,GAAE+D,IAAI,CAACwQ,MAAO,IAAGxQ,IAAI,CAACyQ,QAAS,EAAC,CAAC;QAC/D,IAAIX,GAAG,KAAKtV,SAAS,IAAI+V,cAAc,EAAE,EAAE;UACzC,IAAIvQ,IAAI,CAACyQ,QAAQ,KAAK,CAAC,EACrBzQ,IAAI,CAACyQ,QAAQ,GAAGX,GAAG;UACrB3B,IAAI,CAAC5N,IAAI,CAAC,gBAAgB,EAAEP,IAAI,EAAEgQ,MAAM,EAAEE,MAAM,CAAC;UACjD;QACF;QACA;MACF;IACA,KAAK,mCAAmC;MACtC,IAAI/B,IAAI,CAACjS,eAAe,CAAC8D,IAAI,CAACqN,UAAU,CAAC,KAAK7S,SAAS,IAChD+V,cAAc,EAAE,EAAE;QACvBpC,IAAI,CAAC5N,IAAI,CAAC,iBAAiB,EAAEP,IAAI,EAAEgQ,MAAM,EAAEE,MAAM,CAAC;QAClD;MACF;MACA;IACF,KAAK,wBAAwB;MAC3B,IAAI/B,IAAI,CAAC/R,gBAAgB,IAClB,OAAO+R,IAAI,CAACtS,MAAM,CAAC6U,SAAS,KAAK,UAAU,IAC3CH,cAAc,EAAE,EAAE;QACvBpC,IAAI,CAACtS,MAAM,CAAC6U,SAAS,CAAC,CAACvW,GAAG,EAAE+R,MAAM,KAAK;UACrC,IAAI/R,GAAG,EACL,OAAO+V,MAAM,EAAE;UAEjB,MAAMS,QAAQ,GAAGX,MAAM,EAAE;UACzBW,QAAQ,CAACC,IAAI,CAAC1E,MAAM,CAAC,CAAC0E,IAAI,CAACD,QAAQ,CAAC;QACtC,CAAC,CAAC;QACF;MACF;MACA;IACF,KAAK,KAAK;MACR,IAAIxC,IAAI,CAAChS,UAAU,KAAK,CAAC,IAAIoU,cAAc,EAAE,EAAE;QAC7CpC,IAAI,CAAC5N,IAAI,CAAC,KAAK,EAAEP,IAAI,EAAEgQ,MAAM,EAAEE,MAAM,CAAC;QACtC;MACF;MACA;IACF;MACE;MACA/O,MAAM,GAAGzJ,oBAAoB,CAACmZ,oBAAoB;MAClD,IAAI1C,IAAI,CAAC7T,MAAM,CAACsB,KAAK,EAAE;QACrBuS,IAAI,CAAC7T,MAAM,CAACsB,KAAK,CACf,mEAAmE,GAC9D,SAAQkJ,IAAI,CAACvC,IAAK,EAAC,CACzB;MACH;EAAC;EAGL,IAAIpB,MAAM,KAAK3G,SAAS,EAAE;IACxB2G,MAAM,GAAGzJ,oBAAoB,CAACoZ,2BAA2B;IACzD,IAAI3C,IAAI,CAAC7T,MAAM,CAACsB,KAAK,EAAE;MACpBuS,IAAI,CAAC7T,MAAM,CAACsB,KAAK,CAChB,uEAAuE,GACnEkJ,IAAI,CAACvC,IAAI,CACd;IACH;EACF;EAEA2N,MAAM,EAAE;AACV;AAEA,MAAMjB,YAAY,GAAG,CAAC,MAAM;EAC1B,MAAM8B,MAAM,GAAGhU,MAAM,CAACiU,WAAW,CAAC,EAAE,CAAC;EACrC,OAAO,MAAM;IACXha,cAAc,CAAC+Z,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;IAC7B,OAAOA,MAAM,CAAC/B,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC;EAC/B,CAAC;AACH,CAAC,GAAG;AAEJ,SAAS/F,qBAAqBA,CAACgI,QAAQ,EAAE;EACvC,IAAI,CAAC/S,KAAK,CAACC,OAAO,CAAC8S,QAAQ,CAAC,EAC1B,MAAM,IAAIpT,KAAK,CAAC,2BAA2B,CAAC;EAE9C,IAAIqT,CAAC,GAAG,CAAC;EACT,OAAO,CAACC,SAAS,EAAEhP,cAAc,EAAEa,EAAE,KAAK;IACxC,IAAIkO,CAAC,KAAKD,QAAQ,CAACjT,MAAM,EACvB,OAAO,KAAK;IACd,OAAOiT,QAAQ,CAACC,CAAC,EAAE,CAAC;EACtB,CAAC;AACH;AAEA,SAASzM,aAAaA,CAAC2M,MAAM,EAAEC,KAAK,EAAErO,EAAE,EAAE;EACxC,IAAI,CAACoO,MAAM,CAAC7U,KAAK,IAAI,CAAC3C,UAAU,CAACwX,MAAM,CAAC7U,KAAK,CAAC,EAC5C;EAEF,IAAI,OAAOyG,EAAE,KAAK,UAAU,EAC1BA,EAAE,GAAG9I,IAAI;EAEX,IAAI,CAACgE,KAAK,CAACC,OAAO,CAACkT,KAAK,CAAC,EACvB,MAAM,IAAIC,SAAS,CAAC,4BAA4B,CAAC;EAEnD,MAAM5M,IAAI,GAAG,EAAE;EACf,KAAK,MAAM7F,GAAG,IAAIwS,KAAK,EAAE;IACvB,MAAME,MAAM,GAAG7Y,QAAQ,CAACmG,GAAG,CAAC;IAC5B,IAAI0S,MAAM,YAAY1T,KAAK,EACzB,MAAM0T,MAAM;IACd7M,IAAI,CAACsB,IAAI,CAACuL,MAAM,CAAC;EACnB;EAEA,IAAI,CAACH,MAAM,CAAC9W,MAAM,CAACqB,YAAY,IACvByV,MAAM,CAAC9W,MAAM,CAACqB,YAAY,IAAI1B,UAAU,CAACkT,IAAI,CAACiE,MAAM,CAAC/U,UAAU,CAAE,EAAE;IACzE+U,MAAM,CAACpV,UAAU,CAACgK,IAAI,CAAC,CAACsG,OAAO,EAAEtM,IAAI,KAAK;MACxC,IAAIsM,OAAO,EAAE;QACXtJ,EAAE,CAACsJ,OAAO,KAAK,IAAI,GACdA,OAAO,GACP,IAAIzO,KAAK,CAAC,sCAAsC,CAAC,CAAC;QACvD;MACF;;MAEA;MACA,MAAMoB,GAAG,GAAG,EAAE;MACd,IAAIuS,MAAM,GAAG,CAAC;MACdzX,YAAY,CAACxB,IAAI,CAACyH,IAAI,EAAE,CAAC,CAAC;MAC1B,OAAOjG,YAAY,CAAC0X,KAAK,EAAE,EAAE;QAC3B,IAAID,MAAM,KAAK9M,IAAI,CAAC1G,MAAM,EACxB;QACF,MAAMa,GAAG,GAAG6F,IAAI,CAAC8M,MAAM,EAAE,CAAC;QAC1B,MAAME,SAAS,GAAG7S,GAAG,CAAC8S,YAAY,EAAE;QAEpC,MAAMC,QAAQ,GAAG7X,YAAY,CAAC8X,UAAU,EAAE;QAC1C7X,SAAS,CAACzB,IAAI,CAACqZ,QAAQ,EAAE,CAAC,CAAC;QAC3B,MAAMrP,IAAI,GAAGvI,SAAS,CAAC6X,UAAU,CAAC,IAAI,CAAC;QACvC,IAAIC,KAAK,GAAG9X,SAAS,CAAC6X,UAAU,EAAE;QAElC,IAAIE,IAAI;QACR,IAAIxP,IAAI,KAAK1D,GAAG,CAAC0D,IAAI,EAAE;UACrB,IAAI1D,GAAG,CAAC0D,IAAI,KAAK,SAAS,EAAE;YAC1B,QAAQA,IAAI;cACV,KAAK,cAAc;gBACjBwP,IAAI,GAAG,QAAQ;gBACf;cACF,KAAK,cAAc;gBACjBA,IAAI,GAAG,QAAQ;gBACf;cACF;gBACE;YAAS;UAEf,CAAC,MAAM;YACL;UACF;QACF;QAEA,MAAMC,SAAS,GAAGZ,MAAM,CAAC9U,SAAS,CAAC2V,IAAI,CAACD,SAAS;QACjD,MAAME,UAAU,GAAGnV,MAAM,CAACiU,WAAW,CACnC,CAAC,GAAG,EAAE,GAAG,CAAC,GAAGgB,SAAS,CAAChU,MAAM,GAAG,CAAC,GAAG0T,SAAS,CAAC1T,MAAM,CACrD;QACD,IAAIuB,CAAC,GAAG,CAAC;QACTtG,aAAa,CAACiZ,UAAU,EAAE,EAAE,EAAE3S,CAAC,CAAC;QAChC2S,UAAU,CAACC,SAAS,CAAC,+BAA+B,EAAE5S,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC;QACjEtG,aAAa,CAACiZ,UAAU,EAAEF,SAAS,CAAChU,MAAM,EAAEuB,CAAC,IAAI,EAAE,CAAC;QACpD3G,UAAU,CAACoZ,SAAS,EAAEE,UAAU,EAAE,CAAC,EAAEF,SAAS,CAAChU,MAAM,EAAEuB,CAAC,IAAI,CAAC,CAAC;QAC9DtG,aAAa,CAACiZ,UAAU,EAAER,SAAS,CAAC1T,MAAM,EAAEuB,CAAC,IAAIyS,SAAS,CAAChU,MAAM,CAAC;QAClEpF,UAAU,CAAC8Y,SAAS,EAAEQ,UAAU,EAAE,CAAC,EAAER,SAAS,CAAC1T,MAAM,EAAEuB,CAAC,IAAI,CAAC,CAAC;QAE9D,IAAI,EAAEuS,KAAK,GAAG9Y,YAAY,CAAC8Y,KAAK,EAAEvP,IAAI,CAAC,CAAC,EACtC;QACF,IAAI1D,GAAG,CAACC,MAAM,CAACoT,UAAU,EAAEJ,KAAK,EAAEC,IAAI,CAAC,KAAK,IAAI,EAC9C9S,GAAG,CAAC+G,IAAI,CAACnH,GAAG,CAAC;MACjB;MACA7E,SAAS,CAACoY,KAAK,EAAE;MACjBrY,YAAY,CAACqY,KAAK,EAAE;MAEpBpP,EAAE,CAAC,IAAI,EAAE/D,GAAG,CAAC;IACf,CAAC,CAAC;IAEFmS,MAAM,CAAC9U,SAAS,CAAC+V,qBAAqB,CAAC3N,IAAI,CAAC;IAC5C;EACF;EAEAoF,OAAO,CAACC,QAAQ,CACd/G,EAAE,EACF,IAAInF,KAAK,CACP,sEAAsE,CACvE,CACF;AACH;AAEA,SAAS8L,WAAWA,CAACyH,MAAM,EAAEvS,GAAG,EAAEe,aAAa,EAAE;EAC/C,QAAQf,GAAG,CAAC0D,IAAI;IACd,KAAK,SAAS;MACZ,IAAI6O,MAAM,CAAC9U,SAAS,CAACkQ,YAAY,GAAGjV,MAAM,CAAC+a,sBAAsB,EAAE;QACjE,IAAI,CAACpU,KAAK,CAACC,OAAO,CAACyB,aAAa,CAAC,EAC/BA,aAAa,GAAG,CAAC,cAAc,EAAE,cAAc,CAAC,CAAC,KAEjDA,aAAa,GAAG,CAAC,cAAc,EAAE,cAAc,EAAE,GAAGA,aAAa,CAAC;MACtE;MACA,IAAI1B,KAAK,CAACC,OAAO,CAACyB,aAAa,CAAC,EAAE;QAChC,IAAIA,aAAa,CAACjB,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,EAC9C,OAAO,CAAC,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC;QACrC,IAAIiB,aAAa,CAACjB,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,EAC9C,OAAO,CAAC,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC;QACrC,IAAIiB,aAAa,CAACjB,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,EACzC,OAAO,EAAE;MACb;MACA,OAAO,CAAC,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;EAAC;AAEnC;AAEA4T,MAAM,CAACC,OAAO,GAAGpY,MAAM"},"metadata":{},"sourceType":"script","externalDependencies":[]}