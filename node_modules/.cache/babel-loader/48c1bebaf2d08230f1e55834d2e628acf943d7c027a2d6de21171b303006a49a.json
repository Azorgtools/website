{"ast":null,"code":"// TODO:\n//   * convert listenerCount() usage to emit() return value checking?\n//   * emit error when connection severed early (e.g. before handshake)\n//   * add '.connected' or similar property to connection objects to allow\n//     immediate connection status checking\n'use strict';\n\nconst {\n  Server: netServer\n} = require('net');\nconst EventEmitter = require('events');\nconst {\n  listenerCount\n} = EventEmitter;\nconst {\n  CHANNEL_OPEN_FAILURE,\n  DEFAULT_CIPHER,\n  DEFAULT_COMPRESSION,\n  DEFAULT_KEX,\n  DEFAULT_MAC,\n  DEFAULT_SERVER_HOST_KEY,\n  DISCONNECT_REASON,\n  DISCONNECT_REASON_BY_VALUE,\n  SUPPORTED_CIPHER,\n  SUPPORTED_COMPRESSION,\n  SUPPORTED_KEX,\n  SUPPORTED_MAC,\n  SUPPORTED_SERVER_HOST_KEY\n} = require('./protocol/constants.js');\nconst {\n  init: cryptoInit\n} = require('./protocol/crypto.js');\nconst {\n  KexInit\n} = require('./protocol/kex.js');\nconst {\n  parseKey\n} = require('./protocol/keyParser.js');\nconst Protocol = require('./protocol/Protocol.js');\nconst {\n  SFTP\n} = require('./protocol/SFTP.js');\nconst {\n  writeUInt32BE\n} = require('./protocol/utils.js');\nconst {\n  Channel,\n  MAX_WINDOW,\n  PACKET_SIZE,\n  windowAdjust,\n  WINDOW_THRESHOLD\n} = require('./Channel.js');\nconst {\n  ChannelManager,\n  generateAlgorithmList,\n  isWritable,\n  onChannelOpenFailure,\n  onCHANNEL_CLOSE\n} = require('./utils.js');\nconst MAX_PENDING_AUTHS = 10;\nclass AuthContext extends EventEmitter {\n  constructor(protocol, username, service, method, cb) {\n    super();\n    this.username = this.user = username;\n    this.service = service;\n    this.method = method;\n    this._initialResponse = false;\n    this._finalResponse = false;\n    this._multistep = false;\n    this._cbfinal = (allowed, methodsLeft, isPartial) => {\n      if (!this._finalResponse) {\n        this._finalResponse = true;\n        cb(this, allowed, methodsLeft, isPartial);\n      }\n    };\n    this._protocol = protocol;\n  }\n  accept() {\n    this._cleanup && this._cleanup();\n    this._initialResponse = true;\n    this._cbfinal(true);\n  }\n  reject(methodsLeft, isPartial) {\n    this._cleanup && this._cleanup();\n    this._initialResponse = true;\n    this._cbfinal(false, methodsLeft, isPartial);\n  }\n}\nclass KeyboardAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, submethods, cb) {\n    super(protocol, username, service, method, cb);\n    this._multistep = true;\n    this._cb = undefined;\n    this._onInfoResponse = responses => {\n      const callback = this._cb;\n      if (callback) {\n        this._cb = undefined;\n        callback(responses);\n      }\n    };\n    this.submethods = submethods;\n    this.on('abort', () => {\n      this._cb && this._cb(new Error('Authentication request aborted'));\n    });\n  }\n  prompt(prompts, title, instructions, cb) {\n    if (!Array.isArray(prompts)) prompts = [prompts];\n    if (typeof title === 'function') {\n      cb = title;\n      title = instructions = undefined;\n    } else if (typeof instructions === 'function') {\n      cb = instructions;\n      instructions = undefined;\n    } else if (typeof cb !== 'function') {\n      cb = undefined;\n    }\n    for (let i = 0; i < prompts.length; ++i) {\n      if (typeof prompts[i] === 'string') {\n        prompts[i] = {\n          prompt: prompts[i],\n          echo: true\n        };\n      }\n    }\n    this._cb = cb;\n    this._initialResponse = true;\n    this._protocol.authInfoReq(title, instructions, prompts);\n  }\n}\nclass PKAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, pkInfo, cb) {\n    super(protocol, username, service, method, cb);\n    this.key = {\n      algo: pkInfo.keyAlgo,\n      data: pkInfo.key\n    };\n    this.hashAlgo = pkInfo.hashAlgo;\n    this.signature = pkInfo.signature;\n    this.blob = pkInfo.blob;\n  }\n  accept() {\n    if (!this.signature) {\n      this._initialResponse = true;\n      this._protocol.authPKOK(this.key.algo, this.key.data);\n    } else {\n      AuthContext.prototype.accept.call(this);\n    }\n  }\n}\nclass HostbasedAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, pkInfo, cb) {\n    super(protocol, username, service, method, cb);\n    this.key = {\n      algo: pkInfo.keyAlgo,\n      data: pkInfo.key\n    };\n    this.hashAlgo = pkInfo.hashAlgo;\n    this.signature = pkInfo.signature;\n    this.blob = pkInfo.blob;\n    this.localHostname = pkInfo.localHostname;\n    this.localUsername = pkInfo.localUsername;\n  }\n}\nclass PwdAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, password, cb) {\n    super(protocol, username, service, method, cb);\n    this.password = password;\n    this._changeCb = undefined;\n  }\n  requestChange(prompt, cb) {\n    if (this._changeCb) throw new Error('Change request already in progress');\n    if (typeof prompt !== 'string') throw new Error('prompt argument must be a string');\n    if (typeof cb !== 'function') throw new Error('Callback argument must be a function');\n    this._changeCb = cb;\n    this._protocol.authPasswdChg(prompt);\n  }\n}\nclass Session extends EventEmitter {\n  constructor(client, info, localChan) {\n    super();\n    this.type = 'session';\n    this.subtype = undefined;\n    this.server = true;\n    this._ending = false;\n    this._channel = undefined;\n    this._chanInfo = {\n      type: 'session',\n      incoming: {\n        id: localChan,\n        window: MAX_WINDOW,\n        packetSize: PACKET_SIZE,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n  }\n}\nclass Server extends EventEmitter {\n  constructor(cfg, listener) {\n    super();\n    if (typeof cfg !== 'object' || cfg === null) throw new Error('Missing configuration object');\n    const hostKeys = Object.create(null);\n    const hostKeyAlgoOrder = [];\n    const hostKeys_ = cfg.hostKeys;\n    if (!Array.isArray(hostKeys_)) throw new Error('hostKeys must be an array');\n    const cfgAlgos = typeof cfg.algorithms === 'object' && cfg.algorithms !== null ? cfg.algorithms : {};\n    const hostKeyAlgos = generateAlgorithmList(cfgAlgos.serverHostKey, DEFAULT_SERVER_HOST_KEY, SUPPORTED_SERVER_HOST_KEY);\n    for (let i = 0; i < hostKeys_.length; ++i) {\n      let privateKey;\n      if (Buffer.isBuffer(hostKeys_[i]) || typeof hostKeys_[i] === 'string') privateKey = parseKey(hostKeys_[i]);else privateKey = parseKey(hostKeys_[i].key, hostKeys_[i].passphrase);\n      if (privateKey instanceof Error) throw new Error(`Cannot parse privateKey: ${privateKey.message}`);\n      if (Array.isArray(privateKey)) {\n        // OpenSSH's newer format only stores 1 key for now\n        privateKey = privateKey[0];\n      }\n      if (privateKey.getPrivatePEM() === null) throw new Error('privateKey value contains an invalid private key');\n\n      // Discard key if we already found a key of the same type\n      if (hostKeyAlgoOrder.includes(privateKey.type)) continue;\n      if (privateKey.type === 'ssh-rsa') {\n        // SSH supports multiple signature hashing algorithms for RSA, so we add\n        // the algorithms in the desired order\n        let sha1Pos = hostKeyAlgos.indexOf('ssh-rsa');\n        const sha256Pos = hostKeyAlgos.indexOf('rsa-sha2-256');\n        const sha512Pos = hostKeyAlgos.indexOf('rsa-sha2-512');\n        if (sha1Pos === -1) {\n          // Fall back to giving SHA1 the lowest priority\n          sha1Pos = Infinity;\n        }\n        [sha1Pos, sha256Pos, sha512Pos].sort(compareNumbers).forEach(pos => {\n          if (pos === -1) return;\n          let type;\n          switch (pos) {\n            case sha1Pos:\n              type = 'ssh-rsa';\n              break;\n            case sha256Pos:\n              type = 'rsa-sha2-256';\n              break;\n            case sha512Pos:\n              type = 'rsa-sha2-512';\n              break;\n            default:\n              return;\n          }\n\n          // Store same RSA key under each hash algorithm name for convenience\n          hostKeys[type] = privateKey;\n          hostKeyAlgoOrder.push(type);\n        });\n      } else {\n        hostKeys[privateKey.type] = privateKey;\n        hostKeyAlgoOrder.push(privateKey.type);\n      }\n    }\n    const algorithms = {\n      kex: generateAlgorithmList(cfgAlgos.kex, DEFAULT_KEX, SUPPORTED_KEX),\n      serverHostKey: hostKeyAlgoOrder,\n      cs: {\n        cipher: generateAlgorithmList(cfgAlgos.cipher, DEFAULT_CIPHER, SUPPORTED_CIPHER),\n        mac: generateAlgorithmList(cfgAlgos.hmac, DEFAULT_MAC, SUPPORTED_MAC),\n        compress: generateAlgorithmList(cfgAlgos.compress, DEFAULT_COMPRESSION, SUPPORTED_COMPRESSION),\n        lang: []\n      },\n      sc: undefined\n    };\n    algorithms.sc = algorithms.cs;\n    if (typeof listener === 'function') this.on('connection', listener);\n    const origDebug = typeof cfg.debug === 'function' ? cfg.debug : undefined;\n    const ident = cfg.ident ? Buffer.from(cfg.ident) : undefined;\n    const offer = new KexInit(algorithms);\n    this._srv = new netServer(socket => {\n      if (this._connections >= this.maxConnections) {\n        socket.destroy();\n        return;\n      }\n      ++this._connections;\n      socket.once('close', () => {\n        --this._connections;\n      });\n      let debug;\n      if (origDebug) {\n        // Prepend debug output with a unique identifier in case there are\n        // multiple clients connected at the same time\n        const debugPrefix = `[${process.hrtime().join('.')}] `;\n        debug = msg => {\n          origDebug(`${debugPrefix}${msg}`);\n        };\n      }\n\n      // eslint-disable-next-line no-use-before-define\n      new Client(socket, hostKeys, ident, offer, debug, this, cfg);\n    }).on('error', err => {\n      this.emit('error', err);\n    }).on('listening', () => {\n      this.emit('listening');\n    }).on('close', () => {\n      this.emit('close');\n    });\n    this._connections = 0;\n    this.maxConnections = Infinity;\n  }\n  injectSocket(socket) {\n    this._srv.emit('connection', socket);\n  }\n  listen() {\n    this._srv.listen(...arguments);\n    return this;\n  }\n  address() {\n    return this._srv.address();\n  }\n  getConnections(cb) {\n    this._srv.getConnections(cb);\n    return this;\n  }\n  close(cb) {\n    this._srv.close(cb);\n    return this;\n  }\n  ref() {\n    this._srv.ref();\n    return this;\n  }\n  unref() {\n    this._srv.unref();\n    return this;\n  }\n}\nServer.KEEPALIVE_CLIENT_INTERVAL = 15000;\nServer.KEEPALIVE_CLIENT_COUNT_MAX = 3;\nclass Client extends EventEmitter {\n  constructor(socket, hostKeys, ident, offer, debug, server, srvCfg) {\n    super();\n    let exchanges = 0;\n    let acceptedAuthSvc = false;\n    let pendingAuths = [];\n    let authCtx;\n    let kaTimer;\n    let onPacket;\n    const unsentGlobalRequestsReplies = [];\n    this._sock = socket;\n    this._chanMgr = new ChannelManager(this);\n    this._debug = debug;\n    this.noMoreSessions = false;\n    this.authenticated = false;\n\n    // Silence pre-header errors\n    function onClientPreHeaderError(err) {}\n    this.on('error', onClientPreHeaderError);\n    const DEBUG_HANDLER = !debug ? undefined : (p, display, msg) => {\n      debug(`Debug output from client: ${JSON.stringify(msg)}`);\n    };\n    const kaIntvl = typeof srvCfg.keepaliveInterval === 'number' && isFinite(srvCfg.keepaliveInterval) && srvCfg.keepaliveInterval > 0 ? srvCfg.keepaliveInterval : typeof Server.KEEPALIVE_CLIENT_INTERVAL === 'number' && isFinite(Server.KEEPALIVE_CLIENT_INTERVAL) && Server.KEEPALIVE_CLIENT_INTERVAL > 0 ? Server.KEEPALIVE_CLIENT_INTERVAL : -1;\n    const kaCountMax = typeof srvCfg.keepaliveCountMax === 'number' && isFinite(srvCfg.keepaliveCountMax) && srvCfg.keepaliveCountMax >= 0 ? srvCfg.keepaliveCountMax : typeof Server.KEEPALIVE_CLIENT_COUNT_MAX === 'number' && isFinite(Server.KEEPALIVE_CLIENT_COUNT_MAX) && Server.KEEPALIVE_CLIENT_COUNT_MAX >= 0 ? Server.KEEPALIVE_CLIENT_COUNT_MAX : -1;\n    let kaCurCount = 0;\n    if (kaIntvl !== -1 && kaCountMax !== -1) {\n      this.once('ready', () => {\n        const onClose = () => {\n          clearInterval(kaTimer);\n        };\n        this.on('close', onClose).on('end', onClose);\n        kaTimer = setInterval(() => {\n          if (++kaCurCount > kaCountMax) {\n            clearInterval(kaTimer);\n            const err = new Error('Keepalive timeout');\n            err.level = 'client-timeout';\n            this.emit('error', err);\n            this.end();\n          } else {\n            // XXX: if the server ever starts sending real global requests to\n            //      the client, we will need to add a dummy callback here to\n            //      keep the correct reply order\n            proto.ping();\n          }\n        }, kaIntvl);\n      });\n      // TODO: re-verify keepalive behavior with OpenSSH\n      onPacket = () => {\n        kaTimer && kaTimer.refresh();\n        kaCurCount = 0;\n      };\n    }\n    const proto = this._protocol = new Protocol({\n      server: true,\n      hostKeys,\n      ident,\n      offer,\n      onPacket,\n      greeting: srvCfg.greeting,\n      banner: srvCfg.banner,\n      onWrite: data => {\n        if (isWritable(socket)) socket.write(data);\n      },\n      onError: err => {\n        if (!proto._destruct) socket.removeAllListeners('data');\n        this.emit('error', err);\n        try {\n          socket.end();\n        } catch {}\n      },\n      onHeader: header => {\n        this.removeListener('error', onClientPreHeaderError);\n        const info = {\n          ip: socket.remoteAddress,\n          family: socket.remoteFamily,\n          port: socket.remotePort,\n          header\n        };\n        if (!server.emit('connection', this, info)) {\n          // auto reject\n          proto.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n          socket.end();\n          return;\n        }\n        if (header.greeting) this.emit('greeting', header.greeting);\n      },\n      onHandshakeComplete: negotiated => {\n        if (++exchanges > 1) this.emit('rekey');\n        this.emit('handshake', negotiated);\n      },\n      debug,\n      messageHandlers: {\n        DEBUG: DEBUG_HANDLER,\n        DISCONNECT: (p, reason, desc) => {\n          if (reason !== DISCONNECT_REASON.BY_APPLICATION) {\n            if (!desc) {\n              desc = DISCONNECT_REASON_BY_VALUE[reason];\n              if (desc === undefined) desc = `Unexpected disconnection reason: ${reason}`;\n            }\n            const err = new Error(desc);\n            err.code = reason;\n            this.emit('error', err);\n          }\n          socket.end();\n        },\n        CHANNEL_OPEN: (p, info) => {\n          // Handle incoming requests from client\n\n          // Do early reject in some cases to prevent wasteful channel\n          // allocation\n          if (info.type === 'session' && this.noMoreSessions || !this.authenticated) {\n            const reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n            return proto.channelOpenFail(info.sender, reasonCode);\n          }\n          let localChan = -1;\n          let reason;\n          let replied = false;\n          let accept;\n          const reject = () => {\n            if (replied) return;\n            replied = true;\n            if (reason === undefined) {\n              if (localChan === -1) reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;else reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;\n            }\n            if (localChan !== -1) this._chanMgr.remove(localChan);\n            proto.channelOpenFail(info.sender, reason, '');\n          };\n          const reserveChannel = () => {\n            localChan = this._chanMgr.add();\n            if (localChan === -1) {\n              reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n              if (debug) {\n                debug('Automatic rejection of incoming channel open: ' + 'no channels available');\n              }\n            }\n            return localChan !== -1;\n          };\n          const data = info.data;\n          switch (info.type) {\n            case 'session':\n              if (listenerCount(this, 'session') && reserveChannel()) {\n                accept = () => {\n                  if (replied) return;\n                  replied = true;\n                  const instance = new Session(this, info, localChan);\n                  this._chanMgr.update(localChan, instance);\n                  proto.channelOpenConfirm(info.sender, localChan, MAX_WINDOW, PACKET_SIZE);\n                  return instance;\n                };\n                this.emit('session', accept, reject);\n                return;\n              }\n              break;\n            case 'direct-tcpip':\n              if (listenerCount(this, 'tcpip') && reserveChannel()) {\n                accept = () => {\n                  if (replied) return;\n                  replied = true;\n                  const chanInfo = {\n                    type: undefined,\n                    incoming: {\n                      id: localChan,\n                      window: MAX_WINDOW,\n                      packetSize: PACKET_SIZE,\n                      state: 'open'\n                    },\n                    outgoing: {\n                      id: info.sender,\n                      window: info.window,\n                      packetSize: info.packetSize,\n                      state: 'open'\n                    }\n                  };\n                  const stream = new Channel(this, chanInfo, {\n                    server: true\n                  });\n                  this._chanMgr.update(localChan, stream);\n                  proto.channelOpenConfirm(info.sender, localChan, MAX_WINDOW, PACKET_SIZE);\n                  return stream;\n                };\n                this.emit('tcpip', accept, reject, data);\n                return;\n              }\n              break;\n            case 'direct-streamlocal@openssh.com':\n              if (listenerCount(this, 'openssh.streamlocal') && reserveChannel()) {\n                accept = () => {\n                  if (replied) return;\n                  replied = true;\n                  const chanInfo = {\n                    type: undefined,\n                    incoming: {\n                      id: localChan,\n                      window: MAX_WINDOW,\n                      packetSize: PACKET_SIZE,\n                      state: 'open'\n                    },\n                    outgoing: {\n                      id: info.sender,\n                      window: info.window,\n                      packetSize: info.packetSize,\n                      state: 'open'\n                    }\n                  };\n                  const stream = new Channel(this, chanInfo, {\n                    server: true\n                  });\n                  this._chanMgr.update(localChan, stream);\n                  proto.channelOpenConfirm(info.sender, localChan, MAX_WINDOW, PACKET_SIZE);\n                  return stream;\n                };\n                this.emit('openssh.streamlocal', accept, reject, data);\n                return;\n              }\n              break;\n            default:\n              // Automatically reject any unsupported channel open requests\n              reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;\n              if (debug) {\n                debug('Automatic rejection of unsupported incoming channel open' + ` type: ${info.type}`);\n              }\n          }\n          if (reason === undefined) {\n            reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n            if (debug) {\n              debug('Automatic rejection of unexpected incoming channel open' + ` for: ${info.type}`);\n            }\n          }\n          reject();\n        },\n        CHANNEL_OPEN_CONFIRMATION: (p, info) => {\n          const channel = this._chanMgr.get(info.recipient);\n          if (typeof channel !== 'function') return;\n          const chanInfo = {\n            type: channel.type,\n            incoming: {\n              id: info.recipient,\n              window: MAX_WINDOW,\n              packetSize: PACKET_SIZE,\n              state: 'open'\n            },\n            outgoing: {\n              id: info.sender,\n              window: info.window,\n              packetSize: info.packetSize,\n              state: 'open'\n            }\n          };\n          const instance = new Channel(this, chanInfo, {\n            server: true\n          });\n          this._chanMgr.update(info.recipient, instance);\n          channel(undefined, instance);\n        },\n        CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'function') return;\n          const info = {\n            reason,\n            description\n          };\n          onChannelOpenFailure(this, recipient, info, channel);\n        },\n        CHANNEL_DATA: (p, recipient, data) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel) return;\n          }\n\n          // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n          if (channel.incoming.window === 0) return;\n          channel.incoming.window -= data.length;\n          if (channel.push(data) === false) {\n            channel._waitChanDrain = true;\n            return;\n          }\n          if (channel.incoming.window <= WINDOW_THRESHOLD) windowAdjust(channel);\n        },\n        CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {\n          // NOOP -- should not be sent by client\n        },\n        CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel) return;\n          }\n\n          // The other side is allowing us to send `amount` more bytes of data\n          channel.outgoing.window += amount;\n          if (channel._waitWindow) {\n            channel._waitWindow = false;\n            if (channel._chunk) {\n              channel._write(channel._chunk, null, channel._chunkcb);\n            } else if (channel._chunkcb) {\n              channel._chunkcb();\n            } else if (channel._chunkErr) {\n              channel.stderr._write(channel._chunkErr, null, channel._chunkcbErr);\n            } else if (channel._chunkcbErr) {\n              channel._chunkcbErr();\n            }\n          }\n        },\n        CHANNEL_SUCCESS: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel) return;\n          }\n          if (channel._callbacks.length) channel._callbacks.shift()(false);\n        },\n        CHANNEL_FAILURE: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel) return;\n          }\n          if (channel._callbacks.length) channel._callbacks.shift()(true);\n        },\n        CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {\n          const session = this._chanMgr.get(recipient);\n          if (typeof session !== 'object' || session === null) return;\n          let replied = false;\n          let accept;\n          let reject;\n          if (session.constructor !== Session) {\n            // normal Channel instance\n            if (wantReply) proto.channelFailure(session.outgoing.id);\n            return;\n          }\n          if (wantReply) {\n            // \"real session\" requests will have custom accept behaviors\n            if (type !== 'shell' && type !== 'exec' && type !== 'subsystem') {\n              accept = () => {\n                if (replied || session._ending || session._channel) return;\n                replied = true;\n                proto.channelSuccess(session._chanInfo.outgoing.id);\n              };\n            }\n            reject = () => {\n              if (replied || session._ending || session._channel) return;\n              replied = true;\n              proto.channelFailure(session._chanInfo.outgoing.id);\n            };\n          }\n          if (session._ending) {\n            reject && reject();\n            return;\n          }\n          switch (type) {\n            // \"pre-real session start\" requests\n            case 'env':\n              if (listenerCount(session, 'env')) {\n                session.emit('env', accept, reject, {\n                  key: data.name,\n                  val: data.value\n                });\n                return;\n              }\n              break;\n            case 'pty-req':\n              if (listenerCount(session, 'pty')) {\n                session.emit('pty', accept, reject, data);\n                return;\n              }\n              break;\n            case 'window-change':\n              if (listenerCount(session, 'window-change')) session.emit('window-change', accept, reject, data);else reject && reject();\n              break;\n            case 'x11-req':\n              if (listenerCount(session, 'x11')) {\n                session.emit('x11', accept, reject, data);\n                return;\n              }\n              break;\n            // \"post-real session start\" requests\n            case 'signal':\n              if (listenerCount(session, 'signal')) {\n                session.emit('signal', accept, reject, {\n                  name: data\n                });\n                return;\n              }\n              break;\n            // XXX: is `auth-agent-req@openssh.com` really \"post-real session\n            // start\"?\n            case 'auth-agent-req@openssh.com':\n              if (listenerCount(session, 'auth-agent')) {\n                session.emit('auth-agent', accept, reject);\n                return;\n              }\n              break;\n            // \"real session start\" requests\n            case 'shell':\n              if (listenerCount(session, 'shell')) {\n                accept = () => {\n                  if (replied || session._ending || session._channel) return;\n                  replied = true;\n                  if (wantReply) proto.channelSuccess(session._chanInfo.outgoing.id);\n                  const channel = new Channel(this, session._chanInfo, {\n                    server: true\n                  });\n                  channel.subtype = session.subtype = type;\n                  session._channel = channel;\n                  return channel;\n                };\n                session.emit('shell', accept, reject);\n                return;\n              }\n              break;\n            case 'exec':\n              if (listenerCount(session, 'exec')) {\n                accept = () => {\n                  if (replied || session._ending || session._channel) return;\n                  replied = true;\n                  if (wantReply) proto.channelSuccess(session._chanInfo.outgoing.id);\n                  const channel = new Channel(this, session._chanInfo, {\n                    server: true\n                  });\n                  channel.subtype = session.subtype = type;\n                  session._channel = channel;\n                  return channel;\n                };\n                session.emit('exec', accept, reject, {\n                  command: data\n                });\n                return;\n              }\n              break;\n            case 'subsystem':\n              {\n                let useSFTP = data === 'sftp';\n                accept = () => {\n                  if (replied || session._ending || session._channel) return;\n                  replied = true;\n                  if (wantReply) proto.channelSuccess(session._chanInfo.outgoing.id);\n                  let instance;\n                  if (useSFTP) {\n                    instance = new SFTP(this, session._chanInfo, {\n                      server: true,\n                      debug\n                    });\n                  } else {\n                    instance = new Channel(this, session._chanInfo, {\n                      server: true\n                    });\n                    instance.subtype = session.subtype = `${type}:${data}`;\n                  }\n                  session._channel = instance;\n                  return instance;\n                };\n                if (data === 'sftp') {\n                  if (listenerCount(session, 'sftp')) {\n                    session.emit('sftp', accept, reject);\n                    return;\n                  }\n                  useSFTP = false;\n                }\n                if (listenerCount(session, 'subsystem')) {\n                  session.emit('subsystem', accept, reject, {\n                    name: data\n                  });\n                  return;\n                }\n                break;\n              }\n          }\n          debug && debug(`Automatic rejection of incoming channel request: ${type}`);\n          reject && reject();\n        },\n        CHANNEL_EOF: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          if (channel.constructor === Session) {\n            if (!channel._ending) {\n              channel._ending = true;\n              channel.emit('eof');\n              channel.emit('end');\n            }\n            channel = channel._channel;\n            if (!channel) return;\n          }\n          if (channel.incoming.state !== 'open') return;\n          channel.incoming.state = 'eof';\n          if (channel.readable) channel.push(null);\n        },\n        CHANNEL_CLOSE: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          if (channel.constructor === Session) {\n            channel._ending = true;\n            channel.emit('close');\n            channel = channel._channel;\n            if (!channel) return;\n          }\n          onCHANNEL_CLOSE(this, recipient, channel);\n        },\n        // Begin service/auth-related ==========================================\n        SERVICE_REQUEST: (p, service) => {\n          if (exchanges === 0 || acceptedAuthSvc || this.authenticated || service !== 'ssh-userauth') {\n            proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);\n            socket.end();\n            return;\n          }\n          acceptedAuthSvc = true;\n          proto.serviceAccept(service);\n        },\n        USERAUTH_REQUEST: (p, username, service, method, methodData) => {\n          if (exchanges === 0 || this.authenticated || authCtx && (authCtx.username !== username || authCtx.service !== service)\n          // TODO: support hostbased auth\n          || method !== 'password' && method !== 'publickey' && method !== 'hostbased' && method !== 'keyboard-interactive' && method !== 'none' || pendingAuths.length === MAX_PENDING_AUTHS) {\n            proto.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n            socket.end();\n            return;\n          } else if (service !== 'ssh-connection') {\n            proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);\n            socket.end();\n            return;\n          }\n          let ctx;\n          switch (method) {\n            case 'keyboard-interactive':\n              ctx = new KeyboardAuthContext(proto, username, service, method, methodData, onAuthDecide);\n              break;\n            case 'publickey':\n              ctx = new PKAuthContext(proto, username, service, method, methodData, onAuthDecide);\n              break;\n            case 'hostbased':\n              ctx = new HostbasedAuthContext(proto, username, service, method, methodData, onAuthDecide);\n              break;\n            case 'password':\n              if (authCtx && authCtx instanceof PwdAuthContext && authCtx._changeCb) {\n                const cb = authCtx._changeCb;\n                authCtx._changeCb = undefined;\n                cb(methodData.newPassword);\n                return;\n              }\n              ctx = new PwdAuthContext(proto, username, service, method, methodData, onAuthDecide);\n              break;\n            case 'none':\n              ctx = new AuthContext(proto, username, service, method, onAuthDecide);\n              break;\n          }\n          if (authCtx) {\n            if (!authCtx._initialResponse) {\n              return pendingAuths.push(ctx);\n            } else if (authCtx._multistep && !authCtx._finalResponse) {\n              // RFC 4252 says to silently abort the current auth request if a\n              // new auth request comes in before the final response from an\n              // auth method that requires additional request/response exchanges\n              // -- this means keyboard-interactive for now ...\n              authCtx._cleanup && authCtx._cleanup();\n              authCtx.emit('abort');\n            }\n          }\n          authCtx = ctx;\n          if (listenerCount(this, 'authentication')) this.emit('authentication', authCtx);else authCtx.reject();\n        },\n        USERAUTH_INFO_RESPONSE: (p, responses) => {\n          if (authCtx && authCtx instanceof KeyboardAuthContext) authCtx._onInfoResponse(responses);\n        },\n        // End service/auth-related ============================================\n        GLOBAL_REQUEST: (p, name, wantReply, data) => {\n          const reply = {\n            type: null,\n            buf: null\n          };\n          function setReply(type, buf) {\n            reply.type = type;\n            reply.buf = buf;\n            sendReplies();\n          }\n          if (wantReply) unsentGlobalRequestsReplies.push(reply);\n          if ((name === 'tcpip-forward' || name === 'cancel-tcpip-forward' || name === 'no-more-sessions@openssh.com' || name === 'streamlocal-forward@openssh.com' || name === 'cancel-streamlocal-forward@openssh.com') && listenerCount(this, 'request') && this.authenticated) {\n            let accept;\n            let reject;\n            if (wantReply) {\n              let replied = false;\n              accept = chosenPort => {\n                if (replied) return;\n                replied = true;\n                let bufPort;\n                if (name === 'tcpip-forward' && data.bindPort === 0 && typeof chosenPort === 'number') {\n                  bufPort = Buffer.allocUnsafe(4);\n                  writeUInt32BE(bufPort, chosenPort, 0);\n                }\n                setReply('SUCCESS', bufPort);\n              };\n              reject = () => {\n                if (replied) return;\n                replied = true;\n                setReply('FAILURE');\n              };\n            }\n            if (name === 'no-more-sessions@openssh.com') {\n              this.noMoreSessions = true;\n              accept && accept();\n              return;\n            }\n            this.emit('request', accept, reject, name, data);\n          } else if (wantReply) {\n            setReply('FAILURE');\n          }\n        }\n      }\n    });\n    socket.pause();\n    cryptoInit.then(() => {\n      proto.start();\n      socket.on('data', data => {\n        try {\n          proto.parse(data, 0, data.length);\n        } catch (ex) {\n          this.emit('error', ex);\n          try {\n            if (isWritable(socket)) socket.end();\n          } catch {}\n        }\n      });\n      socket.resume();\n    }).catch(err => {\n      this.emit('error', err);\n      try {\n        if (isWritable(socket)) socket.end();\n      } catch {}\n    });\n    socket.on('error', err => {\n      err.level = 'socket';\n      this.emit('error', err);\n    }).once('end', () => {\n      debug && debug('Socket ended');\n      proto.cleanup();\n      this.emit('end');\n    }).once('close', () => {\n      debug && debug('Socket closed');\n      proto.cleanup();\n      this.emit('close');\n      const err = new Error('No response from server');\n\n      // Simulate error for pending channels and close any open channels\n      this._chanMgr.cleanup(err);\n    });\n    const onAuthDecide = (ctx, allowed, methodsLeft, isPartial) => {\n      if (authCtx === ctx && !this.authenticated) {\n        if (allowed) {\n          authCtx = undefined;\n          this.authenticated = true;\n          proto.authSuccess();\n          pendingAuths = [];\n          this.emit('ready');\n        } else {\n          proto.authFailure(methodsLeft, isPartial);\n          if (pendingAuths.length) {\n            authCtx = pendingAuths.pop();\n            if (listenerCount(this, 'authentication')) this.emit('authentication', authCtx);else authCtx.reject();\n          }\n        }\n      }\n    };\n    function sendReplies() {\n      while (unsentGlobalRequestsReplies.length > 0 && unsentGlobalRequestsReplies[0].type) {\n        const reply = unsentGlobalRequestsReplies.shift();\n        if (reply.type === 'SUCCESS') proto.requestSuccess(reply.buf);\n        if (reply.type === 'FAILURE') proto.requestFailure();\n      }\n    }\n  }\n  end() {\n    if (this._sock && isWritable(this._sock)) {\n      this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n      this._sock.end();\n    }\n    return this;\n  }\n  x11(originAddr, originPort, cb) {\n    const opts = {\n      originAddr,\n      originPort\n    };\n    openChannel(this, 'x11', opts, cb);\n    return this;\n  }\n  forwardOut(boundAddr, boundPort, remoteAddr, remotePort, cb) {\n    const opts = {\n      boundAddr,\n      boundPort,\n      remoteAddr,\n      remotePort\n    };\n    openChannel(this, 'forwarded-tcpip', opts, cb);\n    return this;\n  }\n  openssh_forwardOutStreamLocal(socketPath, cb) {\n    const opts = {\n      socketPath\n    };\n    openChannel(this, 'forwarded-streamlocal@openssh.com', opts, cb);\n    return this;\n  }\n  rekey(cb) {\n    let error;\n    try {\n      this._protocol.rekey();\n    } catch (ex) {\n      error = ex;\n    }\n\n    // TODO: re-throw error if no callback?\n\n    if (typeof cb === 'function') {\n      if (error) process.nextTick(cb, error);else this.once('rekey', cb);\n    }\n  }\n  setNoDelay(noDelay) {\n    if (this._sock && typeof this._sock.setNoDelay === 'function') this._sock.setNoDelay(noDelay);\n    return this;\n  }\n}\nfunction openChannel(self, type, opts, cb) {\n  // Ask the client to open a channel for some purpose (e.g. a forwarded TCP\n  // connection)\n  const initWindow = MAX_WINDOW;\n  const maxPacket = PACKET_SIZE;\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  const wrapper = (err, stream) => {\n    cb(err, stream);\n  };\n  wrapper.type = type;\n  const localChan = self._chanMgr.add(wrapper);\n  if (localChan === -1) {\n    cb(new Error('No free channels available'));\n    return;\n  }\n  switch (type) {\n    case 'forwarded-tcpip':\n      self._protocol.forwardedTcpip(localChan, initWindow, maxPacket, opts);\n      break;\n    case 'x11':\n      self._protocol.x11(localChan, initWindow, maxPacket, opts);\n      break;\n    case 'forwarded-streamlocal@openssh.com':\n      self._protocol.openssh_forwardedStreamLocal(localChan, initWindow, maxPacket, opts);\n      break;\n    default:\n      throw new Error(`Unsupported channel type: ${type}`);\n  }\n}\nfunction compareNumbers(a, b) {\n  return a - b;\n}\nmodule.exports = Server;\nmodule.exports.IncomingClient = Client;","map":{"version":3,"names":["Server","netServer","require","EventEmitter","listenerCount","CHANNEL_OPEN_FAILURE","DEFAULT_CIPHER","DEFAULT_COMPRESSION","DEFAULT_KEX","DEFAULT_MAC","DEFAULT_SERVER_HOST_KEY","DISCONNECT_REASON","DISCONNECT_REASON_BY_VALUE","SUPPORTED_CIPHER","SUPPORTED_COMPRESSION","SUPPORTED_KEX","SUPPORTED_MAC","SUPPORTED_SERVER_HOST_KEY","init","cryptoInit","KexInit","parseKey","Protocol","SFTP","writeUInt32BE","Channel","MAX_WINDOW","PACKET_SIZE","windowAdjust","WINDOW_THRESHOLD","ChannelManager","generateAlgorithmList","isWritable","onChannelOpenFailure","onCHANNEL_CLOSE","MAX_PENDING_AUTHS","AuthContext","constructor","protocol","username","service","method","cb","user","_initialResponse","_finalResponse","_multistep","_cbfinal","allowed","methodsLeft","isPartial","_protocol","accept","_cleanup","reject","KeyboardAuthContext","submethods","_cb","undefined","_onInfoResponse","responses","callback","on","Error","prompt","prompts","title","instructions","Array","isArray","i","length","echo","authInfoReq","PKAuthContext","pkInfo","key","algo","keyAlgo","data","hashAlgo","signature","blob","authPKOK","prototype","call","HostbasedAuthContext","localHostname","localUsername","PwdAuthContext","password","_changeCb","requestChange","authPasswdChg","Session","client","info","localChan","type","subtype","server","_ending","_channel","_chanInfo","incoming","id","window","packetSize","state","outgoing","sender","cfg","listener","hostKeys","Object","create","hostKeyAlgoOrder","hostKeys_","cfgAlgos","algorithms","hostKeyAlgos","serverHostKey","privateKey","Buffer","isBuffer","passphrase","message","getPrivatePEM","includes","sha1Pos","indexOf","sha256Pos","sha512Pos","Infinity","sort","compareNumbers","forEach","pos","push","kex","cs","cipher","mac","hmac","compress","lang","sc","origDebug","debug","ident","from","offer","_srv","socket","_connections","maxConnections","destroy","once","debugPrefix","process","hrtime","join","msg","Client","err","emit","injectSocket","listen","arguments","address","getConnections","close","ref","unref","KEEPALIVE_CLIENT_INTERVAL","KEEPALIVE_CLIENT_COUNT_MAX","srvCfg","exchanges","acceptedAuthSvc","pendingAuths","authCtx","kaTimer","onPacket","unsentGlobalRequestsReplies","_sock","_chanMgr","_debug","noMoreSessions","authenticated","onClientPreHeaderError","DEBUG_HANDLER","p","display","JSON","stringify","kaIntvl","keepaliveInterval","isFinite","kaCountMax","keepaliveCountMax","kaCurCount","onClose","clearInterval","setInterval","level","end","proto","ping","refresh","greeting","banner","onWrite","write","onError","_destruct","removeAllListeners","onHeader","header","removeListener","ip","remoteAddress","family","remoteFamily","port","remotePort","disconnect","BY_APPLICATION","onHandshakeComplete","negotiated","messageHandlers","DEBUG","DISCONNECT","reason","desc","code","CHANNEL_OPEN","reasonCode","ADMINISTRATIVELY_PROHIBITED","channelOpenFail","replied","RESOURCE_SHORTAGE","CONNECT_FAILED","remove","reserveChannel","add","instance","update","channelOpenConfirm","chanInfo","stream","UNKNOWN_CHANNEL_TYPE","CHANNEL_OPEN_CONFIRMATION","channel","get","recipient","description","CHANNEL_DATA","_waitChanDrain","CHANNEL_EXTENDED_DATA","CHANNEL_WINDOW_ADJUST","amount","_waitWindow","_chunk","_write","_chunkcb","_chunkErr","stderr","_chunkcbErr","CHANNEL_SUCCESS","_callbacks","shift","CHANNEL_FAILURE","CHANNEL_REQUEST","wantReply","session","channelFailure","channelSuccess","name","val","value","command","useSFTP","CHANNEL_EOF","readable","CHANNEL_CLOSE","SERVICE_REQUEST","SERVICE_NOT_AVAILABLE","serviceAccept","USERAUTH_REQUEST","methodData","PROTOCOL_ERROR","ctx","onAuthDecide","newPassword","USERAUTH_INFO_RESPONSE","GLOBAL_REQUEST","reply","buf","setReply","sendReplies","chosenPort","bufPort","bindPort","allocUnsafe","pause","then","start","parse","ex","resume","catch","cleanup","authSuccess","authFailure","pop","requestSuccess","requestFailure","x11","originAddr","originPort","opts","openChannel","forwardOut","boundAddr","boundPort","remoteAddr","openssh_forwardOutStreamLocal","socketPath","rekey","error","nextTick","setNoDelay","noDelay","self","initWindow","maxPacket","wrapper","forwardedTcpip","openssh_forwardedStreamLocal","a","b","module","exports","IncomingClient"],"sources":["/home/user/node_modules/ssh2/lib/server.js"],"sourcesContent":["// TODO:\n//   * convert listenerCount() usage to emit() return value checking?\n//   * emit error when connection severed early (e.g. before handshake)\n//   * add '.connected' or similar property to connection objects to allow\n//     immediate connection status checking\n'use strict';\n\nconst { Server: netServer } = require('net');\nconst EventEmitter = require('events');\nconst { listenerCount } = EventEmitter;\n\nconst {\n  CHANNEL_OPEN_FAILURE,\n  DEFAULT_CIPHER,\n  DEFAULT_COMPRESSION,\n  DEFAULT_KEX,\n  DEFAULT_MAC,\n  DEFAULT_SERVER_HOST_KEY,\n  DISCONNECT_REASON,\n  DISCONNECT_REASON_BY_VALUE,\n  SUPPORTED_CIPHER,\n  SUPPORTED_COMPRESSION,\n  SUPPORTED_KEX,\n  SUPPORTED_MAC,\n  SUPPORTED_SERVER_HOST_KEY,\n} = require('./protocol/constants.js');\nconst { init: cryptoInit } = require('./protocol/crypto.js');\nconst { KexInit } = require('./protocol/kex.js');\nconst { parseKey } = require('./protocol/keyParser.js');\nconst Protocol = require('./protocol/Protocol.js');\nconst { SFTP } = require('./protocol/SFTP.js');\nconst { writeUInt32BE } = require('./protocol/utils.js');\n\nconst {\n  Channel,\n  MAX_WINDOW,\n  PACKET_SIZE,\n  windowAdjust,\n  WINDOW_THRESHOLD,\n} = require('./Channel.js');\n\nconst {\n  ChannelManager,\n  generateAlgorithmList,\n  isWritable,\n  onChannelOpenFailure,\n  onCHANNEL_CLOSE,\n} = require('./utils.js');\n\nconst MAX_PENDING_AUTHS = 10;\n\nclass AuthContext extends EventEmitter {\n  constructor(protocol, username, service, method, cb) {\n    super();\n\n    this.username = this.user = username;\n    this.service = service;\n    this.method = method;\n    this._initialResponse = false;\n    this._finalResponse = false;\n    this._multistep = false;\n    this._cbfinal = (allowed, methodsLeft, isPartial) => {\n      if (!this._finalResponse) {\n        this._finalResponse = true;\n        cb(this, allowed, methodsLeft, isPartial);\n      }\n    };\n    this._protocol = protocol;\n  }\n\n  accept() {\n    this._cleanup && this._cleanup();\n    this._initialResponse = true;\n    this._cbfinal(true);\n  }\n  reject(methodsLeft, isPartial) {\n    this._cleanup && this._cleanup();\n    this._initialResponse = true;\n    this._cbfinal(false, methodsLeft, isPartial);\n  }\n}\n\n\nclass KeyboardAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, submethods, cb) {\n    super(protocol, username, service, method, cb);\n\n    this._multistep = true;\n\n    this._cb = undefined;\n    this._onInfoResponse = (responses) => {\n      const callback = this._cb;\n      if (callback) {\n        this._cb = undefined;\n        callback(responses);\n      }\n    };\n    this.submethods = submethods;\n    this.on('abort', () => {\n      this._cb && this._cb(new Error('Authentication request aborted'));\n    });\n  }\n\n  prompt(prompts, title, instructions, cb) {\n    if (!Array.isArray(prompts))\n      prompts = [ prompts ];\n\n    if (typeof title === 'function') {\n      cb = title;\n      title = instructions = undefined;\n    } else if (typeof instructions === 'function') {\n      cb = instructions;\n      instructions = undefined;\n    } else if (typeof cb !== 'function') {\n      cb = undefined;\n    }\n\n    for (let i = 0; i < prompts.length; ++i) {\n      if (typeof prompts[i] === 'string') {\n        prompts[i] = {\n          prompt: prompts[i],\n          echo: true\n        };\n      }\n    }\n\n    this._cb = cb;\n    this._initialResponse = true;\n\n    this._protocol.authInfoReq(title, instructions, prompts);\n  }\n}\n\nclass PKAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, pkInfo, cb) {\n    super(protocol, username, service, method, cb);\n\n    this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };\n    this.hashAlgo = pkInfo.hashAlgo;\n    this.signature = pkInfo.signature;\n    this.blob = pkInfo.blob;\n  }\n\n  accept() {\n    if (!this.signature) {\n      this._initialResponse = true;\n      this._protocol.authPKOK(this.key.algo, this.key.data);\n    } else {\n      AuthContext.prototype.accept.call(this);\n    }\n  }\n}\n\nclass HostbasedAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, pkInfo, cb) {\n    super(protocol, username, service, method, cb);\n\n    this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };\n    this.hashAlgo = pkInfo.hashAlgo;\n    this.signature = pkInfo.signature;\n    this.blob = pkInfo.blob;\n    this.localHostname = pkInfo.localHostname;\n    this.localUsername = pkInfo.localUsername;\n  }\n}\n\nclass PwdAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, password, cb) {\n    super(protocol, username, service, method, cb);\n\n    this.password = password;\n    this._changeCb = undefined;\n  }\n\n  requestChange(prompt, cb) {\n    if (this._changeCb)\n      throw new Error('Change request already in progress');\n    if (typeof prompt !== 'string')\n      throw new Error('prompt argument must be a string');\n    if (typeof cb !== 'function')\n      throw new Error('Callback argument must be a function');\n    this._changeCb = cb;\n    this._protocol.authPasswdChg(prompt);\n  }\n}\n\n\nclass Session extends EventEmitter {\n  constructor(client, info, localChan) {\n    super();\n\n    this.type = 'session';\n    this.subtype = undefined;\n    this.server = true;\n    this._ending = false;\n    this._channel = undefined;\n    this._chanInfo = {\n      type: 'session',\n      incoming: {\n        id: localChan,\n        window: MAX_WINDOW,\n        packetSize: PACKET_SIZE,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n  }\n}\n\n\nclass Server extends EventEmitter {\n  constructor(cfg, listener) {\n    super();\n\n    if (typeof cfg !== 'object' || cfg === null)\n      throw new Error('Missing configuration object');\n\n    const hostKeys = Object.create(null);\n    const hostKeyAlgoOrder = [];\n\n    const hostKeys_ = cfg.hostKeys;\n    if (!Array.isArray(hostKeys_))\n      throw new Error('hostKeys must be an array');\n\n    const cfgAlgos = (\n      typeof cfg.algorithms === 'object' && cfg.algorithms !== null\n      ? cfg.algorithms\n      : {}\n    );\n\n    const hostKeyAlgos = generateAlgorithmList(\n      cfgAlgos.serverHostKey,\n      DEFAULT_SERVER_HOST_KEY,\n      SUPPORTED_SERVER_HOST_KEY\n    );\n    for (let i = 0; i < hostKeys_.length; ++i) {\n      let privateKey;\n      if (Buffer.isBuffer(hostKeys_[i]) || typeof hostKeys_[i] === 'string')\n        privateKey = parseKey(hostKeys_[i]);\n      else\n        privateKey = parseKey(hostKeys_[i].key, hostKeys_[i].passphrase);\n\n      if (privateKey instanceof Error)\n        throw new Error(`Cannot parse privateKey: ${privateKey.message}`);\n\n      if (Array.isArray(privateKey)) {\n        // OpenSSH's newer format only stores 1 key for now\n        privateKey = privateKey[0];\n      }\n\n      if (privateKey.getPrivatePEM() === null)\n        throw new Error('privateKey value contains an invalid private key');\n\n      // Discard key if we already found a key of the same type\n      if (hostKeyAlgoOrder.includes(privateKey.type))\n        continue;\n\n      if (privateKey.type === 'ssh-rsa') {\n        // SSH supports multiple signature hashing algorithms for RSA, so we add\n        // the algorithms in the desired order\n        let sha1Pos = hostKeyAlgos.indexOf('ssh-rsa');\n        const sha256Pos = hostKeyAlgos.indexOf('rsa-sha2-256');\n        const sha512Pos = hostKeyAlgos.indexOf('rsa-sha2-512');\n        if (sha1Pos === -1) {\n          // Fall back to giving SHA1 the lowest priority\n          sha1Pos = Infinity;\n        }\n        [sha1Pos, sha256Pos, sha512Pos].sort(compareNumbers).forEach((pos) => {\n          if (pos === -1)\n            return;\n\n          let type;\n          switch (pos) {\n            case sha1Pos: type = 'ssh-rsa'; break;\n            case sha256Pos: type = 'rsa-sha2-256'; break;\n            case sha512Pos: type = 'rsa-sha2-512'; break;\n            default: return;\n          }\n\n          // Store same RSA key under each hash algorithm name for convenience\n          hostKeys[type] = privateKey;\n\n          hostKeyAlgoOrder.push(type);\n        });\n      } else {\n        hostKeys[privateKey.type] = privateKey;\n        hostKeyAlgoOrder.push(privateKey.type);\n      }\n    }\n\n    const algorithms = {\n      kex: generateAlgorithmList(cfgAlgos.kex, DEFAULT_KEX, SUPPORTED_KEX),\n      serverHostKey: hostKeyAlgoOrder,\n      cs: {\n        cipher: generateAlgorithmList(\n                  cfgAlgos.cipher,\n                  DEFAULT_CIPHER,\n                  SUPPORTED_CIPHER\n                ),\n        mac: generateAlgorithmList(cfgAlgos.hmac, DEFAULT_MAC, SUPPORTED_MAC),\n        compress: generateAlgorithmList(\n                    cfgAlgos.compress,\n                    DEFAULT_COMPRESSION,\n                    SUPPORTED_COMPRESSION\n                  ),\n        lang: [],\n      },\n      sc: undefined,\n    };\n    algorithms.sc = algorithms.cs;\n\n    if (typeof listener === 'function')\n      this.on('connection', listener);\n\n    const origDebug = (typeof cfg.debug === 'function' ? cfg.debug : undefined);\n    const ident = (cfg.ident ? Buffer.from(cfg.ident) : undefined);\n    const offer = new KexInit(algorithms);\n\n    this._srv = new netServer((socket) => {\n      if (this._connections >= this.maxConnections) {\n        socket.destroy();\n        return;\n      }\n      ++this._connections;\n      socket.once('close', () => {\n        --this._connections;\n      });\n\n      let debug;\n      if (origDebug) {\n        // Prepend debug output with a unique identifier in case there are\n        // multiple clients connected at the same time\n        const debugPrefix = `[${process.hrtime().join('.')}] `;\n        debug = (msg) => {\n          origDebug(`${debugPrefix}${msg}`);\n        };\n      }\n\n      // eslint-disable-next-line no-use-before-define\n      new Client(socket, hostKeys, ident, offer, debug, this, cfg);\n    }).on('error', (err) => {\n      this.emit('error', err);\n    }).on('listening', () => {\n      this.emit('listening');\n    }).on('close', () => {\n      this.emit('close');\n    });\n    this._connections = 0;\n    this.maxConnections = Infinity;\n  }\n\n  injectSocket(socket) {\n    this._srv.emit('connection', socket);\n  }\n\n  listen(...args) {\n    this._srv.listen(...args);\n    return this;\n  }\n\n  address() {\n    return this._srv.address();\n  }\n\n  getConnections(cb) {\n    this._srv.getConnections(cb);\n    return this;\n  }\n\n  close(cb) {\n    this._srv.close(cb);\n    return this;\n  }\n\n  ref() {\n    this._srv.ref();\n    return this;\n  }\n\n  unref() {\n    this._srv.unref();\n    return this;\n  }\n}\nServer.KEEPALIVE_CLIENT_INTERVAL = 15000;\nServer.KEEPALIVE_CLIENT_COUNT_MAX = 3;\n\n\nclass Client extends EventEmitter {\n  constructor(socket, hostKeys, ident, offer, debug, server, srvCfg) {\n    super();\n\n    let exchanges = 0;\n    let acceptedAuthSvc = false;\n    let pendingAuths = [];\n    let authCtx;\n    let kaTimer;\n    let onPacket;\n    const unsentGlobalRequestsReplies = [];\n    this._sock = socket;\n    this._chanMgr = new ChannelManager(this);\n    this._debug = debug;\n    this.noMoreSessions = false;\n    this.authenticated = false;\n\n    // Silence pre-header errors\n    function onClientPreHeaderError(err) {}\n    this.on('error', onClientPreHeaderError);\n\n    const DEBUG_HANDLER = (!debug ? undefined : (p, display, msg) => {\n      debug(`Debug output from client: ${JSON.stringify(msg)}`);\n    });\n\n    const kaIntvl = (\n      typeof srvCfg.keepaliveInterval === 'number'\n        && isFinite(srvCfg.keepaliveInterval)\n        && srvCfg.keepaliveInterval > 0\n      ? srvCfg.keepaliveInterval\n      : (\n        typeof Server.KEEPALIVE_CLIENT_INTERVAL === 'number'\n          && isFinite(Server.KEEPALIVE_CLIENT_INTERVAL)\n          && Server.KEEPALIVE_CLIENT_INTERVAL > 0\n        ? Server.KEEPALIVE_CLIENT_INTERVAL\n        : -1\n      )\n    );\n    const kaCountMax = (\n      typeof srvCfg.keepaliveCountMax === 'number'\n        && isFinite(srvCfg.keepaliveCountMax)\n        && srvCfg.keepaliveCountMax >= 0\n      ? srvCfg.keepaliveCountMax\n      : (\n        typeof Server.KEEPALIVE_CLIENT_COUNT_MAX === 'number'\n          && isFinite(Server.KEEPALIVE_CLIENT_COUNT_MAX)\n          && Server.KEEPALIVE_CLIENT_COUNT_MAX >= 0\n        ? Server.KEEPALIVE_CLIENT_COUNT_MAX\n        : -1\n      )\n    );\n    let kaCurCount = 0;\n    if (kaIntvl !== -1 && kaCountMax !== -1) {\n      this.once('ready', () => {\n        const onClose = () => {\n          clearInterval(kaTimer);\n        };\n        this.on('close', onClose).on('end', onClose);\n        kaTimer = setInterval(() => {\n          if (++kaCurCount > kaCountMax) {\n            clearInterval(kaTimer);\n            const err = new Error('Keepalive timeout');\n            err.level = 'client-timeout';\n            this.emit('error', err);\n            this.end();\n          } else {\n            // XXX: if the server ever starts sending real global requests to\n            //      the client, we will need to add a dummy callback here to\n            //      keep the correct reply order\n            proto.ping();\n          }\n        }, kaIntvl);\n      });\n      // TODO: re-verify keepalive behavior with OpenSSH\n      onPacket = () => {\n        kaTimer && kaTimer.refresh();\n        kaCurCount = 0;\n      };\n    }\n\n    const proto = this._protocol = new Protocol({\n      server: true,\n      hostKeys,\n      ident,\n      offer,\n      onPacket,\n      greeting: srvCfg.greeting,\n      banner: srvCfg.banner,\n      onWrite: (data) => {\n        if (isWritable(socket))\n          socket.write(data);\n      },\n      onError: (err) => {\n        if (!proto._destruct)\n          socket.removeAllListeners('data');\n        this.emit('error', err);\n        try {\n          socket.end();\n        } catch {}\n      },\n      onHeader: (header) => {\n        this.removeListener('error', onClientPreHeaderError);\n\n        const info = {\n          ip: socket.remoteAddress,\n          family: socket.remoteFamily,\n          port: socket.remotePort,\n          header,\n        };\n        if (!server.emit('connection', this, info)) {\n          // auto reject\n          proto.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n          socket.end();\n          return;\n        }\n\n        if (header.greeting)\n          this.emit('greeting', header.greeting);\n      },\n      onHandshakeComplete: (negotiated) => {\n        if (++exchanges > 1)\n          this.emit('rekey');\n        this.emit('handshake', negotiated);\n      },\n      debug,\n      messageHandlers: {\n        DEBUG: DEBUG_HANDLER,\n        DISCONNECT: (p, reason, desc) => {\n          if (reason !== DISCONNECT_REASON.BY_APPLICATION) {\n            if (!desc) {\n              desc = DISCONNECT_REASON_BY_VALUE[reason];\n              if (desc === undefined)\n                desc = `Unexpected disconnection reason: ${reason}`;\n            }\n            const err = new Error(desc);\n            err.code = reason;\n            this.emit('error', err);\n          }\n          socket.end();\n        },\n        CHANNEL_OPEN: (p, info) => {\n          // Handle incoming requests from client\n\n          // Do early reject in some cases to prevent wasteful channel\n          // allocation\n          if ((info.type === 'session' && this.noMoreSessions)\n              || !this.authenticated) {\n            const reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n            return proto.channelOpenFail(info.sender, reasonCode);\n          }\n\n          let localChan = -1;\n          let reason;\n          let replied = false;\n\n          let accept;\n          const reject = () => {\n            if (replied)\n              return;\n            replied = true;\n\n            if (reason === undefined) {\n              if (localChan === -1)\n                reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n              else\n                reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;\n            }\n\n            if (localChan !== -1)\n              this._chanMgr.remove(localChan);\n            proto.channelOpenFail(info.sender, reason, '');\n          };\n          const reserveChannel = () => {\n            localChan = this._chanMgr.add();\n\n            if (localChan === -1) {\n              reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n              if (debug) {\n                debug('Automatic rejection of incoming channel open: '\n                        + 'no channels available');\n              }\n            }\n\n            return (localChan !== -1);\n          };\n\n          const data = info.data;\n          switch (info.type) {\n            case 'session':\n              if (listenerCount(this, 'session') && reserveChannel()) {\n                accept = () => {\n                  if (replied)\n                    return;\n                  replied = true;\n\n                  const instance = new Session(this, info, localChan);\n                  this._chanMgr.update(localChan, instance);\n\n                  proto.channelOpenConfirm(info.sender,\n                                           localChan,\n                                           MAX_WINDOW,\n                                           PACKET_SIZE);\n\n                  return instance;\n                };\n\n                this.emit('session', accept, reject);\n                return;\n              }\n              break;\n            case 'direct-tcpip':\n              if (listenerCount(this, 'tcpip') && reserveChannel()) {\n                accept = () => {\n                  if (replied)\n                    return;\n                  replied = true;\n\n                  const chanInfo = {\n                    type: undefined,\n                    incoming: {\n                      id: localChan,\n                      window: MAX_WINDOW,\n                      packetSize: PACKET_SIZE,\n                      state: 'open'\n                    },\n                    outgoing: {\n                      id: info.sender,\n                      window: info.window,\n                      packetSize: info.packetSize,\n                      state: 'open'\n                    }\n                  };\n\n                  const stream = new Channel(this, chanInfo, { server: true });\n                  this._chanMgr.update(localChan, stream);\n\n                  proto.channelOpenConfirm(info.sender,\n                                           localChan,\n                                           MAX_WINDOW,\n                                           PACKET_SIZE);\n\n                  return stream;\n                };\n\n                this.emit('tcpip', accept, reject, data);\n                return;\n              }\n              break;\n            case 'direct-streamlocal@openssh.com':\n              if (listenerCount(this, 'openssh.streamlocal')\n                  && reserveChannel()) {\n                accept = () => {\n                  if (replied)\n                    return;\n                  replied = true;\n\n                  const chanInfo = {\n                    type: undefined,\n                    incoming: {\n                      id: localChan,\n                      window: MAX_WINDOW,\n                      packetSize: PACKET_SIZE,\n                      state: 'open'\n                    },\n                    outgoing: {\n                      id: info.sender,\n                      window: info.window,\n                      packetSize: info.packetSize,\n                      state: 'open'\n                    }\n                  };\n\n                  const stream = new Channel(this, chanInfo, { server: true });\n                  this._chanMgr.update(localChan, stream);\n\n                  proto.channelOpenConfirm(info.sender,\n                                           localChan,\n                                           MAX_WINDOW,\n                                           PACKET_SIZE);\n\n                  return stream;\n                };\n\n                this.emit('openssh.streamlocal', accept, reject, data);\n                return;\n              }\n              break;\n            default:\n              // Automatically reject any unsupported channel open requests\n              reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;\n              if (debug) {\n                debug('Automatic rejection of unsupported incoming channel open'\n                        + ` type: ${info.type}`);\n              }\n          }\n\n          if (reason === undefined) {\n            reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n            if (debug) {\n              debug('Automatic rejection of unexpected incoming channel open'\n                      + ` for: ${info.type}`);\n            }\n          }\n\n          reject();\n        },\n        CHANNEL_OPEN_CONFIRMATION: (p, info) => {\n          const channel = this._chanMgr.get(info.recipient);\n          if (typeof channel !== 'function')\n            return;\n\n          const chanInfo = {\n            type: channel.type,\n            incoming: {\n              id: info.recipient,\n              window: MAX_WINDOW,\n              packetSize: PACKET_SIZE,\n              state: 'open'\n            },\n            outgoing: {\n              id: info.sender,\n              window: info.window,\n              packetSize: info.packetSize,\n              state: 'open'\n            }\n          };\n\n          const instance = new Channel(this, chanInfo, { server: true });\n          this._chanMgr.update(info.recipient, instance);\n          channel(undefined, instance);\n        },\n        CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'function')\n            return;\n\n          const info = { reason, description };\n          onChannelOpenFailure(this, recipient, info, channel);\n        },\n        CHANNEL_DATA: (p, recipient, data) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel)\n              return;\n          }\n\n          // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n          if (channel.incoming.window === 0)\n            return;\n\n          channel.incoming.window -= data.length;\n\n          if (channel.push(data) === false) {\n            channel._waitChanDrain = true;\n            return;\n          }\n\n          if (channel.incoming.window <= WINDOW_THRESHOLD)\n            windowAdjust(channel);\n        },\n        CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {\n          // NOOP -- should not be sent by client\n        },\n        CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel)\n              return;\n          }\n\n          // The other side is allowing us to send `amount` more bytes of data\n          channel.outgoing.window += amount;\n\n          if (channel._waitWindow) {\n            channel._waitWindow = false;\n\n            if (channel._chunk) {\n              channel._write(channel._chunk, null, channel._chunkcb);\n            } else if (channel._chunkcb) {\n              channel._chunkcb();\n            } else if (channel._chunkErr) {\n              channel.stderr._write(channel._chunkErr,\n                                    null,\n                                    channel._chunkcbErr);\n            } else if (channel._chunkcbErr) {\n              channel._chunkcbErr();\n            }\n          }\n        },\n        CHANNEL_SUCCESS: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel)\n              return;\n          }\n\n          if (channel._callbacks.length)\n            channel._callbacks.shift()(false);\n        },\n        CHANNEL_FAILURE: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel)\n              return;\n          }\n\n          if (channel._callbacks.length)\n            channel._callbacks.shift()(true);\n        },\n        CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {\n          const session = this._chanMgr.get(recipient);\n          if (typeof session !== 'object' || session === null)\n            return;\n\n          let replied = false;\n          let accept;\n          let reject;\n\n          if (session.constructor !== Session) {\n            // normal Channel instance\n            if (wantReply)\n              proto.channelFailure(session.outgoing.id);\n            return;\n          }\n\n          if (wantReply) {\n            // \"real session\" requests will have custom accept behaviors\n            if (type !== 'shell'\n                && type !== 'exec'\n                && type !== 'subsystem') {\n              accept = () => {\n                if (replied || session._ending || session._channel)\n                  return;\n                replied = true;\n\n                proto.channelSuccess(session._chanInfo.outgoing.id);\n              };\n            }\n\n            reject = () => {\n              if (replied || session._ending || session._channel)\n                return;\n              replied = true;\n\n              proto.channelFailure(session._chanInfo.outgoing.id);\n            };\n          }\n\n          if (session._ending) {\n            reject && reject();\n            return;\n          }\n\n          switch (type) {\n            // \"pre-real session start\" requests\n            case 'env':\n              if (listenerCount(session, 'env')) {\n                session.emit('env', accept, reject, {\n                  key: data.name,\n                  val: data.value\n                });\n                return;\n              }\n              break;\n            case 'pty-req':\n              if (listenerCount(session, 'pty')) {\n                session.emit('pty', accept, reject, data);\n                return;\n              }\n              break;\n            case 'window-change':\n              if (listenerCount(session, 'window-change'))\n                session.emit('window-change', accept, reject, data);\n              else\n                reject && reject();\n              break;\n            case 'x11-req':\n              if (listenerCount(session, 'x11')) {\n                session.emit('x11', accept, reject, data);\n                return;\n              }\n              break;\n            // \"post-real session start\" requests\n            case 'signal':\n              if (listenerCount(session, 'signal')) {\n                session.emit('signal', accept, reject, {\n                  name: data\n                });\n                return;\n              }\n              break;\n            // XXX: is `auth-agent-req@openssh.com` really \"post-real session\n            // start\"?\n            case 'auth-agent-req@openssh.com':\n              if (listenerCount(session, 'auth-agent')) {\n                session.emit('auth-agent', accept, reject);\n                return;\n              }\n              break;\n            // \"real session start\" requests\n            case 'shell':\n              if (listenerCount(session, 'shell')) {\n                accept = () => {\n                  if (replied || session._ending || session._channel)\n                    return;\n                  replied = true;\n\n                  if (wantReply)\n                    proto.channelSuccess(session._chanInfo.outgoing.id);\n\n                  const channel = new Channel(\n                    this, session._chanInfo, { server: true }\n                  );\n\n                  channel.subtype = session.subtype = type;\n                  session._channel = channel;\n\n                  return channel;\n                };\n\n                session.emit('shell', accept, reject);\n                return;\n              }\n              break;\n            case 'exec':\n              if (listenerCount(session, 'exec')) {\n                accept = () => {\n                  if (replied || session._ending || session._channel)\n                    return;\n                  replied = true;\n\n                  if (wantReply)\n                    proto.channelSuccess(session._chanInfo.outgoing.id);\n\n                  const channel = new Channel(\n                    this, session._chanInfo, { server: true }\n                  );\n\n                  channel.subtype = session.subtype = type;\n                  session._channel = channel;\n\n                  return channel;\n                };\n\n                session.emit('exec', accept, reject, {\n                  command: data\n                });\n                return;\n              }\n              break;\n            case 'subsystem': {\n              let useSFTP = (data === 'sftp');\n              accept = () => {\n                if (replied || session._ending || session._channel)\n                  return;\n                replied = true;\n\n                if (wantReply)\n                  proto.channelSuccess(session._chanInfo.outgoing.id);\n\n                let instance;\n                if (useSFTP) {\n                  instance = new SFTP(this, session._chanInfo, {\n                    server: true,\n                    debug,\n                  });\n                } else {\n                  instance = new Channel(\n                    this, session._chanInfo, { server: true }\n                  );\n                  instance.subtype =\n                    session.subtype = `${type}:${data}`;\n                }\n                session._channel = instance;\n\n                return instance;\n              };\n\n              if (data === 'sftp') {\n                if (listenerCount(session, 'sftp')) {\n                  session.emit('sftp', accept, reject);\n                  return;\n                }\n                useSFTP = false;\n              }\n              if (listenerCount(session, 'subsystem')) {\n                session.emit('subsystem', accept, reject, {\n                  name: data\n                });\n                return;\n              }\n              break;\n            }\n          }\n          debug && debug(\n            `Automatic rejection of incoming channel request: ${type}`\n          );\n          reject && reject();\n        },\n        CHANNEL_EOF: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          if (channel.constructor === Session) {\n            if (!channel._ending) {\n              channel._ending = true;\n              channel.emit('eof');\n              channel.emit('end');\n            }\n            channel = channel._channel;\n            if (!channel)\n              return;\n          }\n\n          if (channel.incoming.state !== 'open')\n            return;\n          channel.incoming.state = 'eof';\n\n          if (channel.readable)\n            channel.push(null);\n        },\n        CHANNEL_CLOSE: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null)\n            return;\n\n          if (channel.constructor === Session) {\n            channel._ending = true;\n            channel.emit('close');\n            channel = channel._channel;\n            if (!channel)\n              return;\n          }\n\n          onCHANNEL_CLOSE(this, recipient, channel);\n        },\n        // Begin service/auth-related ==========================================\n        SERVICE_REQUEST: (p, service) => {\n          if (exchanges === 0\n              || acceptedAuthSvc\n              || this.authenticated\n              || service !== 'ssh-userauth') {\n            proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);\n            socket.end();\n            return;\n          }\n\n          acceptedAuthSvc = true;\n          proto.serviceAccept(service);\n        },\n        USERAUTH_REQUEST: (p, username, service, method, methodData) => {\n          if (exchanges === 0\n              || this.authenticated\n              || (authCtx\n                  && (authCtx.username !== username\n                      || authCtx.service !== service))\n                // TODO: support hostbased auth\n              || (method !== 'password'\n                  && method !== 'publickey'\n                  && method !== 'hostbased'\n                  && method !== 'keyboard-interactive'\n                  && method !== 'none')\n              || pendingAuths.length === MAX_PENDING_AUTHS) {\n            proto.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n            socket.end();\n            return;\n          } else if (service !== 'ssh-connection') {\n            proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);\n            socket.end();\n            return;\n          }\n\n          let ctx;\n          switch (method) {\n            case 'keyboard-interactive':\n              ctx = new KeyboardAuthContext(proto, username, service, method,\n                                            methodData, onAuthDecide);\n              break;\n            case 'publickey':\n              ctx = new PKAuthContext(proto, username, service, method,\n                                      methodData, onAuthDecide);\n              break;\n            case 'hostbased':\n              ctx = new HostbasedAuthContext(proto, username, service, method,\n                                             methodData, onAuthDecide);\n              break;\n            case 'password':\n              if (authCtx\n                  && authCtx instanceof PwdAuthContext\n                  && authCtx._changeCb) {\n                const cb = authCtx._changeCb;\n                authCtx._changeCb = undefined;\n                cb(methodData.newPassword);\n                return;\n              }\n              ctx = new PwdAuthContext(proto, username, service, method,\n                                       methodData, onAuthDecide);\n              break;\n            case 'none':\n              ctx = new AuthContext(proto, username, service, method,\n                                    onAuthDecide);\n              break;\n          }\n\n          if (authCtx) {\n            if (!authCtx._initialResponse) {\n              return pendingAuths.push(ctx);\n            } else if (authCtx._multistep && !authCtx._finalResponse) {\n              // RFC 4252 says to silently abort the current auth request if a\n              // new auth request comes in before the final response from an\n              // auth method that requires additional request/response exchanges\n              // -- this means keyboard-interactive for now ...\n              authCtx._cleanup && authCtx._cleanup();\n              authCtx.emit('abort');\n            }\n          }\n\n          authCtx = ctx;\n\n          if (listenerCount(this, 'authentication'))\n            this.emit('authentication', authCtx);\n          else\n            authCtx.reject();\n        },\n        USERAUTH_INFO_RESPONSE: (p, responses) => {\n          if (authCtx && authCtx instanceof KeyboardAuthContext)\n            authCtx._onInfoResponse(responses);\n        },\n        // End service/auth-related ============================================\n        GLOBAL_REQUEST: (p, name, wantReply, data) => {\n          const reply = {\n            type: null,\n            buf: null\n          };\n\n          function setReply(type, buf) {\n            reply.type = type;\n            reply.buf = buf;\n            sendReplies();\n          }\n\n          if (wantReply)\n            unsentGlobalRequestsReplies.push(reply);\n\n          if ((name === 'tcpip-forward'\n               || name === 'cancel-tcpip-forward'\n               || name === 'no-more-sessions@openssh.com'\n               || name === 'streamlocal-forward@openssh.com'\n               || name === 'cancel-streamlocal-forward@openssh.com')\n              && listenerCount(this, 'request')\n              && this.authenticated) {\n            let accept;\n            let reject;\n\n            if (wantReply) {\n              let replied = false;\n              accept = (chosenPort) => {\n                if (replied)\n                  return;\n                replied = true;\n                let bufPort;\n                if (name === 'tcpip-forward'\n                    && data.bindPort === 0\n                    && typeof chosenPort === 'number') {\n                  bufPort = Buffer.allocUnsafe(4);\n                  writeUInt32BE(bufPort, chosenPort, 0);\n                }\n                setReply('SUCCESS', bufPort);\n              };\n              reject = () => {\n                if (replied)\n                  return;\n                replied = true;\n                setReply('FAILURE');\n              };\n            }\n\n            if (name === 'no-more-sessions@openssh.com') {\n              this.noMoreSessions = true;\n              accept && accept();\n              return;\n            }\n\n            this.emit('request', accept, reject, name, data);\n          } else if (wantReply) {\n            setReply('FAILURE');\n          }\n        },\n      },\n    });\n\n    socket.pause();\n    cryptoInit.then(() => {\n      proto.start();\n      socket.on('data', (data) => {\n        try {\n          proto.parse(data, 0, data.length);\n        } catch (ex) {\n          this.emit('error', ex);\n          try {\n            if (isWritable(socket))\n              socket.end();\n          } catch {}\n        }\n      });\n      socket.resume();\n    }).catch((err) => {\n      this.emit('error', err);\n      try {\n        if (isWritable(socket))\n          socket.end();\n      } catch {}\n    });\n    socket.on('error', (err) => {\n      err.level = 'socket';\n      this.emit('error', err);\n    }).once('end', () => {\n      debug && debug('Socket ended');\n      proto.cleanup();\n      this.emit('end');\n    }).once('close', () => {\n      debug && debug('Socket closed');\n      proto.cleanup();\n      this.emit('close');\n\n      const err = new Error('No response from server');\n\n      // Simulate error for pending channels and close any open channels\n      this._chanMgr.cleanup(err);\n    });\n\n    const onAuthDecide = (ctx, allowed, methodsLeft, isPartial) => {\n      if (authCtx === ctx && !this.authenticated) {\n        if (allowed) {\n          authCtx = undefined;\n          this.authenticated = true;\n          proto.authSuccess();\n          pendingAuths = [];\n          this.emit('ready');\n        } else {\n          proto.authFailure(methodsLeft, isPartial);\n          if (pendingAuths.length) {\n            authCtx = pendingAuths.pop();\n            if (listenerCount(this, 'authentication'))\n              this.emit('authentication', authCtx);\n            else\n              authCtx.reject();\n          }\n        }\n      }\n    };\n\n    function sendReplies() {\n      while (unsentGlobalRequestsReplies.length > 0\n             && unsentGlobalRequestsReplies[0].type) {\n        const reply = unsentGlobalRequestsReplies.shift();\n        if (reply.type === 'SUCCESS')\n          proto.requestSuccess(reply.buf);\n        if (reply.type === 'FAILURE')\n          proto.requestFailure();\n      }\n    }\n  }\n\n  end() {\n    if (this._sock && isWritable(this._sock)) {\n      this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n      this._sock.end();\n    }\n    return this;\n  }\n\n  x11(originAddr, originPort, cb) {\n    const opts = { originAddr, originPort };\n    openChannel(this, 'x11', opts, cb);\n    return this;\n  }\n\n  forwardOut(boundAddr, boundPort, remoteAddr, remotePort, cb) {\n    const opts = { boundAddr, boundPort, remoteAddr, remotePort };\n    openChannel(this, 'forwarded-tcpip', opts, cb);\n    return this;\n  }\n\n  openssh_forwardOutStreamLocal(socketPath, cb) {\n    const opts = { socketPath };\n    openChannel(this, 'forwarded-streamlocal@openssh.com', opts, cb);\n    return this;\n  }\n\n  rekey(cb) {\n    let error;\n\n    try {\n      this._protocol.rekey();\n    } catch (ex) {\n      error = ex;\n    }\n\n    // TODO: re-throw error if no callback?\n\n    if (typeof cb === 'function') {\n      if (error)\n        process.nextTick(cb, error);\n      else\n        this.once('rekey', cb);\n    }\n  }\n\n  setNoDelay(noDelay) {\n    if (this._sock && typeof this._sock.setNoDelay === 'function')\n      this._sock.setNoDelay(noDelay);\n\n    return this;\n  }\n}\n\n\nfunction openChannel(self, type, opts, cb) {\n  // Ask the client to open a channel for some purpose (e.g. a forwarded TCP\n  // connection)\n  const initWindow = MAX_WINDOW;\n  const maxPacket = PACKET_SIZE;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  const wrapper = (err, stream) => {\n    cb(err, stream);\n  };\n  wrapper.type = type;\n\n  const localChan = self._chanMgr.add(wrapper);\n\n  if (localChan === -1) {\n    cb(new Error('No free channels available'));\n    return;\n  }\n\n  switch (type) {\n    case 'forwarded-tcpip':\n      self._protocol.forwardedTcpip(localChan, initWindow, maxPacket, opts);\n      break;\n    case 'x11':\n      self._protocol.x11(localChan, initWindow, maxPacket, opts);\n      break;\n    case 'forwarded-streamlocal@openssh.com':\n      self._protocol.openssh_forwardedStreamLocal(\n        localChan, initWindow, maxPacket, opts\n      );\n      break;\n    default:\n      throw new Error(`Unsupported channel type: ${type}`);\n  }\n}\n\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\nmodule.exports = Server;\nmodule.exports.IncomingClient = Client;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}