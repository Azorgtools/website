{"ast":null,"code":"/*\n  TODO:\n    * Replace `buffer._pos` usage in keyParser.js and elsewhere\n    * Utilize optional \"writev\" support when writing packets from\n      cipher.encrypt()\n    * Built-in support for automatic re-keying, on by default\n    * Revisit receiving unexpected/unknown packets\n      * Error (fatal or otherwise) or ignore or pass on to user (in some or all\n        cases)?\n      * Including server/client check for single directional packet types?\n      * Check packets for validity or bail as early as possible?\n    * Automatic re-key every 2**31 packets after the last key exchange (sent or\n      received), as suggested by RFC4344. OpenSSH currently does this.\n    * Automatic re-key every so many blocks depending on cipher. RFC4344:\n         Because of a birthday property of block ciphers and some modes of\n         operation, implementations must be careful not to encrypt too many\n         blocks with the same encryption key.\n\n         Let L be the block length (in bits) of an SSH encryption method's\n         block cipher (e.g., 128 for AES).  If L is at least 128, then, after\n         rekeying, an SSH implementation SHOULD NOT encrypt more than 2**(L/4)\n         blocks before rekeying again.  If L is at least 128, then SSH\n         implementations should also attempt to force a rekey before receiving\n         more than 2**(L/4) blocks.  If L is less than 128 (which is the case\n         for older ciphers such as 3DES, Blowfish, CAST-128, and IDEA), then,\n         although it may be too expensive to rekey every 2**(L/4) blocks, it\n         is still advisable for SSH implementations to follow the original\n         recommendation in [RFC4253]: rekey at least once for every gigabyte\n         of transmitted data.\n\n         Note that if L is less than or equal to 128, then the recommendation\n         in this subsection supersedes the recommendation in Section 3.1.  If\n         an SSH implementation uses a block cipher with a larger block size\n         (e.g., Rijndael with 256-bit blocks), then the recommendations in\n         Section 3.1 may supersede the recommendations in this subsection\n         (depending on the lengths of the packets).\n*/\n\n'use strict';\n\nconst {\n  inspect\n} = require('util');\nconst {\n  bindingAvailable,\n  NullCipher,\n  NullDecipher\n} = require('./crypto.js');\nconst {\n  COMPAT_CHECKS,\n  DISCONNECT_REASON,\n  eddsaSupported,\n  MESSAGE,\n  SIGNALS,\n  TERMINAL_MODE\n} = require('./constants.js');\nconst {\n  DEFAULT_KEXINIT_CLIENT,\n  DEFAULT_KEXINIT_SERVER,\n  KexInit,\n  kexinit,\n  onKEXPayload\n} = require('./kex.js');\nconst {\n  parseKey\n} = require('./keyParser.js');\nconst MESSAGE_HANDLERS = require('./handlers.js');\nconst {\n  bufferCopy,\n  bufferFill,\n  bufferSlice,\n  convertSignature,\n  sendPacket,\n  writeUInt32BE\n} = require('./utils.js');\nconst {\n  PacketReader,\n  PacketWriter,\n  ZlibPacketReader,\n  ZlibPacketWriter\n} = require('./zlib.js');\nconst MODULE_VER = require('../../package.json').version;\nconst VALID_DISCONNECT_REASONS = new Map(Object.values(DISCONNECT_REASON).map(n => [n, 1]));\nconst IDENT_RAW = Buffer.from(`SSH-2.0-ssh2js${MODULE_VER}`);\nconst IDENT = Buffer.from(`${IDENT_RAW}\\r\\n`);\nconst MAX_LINE_LEN = 8192;\nconst MAX_LINES = 1024;\nconst PING_PAYLOAD = Buffer.from([MESSAGE.GLOBAL_REQUEST,\n// \"keepalive@openssh.com\"\n0, 0, 0, 21, 107, 101, 101, 112, 97, 108, 105, 118, 101, 64, 111, 112, 101, 110, 115, 115, 104, 46, 99, 111, 109,\n// Request a reply\n1]);\nconst NO_TERMINAL_MODES_BUFFER = Buffer.from([TERMINAL_MODE.TTY_OP_END]);\nfunction noop() {}\n\n/*\n  Inbound:\n    * kexinit payload (needed only until exchange hash is generated)\n    * raw ident\n    * rekey packet queue\n    * expected packet (implemented as separate _parse() function?)\n  Outbound:\n    * kexinit payload (needed only until exchange hash is generated)\n    * rekey packet queue\n    * kex secret (needed only until NEWKEYS)\n    * exchange hash (needed only until NEWKEYS)\n    * session ID (set to exchange hash from initial handshake)\n*/\nclass Protocol {\n  constructor(config) {\n    var _this = this;\n    const onWrite = config.onWrite;\n    if (typeof onWrite !== 'function') throw new Error('Missing onWrite function');\n    this._onWrite = data => {\n      onWrite(data);\n    };\n    const onError = config.onError;\n    if (typeof onError !== 'function') throw new Error('Missing onError function');\n    this._onError = err => {\n      onError(err);\n    };\n    const debug = config.debug;\n    this._debug = typeof debug === 'function' ? msg => {\n      debug(msg);\n    } : undefined;\n    const onHeader = config.onHeader;\n    this._onHeader = typeof onHeader === 'function' ? function () {\n      onHeader(...arguments);\n    } : noop;\n    const onPacket = config.onPacket;\n    this._onPacket = typeof onPacket === 'function' ? () => {\n      onPacket();\n    } : noop;\n    let onHandshakeComplete = config.onHandshakeComplete;\n    if (typeof onHandshakeComplete !== 'function') onHandshakeComplete = noop;\n    let firstHandshake;\n    this._onHandshakeComplete = function () {\n      _this._debug && _this._debug('Handshake completed');\n      if (firstHandshake === undefined) firstHandshake = true;else firstHandshake = false;\n\n      // Process packets queued during a rekey where necessary\n      const oldQueue = _this._queue;\n      if (oldQueue) {\n        _this._queue = undefined;\n        _this._debug && _this._debug(`Draining outbound queue (${oldQueue.length}) ...`);\n        for (let i = 0; i < oldQueue.length; ++i) {\n          const data = oldQueue[i];\n          // data === payload only\n\n          // XXX: hacky\n          let finalized = _this._packetRW.write.finalize(data);\n          if (finalized === data) {\n            const packet = _this._cipher.allocPacket(data.length);\n            packet.set(data, 5);\n            finalized = packet;\n          }\n          sendPacket(_this, finalized);\n        }\n        _this._debug && _this._debug('... finished draining outbound queue');\n      }\n      if (firstHandshake && _this._server && _this._kex.remoteExtInfoEnabled) sendExtInfo(_this);\n      onHandshakeComplete(...arguments);\n    };\n    this._queue = undefined;\n    const messageHandlers = config.messageHandlers;\n    if (typeof messageHandlers === 'object' && messageHandlers !== null) this._handlers = messageHandlers;else this._handlers = {};\n    this._onPayload = onPayload.bind(this);\n    this._server = !!config.server;\n    this._banner = undefined;\n    let greeting;\n    if (this._server) {\n      if (typeof config.hostKeys !== 'object' || config.hostKeys === null) throw new Error('Missing server host key(s)');\n      this._hostKeys = config.hostKeys;\n\n      // Greeting displayed before the ssh identification string is sent, this\n      // is usually ignored by most clients\n      if (typeof config.greeting === 'string' && config.greeting.length) {\n        greeting = config.greeting.slice(-2) === '\\r\\n' ? config.greeting : `${config.greeting}\\r\\n`;\n      }\n\n      // Banner shown after the handshake completes, but before user\n      // authentication begins\n      if (typeof config.banner === 'string' && config.banner.length) {\n        this._banner = config.banner.slice(-2) === '\\r\\n' ? config.banner : `${config.banner}\\r\\n`;\n      }\n    } else {\n      this._hostKeys = undefined;\n    }\n    let offer = config.offer;\n    if (typeof offer !== 'object' || offer === null) {\n      offer = this._server ? DEFAULT_KEXINIT_SERVER : DEFAULT_KEXINIT_CLIENT;\n    } else if (offer.constructor !== KexInit) {\n      if (!this._server) offer.kex = offer.kex.concat(['ext-info-c']);\n      offer = new KexInit(offer);\n    }\n    this._kex = undefined;\n    this._kexinit = undefined;\n    this._offer = offer;\n    this._cipher = new NullCipher(0, this._onWrite);\n    this._decipher = undefined;\n    this._skipNextInboundPacket = false;\n    this._packetRW = {\n      read: new PacketReader(),\n      write: new PacketWriter(this)\n    };\n    this._hostVerifier = !this._server && typeof config.hostVerifier === 'function' ? config.hostVerifier : undefined;\n    this._parse = parseHeader;\n    this._buffer = undefined;\n    this._authsQueue = [];\n    this._authenticated = false;\n    this._remoteIdentRaw = undefined;\n    let sentIdent;\n    if (typeof config.ident === 'string') {\n      this._identRaw = Buffer.from(`SSH-2.0-${config.ident}`);\n      sentIdent = Buffer.allocUnsafe(this._identRaw.length + 2);\n      sentIdent.set(this._identRaw, 0);\n      sentIdent[sentIdent.length - 2] = 13; // '\\r'\n      sentIdent[sentIdent.length - 1] = 10; // '\\n'\n    } else if (Buffer.isBuffer(config.ident)) {\n      const fullIdent = Buffer.allocUnsafe(8 + config.ident.length);\n      fullIdent.latin1Write('SSH-2.0-', 0, 8);\n      fullIdent.set(config.ident, 8);\n      this._identRaw = fullIdent;\n      sentIdent = Buffer.allocUnsafe(fullIdent.length + 2);\n      sentIdent.set(fullIdent, 0);\n      sentIdent[sentIdent.length - 2] = 13; // '\\r'\n      sentIdent[sentIdent.length - 1] = 10; // '\\n'\n    } else {\n      this._identRaw = IDENT_RAW;\n      sentIdent = IDENT;\n    }\n    this._compatFlags = 0;\n    if (this._debug) {\n      if (bindingAvailable) this._debug('Custom crypto binding available');else this._debug('Custom crypto binding not available');\n    }\n    this._debug && this._debug(`Local ident: ${inspect(this._identRaw.toString())}`);\n    this.start = () => {\n      this.start = undefined;\n      if (greeting) this._onWrite(greeting);\n      this._onWrite(sentIdent);\n    };\n  }\n  _destruct(reason) {\n    this._packetRW.read.cleanup();\n    this._packetRW.write.cleanup();\n    this._cipher && this._cipher.free();\n    this._decipher && this._decipher.free();\n    if (typeof reason !== 'string' || reason.length === 0) reason = 'fatal error';\n    this.parse = () => {\n      throw new Error(`Instance unusable after ${reason}`);\n    };\n    this._onWrite = () => {\n      throw new Error(`Instance unusable after ${reason}`);\n    };\n    this._destruct = undefined;\n  }\n  cleanup() {\n    this._destruct && this._destruct();\n  }\n  parse(chunk, i, len) {\n    while (i < len) i = this._parse(chunk, i, len);\n  }\n\n  // Protocol message API\n\n  // ===========================================================================\n  // Common/Shared =============================================================\n  // ===========================================================================\n\n  // Global\n  // ------\n  disconnect(reason) {\n    const pktLen = 1 + 4 + 4 + 4;\n    // We don't use _packetRW.write.* here because we need to make sure that\n    // we always get a full packet allocated because this message can be sent\n    // at any time -- even during a key exchange\n    let p = this._packetRW.write.allocStartKEX;\n    const packet = this._packetRW.write.alloc(pktLen, true);\n    const end = p + pktLen;\n    if (!VALID_DISCONNECT_REASONS.has(reason)) reason = DISCONNECT_REASON.PROTOCOL_ERROR;\n    packet[p] = MESSAGE.DISCONNECT;\n    writeUInt32BE(packet, reason, ++p);\n    packet.fill(0, p += 4, end);\n    this._debug && this._debug(`Outbound: Sending DISCONNECT (${reason})`);\n    sendPacket(this, this._packetRW.write.finalize(packet, true), true);\n  }\n  ping() {\n    const p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(PING_PAYLOAD.length);\n    packet.set(PING_PAYLOAD, p);\n    this._debug && this._debug('Outbound: Sending ping (GLOBAL_REQUEST: keepalive@openssh.com)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  rekey() {\n    if (this._kexinit === undefined) {\n      this._debug && this._debug('Outbound: Initiated explicit rekey');\n      this._queue = [];\n      kexinit(this);\n    } else {\n      this._debug && this._debug('Outbound: Ignoring rekey during handshake');\n    }\n  }\n\n  // 'ssh-connection' service-specific\n  // ---------------------------------\n  requestSuccess(data) {\n    let p = this._packetRW.write.allocStart;\n    let packet;\n    if (Buffer.isBuffer(data)) {\n      packet = this._packetRW.write.alloc(1 + data.length);\n      packet[p] = MESSAGE.REQUEST_SUCCESS;\n      packet.set(data, ++p);\n    } else {\n      packet = this._packetRW.write.alloc(1);\n      packet[p] = MESSAGE.REQUEST_SUCCESS;\n    }\n    this._debug && this._debug('Outbound: Sending REQUEST_SUCCESS');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  requestFailure() {\n    const p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1);\n    packet[p] = MESSAGE.REQUEST_FAILURE;\n    this._debug && this._debug('Outbound: Sending REQUEST_FAILURE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelSuccess(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n    packet[p] = MESSAGE.CHANNEL_SUCCESS;\n    writeUInt32BE(packet, chan, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_SUCCESS (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelFailure(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n    packet[p] = MESSAGE.CHANNEL_FAILURE;\n    writeUInt32BE(packet, chan, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_FAILURE (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelEOF(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n    packet[p] = MESSAGE.CHANNEL_EOF;\n    writeUInt32BE(packet, chan, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_EOF (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelClose(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n    packet[p] = MESSAGE.CHANNEL_CLOSE;\n    writeUInt32BE(packet, chan, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_CLOSE (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelWindowAdjust(chan, amount) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4);\n    packet[p] = MESSAGE.CHANNEL_WINDOW_ADJUST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, amount, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_WINDOW_ADJUST (r:${chan}, ${amount})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelData(chan, data) {\n    const isBuffer = Buffer.isBuffer(data);\n    const dataLen = isBuffer ? data.length : Buffer.byteLength(data);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + dataLen);\n    packet[p] = MESSAGE.CHANNEL_DATA;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, dataLen, p += 4);\n    if (isBuffer) packet.set(data, p += 4);else packet.utf8Write(data, p += 4, dataLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_DATA (r:${chan}, ${dataLen})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelExtData(chan, data, type) {\n    const isBuffer = Buffer.isBuffer(data);\n    const dataLen = isBuffer ? data.length : Buffer.byteLength(data);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + dataLen);\n    packet[p] = MESSAGE.CHANNEL_EXTENDED_DATA;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, type, p += 4);\n    writeUInt32BE(packet, dataLen, p += 4);\n    if (isBuffer) packet.set(data, p += 4);else packet.utf8Write(data, p += 4, dataLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_EXTENDED_DATA (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelOpenConfirm(remote, local, initWindow, maxPacket) {\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN_CONFIRMATION;\n    writeUInt32BE(packet, remote, ++p);\n    writeUInt32BE(packet, local, p += 4);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN_CONFIRMATION (r:${remote}, l:${local})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelOpenFail(remote, reason, desc) {\n    if (typeof desc !== 'string') desc = '';\n    const descLen = Buffer.byteLength(desc);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + descLen + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN_FAILURE;\n    writeUInt32BE(packet, remote, ++p);\n    writeUInt32BE(packet, reason, p += 4);\n    writeUInt32BE(packet, descLen, p += 4);\n    p += 4;\n    if (descLen) {\n      packet.utf8Write(desc, p, descLen);\n      p += descLen;\n    }\n    writeUInt32BE(packet, 0, p); // Empty language tag\n\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN_FAILURE (r:${remote})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // ===========================================================================\n  // Client-specific ===========================================================\n  // ===========================================================================\n\n  // Global\n  // ------\n  service(name) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const nameLen = Buffer.byteLength(name);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + nameLen);\n    packet[p] = MESSAGE.SERVICE_REQUEST;\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(name, p += 4, nameLen);\n    this._debug && this._debug(`Outbound: Sending SERVICE_REQUEST (${name})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // 'ssh-userauth' service-specific\n  // -------------------------------\n  authPassword(username, password, newPassword) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const userLen = Buffer.byteLength(username);\n    const passLen = Buffer.byteLength(password);\n    const newPassLen = newPassword ? Buffer.byteLength(newPassword) : 0;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 8 + 1 + 4 + passLen + (newPassword ? 4 + newPassLen : 0));\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(packet, 8, p += 14);\n    packet.utf8Write('password', p += 4, 8);\n    packet[p += 8] = newPassword ? 1 : 0;\n    writeUInt32BE(packet, passLen, ++p);\n    if (Buffer.isBuffer(password)) bufferCopy(password, packet, 0, passLen, p += 4);else packet.utf8Write(password, p += 4, passLen);\n    if (newPassword) {\n      writeUInt32BE(packet, newPassLen, p += passLen);\n      if (Buffer.isBuffer(newPassword)) bufferCopy(newPassword, packet, 0, newPassLen, p += 4);else packet.utf8Write(newPassword, p += 4, newPassLen);\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (changed password)');\n    } else {\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (password)');\n    }\n    this._authsQueue.push('password');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authPK(username, pubKey, keyAlgo, cbSign) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    pubKey = parseKey(pubKey);\n    if (pubKey instanceof Error) throw new Error('Invalid key');\n    const keyType = pubKey.type;\n    pubKey = pubKey.getPublicSSH();\n    if (typeof keyAlgo === 'function') {\n      cbSign = keyAlgo;\n      keyAlgo = undefined;\n    }\n    if (!keyAlgo) keyAlgo = keyType;\n    const userLen = Buffer.byteLength(username);\n    const algoLen = Buffer.byteLength(keyAlgo);\n    const pubKeyLen = pubKey.length;\n    const sessionID = this._kex.sessionID;\n    const sesLen = sessionID.length;\n    const payloadLen = (cbSign ? 4 + sesLen : 0) + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen;\n    let packet;\n    let p;\n    if (cbSign) {\n      packet = Buffer.allocUnsafe(payloadLen);\n      p = 0;\n      writeUInt32BE(packet, sesLen, p);\n      packet.set(sessionID, p += 4);\n      p += sesLen;\n    } else {\n      packet = this._packetRW.write.alloc(payloadLen);\n      p = this._packetRW.write.allocStart;\n    }\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(packet, 9, p += 14);\n    packet.utf8Write('publickey', p += 4, 9);\n    packet[p += 9] = cbSign ? 1 : 0;\n    writeUInt32BE(packet, algoLen, ++p);\n    packet.utf8Write(keyAlgo, p += 4, algoLen);\n    writeUInt32BE(packet, pubKeyLen, p += algoLen);\n    packet.set(pubKey, p += 4);\n    if (!cbSign) {\n      this._authsQueue.push('publickey');\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (publickey -- check)');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n      return;\n    }\n    cbSign(packet, signature => {\n      signature = convertSignature(signature, keyType);\n      if (signature === false) throw new Error('Error while converting handshake signature');\n      const sigLen = signature.length;\n      p = this._packetRW.write.allocStart;\n      packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen + 4 + 4 + algoLen + 4 + sigLen);\n\n      // TODO: simply copy from original \"packet\" to new `packet` to avoid\n      // having to write each individual field a second time?\n      packet[p] = MESSAGE.USERAUTH_REQUEST;\n      writeUInt32BE(packet, userLen, ++p);\n      packet.utf8Write(username, p += 4, userLen);\n      writeUInt32BE(packet, 14, p += userLen);\n      packet.utf8Write('ssh-connection', p += 4, 14);\n      writeUInt32BE(packet, 9, p += 14);\n      packet.utf8Write('publickey', p += 4, 9);\n      packet[p += 9] = 1;\n      writeUInt32BE(packet, algoLen, ++p);\n      packet.utf8Write(keyAlgo, p += 4, algoLen);\n      writeUInt32BE(packet, pubKeyLen, p += algoLen);\n      packet.set(pubKey, p += 4);\n      writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += pubKeyLen);\n      writeUInt32BE(packet, algoLen, p += 4);\n      packet.utf8Write(keyAlgo, p += 4, algoLen);\n      writeUInt32BE(packet, sigLen, p += algoLen);\n      packet.set(signature, p += 4);\n\n      // Servers shouldn't send packet type 60 in response to signed publickey\n      // attempts, but if they do, interpret as type 60.\n      this._authsQueue.push('publickey');\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (publickey)');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    });\n  }\n  authHostbased(username, pubKey, hostname, userlocal, keyAlgo, cbSign) {\n    // TODO: Make DRY by sharing similar code with authPK()\n    if (this._server) throw new Error('Client-only method called in server mode');\n    pubKey = parseKey(pubKey);\n    if (pubKey instanceof Error) throw new Error('Invalid key');\n    const keyType = pubKey.type;\n    pubKey = pubKey.getPublicSSH();\n    if (typeof keyAlgo === 'function') {\n      cbSign = keyAlgo;\n      keyAlgo = undefined;\n    }\n    if (!keyAlgo) keyAlgo = keyType;\n    const userLen = Buffer.byteLength(username);\n    const algoLen = Buffer.byteLength(keyAlgo);\n    const pubKeyLen = pubKey.length;\n    const sessionID = this._kex.sessionID;\n    const sesLen = sessionID.length;\n    const hostnameLen = Buffer.byteLength(hostname);\n    const userlocalLen = Buffer.byteLength(userlocal);\n    const data = Buffer.allocUnsafe(4 + sesLen + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 4 + algoLen + 4 + pubKeyLen + 4 + hostnameLen + 4 + userlocalLen);\n    let p = 0;\n    writeUInt32BE(data, sesLen, p);\n    data.set(sessionID, p += 4);\n    data[p += sesLen] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(data, userLen, ++p);\n    data.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(data, 14, p += userLen);\n    data.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(data, 9, p += 14);\n    data.utf8Write('hostbased', p += 4, 9);\n    writeUInt32BE(data, algoLen, p += 9);\n    data.utf8Write(keyAlgo, p += 4, algoLen);\n    writeUInt32BE(data, pubKeyLen, p += algoLen);\n    data.set(pubKey, p += 4);\n    writeUInt32BE(data, hostnameLen, p += pubKeyLen);\n    data.utf8Write(hostname, p += 4, hostnameLen);\n    writeUInt32BE(data, userlocalLen, p += hostnameLen);\n    data.utf8Write(userlocal, p += 4, userlocalLen);\n    cbSign(data, signature => {\n      signature = convertSignature(signature, keyType);\n      if (!signature) throw new Error('Error while converting handshake signature');\n      const sigLen = signature.length;\n      const reqDataLen = data.length - sesLen - 4;\n      p = this._packetRW.write.allocStart;\n      const packet = this._packetRW.write.alloc(reqDataLen + 4 + 4 + algoLen + 4 + sigLen);\n      bufferCopy(data, packet, 4 + sesLen, data.length, p);\n      writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += reqDataLen);\n      writeUInt32BE(packet, algoLen, p += 4);\n      packet.utf8Write(keyAlgo, p += 4, algoLen);\n      writeUInt32BE(packet, sigLen, p += algoLen);\n      packet.set(signature, p += 4);\n      this._authsQueue.push('hostbased');\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (hostbased)');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    });\n  }\n  authKeyboard(username) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const userLen = Buffer.byteLength(username);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 20 + 4 + 4);\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(packet, 20, p += 14);\n    packet.utf8Write('keyboard-interactive', p += 4, 20);\n    writeUInt32BE(packet, 0, p += 20);\n    writeUInt32BE(packet, 0, p += 4);\n    this._authsQueue.push('keyboard-interactive');\n    this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (keyboard-interactive)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authNone(username) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const userLen = Buffer.byteLength(username);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 4);\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(packet, 4, p += 14);\n    packet.utf8Write('none', p += 4, 4);\n    this._authsQueue.push('none');\n    this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (none)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authInfoRes(responses) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    let responsesTotalLen = 0;\n    let responseLens;\n    if (responses) {\n      responseLens = new Array(responses.length);\n      for (let i = 0; i < responses.length; ++i) {\n        const len = Buffer.byteLength(responses[i]);\n        responseLens[i] = len;\n        responsesTotalLen += 4 + len;\n      }\n    }\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + responsesTotalLen);\n    packet[p] = MESSAGE.USERAUTH_INFO_RESPONSE;\n    if (responses) {\n      writeUInt32BE(packet, responses.length, ++p);\n      p += 4;\n      for (let i = 0; i < responses.length; ++i) {\n        const len = responseLens[i];\n        writeUInt32BE(packet, len, p);\n        p += 4;\n        if (len) {\n          packet.utf8Write(responses[i], p, len);\n          p += len;\n        }\n      }\n    } else {\n      writeUInt32BE(packet, 0, ++p);\n    }\n    this._debug && this._debug('Outbound: Sending USERAUTH_INFO_RESPONSE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // 'ssh-connection' service-specific\n  // ---------------------------------\n  tcpipForward(bindAddr, bindPort, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const addrLen = Buffer.byteLength(bindAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 13 + 1 + 4 + addrLen + 4);\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 13, ++p);\n    packet.utf8Write('tcpip-forward', p += 4, 13);\n    packet[p += 13] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, addrLen, ++p);\n    packet.utf8Write(bindAddr, p += 4, addrLen);\n    writeUInt32BE(packet, bindPort, p += addrLen);\n    this._debug && this._debug('Outbound: Sending GLOBAL_REQUEST (tcpip-forward)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  cancelTcpipForward(bindAddr, bindPort, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const addrLen = Buffer.byteLength(bindAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 20 + 1 + 4 + addrLen + 4);\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 20, ++p);\n    packet.utf8Write('cancel-tcpip-forward', p += 4, 20);\n    packet[p += 20] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, addrLen, ++p);\n    packet.utf8Write(bindAddr, p += 4, addrLen);\n    writeUInt32BE(packet, bindPort, p += addrLen);\n    this._debug && this._debug('Outbound: Sending GLOBAL_REQUEST (cancel-tcpip-forward)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_streamLocalForward(socketPath, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const socketPathLen = Buffer.byteLength(socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 31 + 1 + 4 + socketPathLen);\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 31, ++p);\n    packet.utf8Write('streamlocal-forward@openssh.com', p += 4, 31);\n    packet[p += 31] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, socketPathLen, ++p);\n    packet.utf8Write(socketPath, p += 4, socketPathLen);\n    this._debug && this._debug('Outbound: Sending GLOBAL_REQUEST (streamlocal-forward@openssh.com)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_cancelStreamLocalForward(socketPath, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const socketPathLen = Buffer.byteLength(socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 38 + 1 + 4 + socketPathLen);\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 38, ++p);\n    packet.utf8Write('cancel-streamlocal-forward@openssh.com', p += 4, 38);\n    packet[p += 38] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, socketPathLen, ++p);\n    packet.utf8Write(socketPath, p += 4, socketPathLen);\n    if (this._debug) {\n      this._debug('Outbound: Sending GLOBAL_REQUEST ' + '(cancel-streamlocal-forward@openssh.com)');\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  directTcpip(chan, initWindow, maxPacket, cfg) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const srcLen = Buffer.byteLength(cfg.srcIP);\n    const dstLen = Buffer.byteLength(cfg.dstIP);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 12 + 4 + 4 + 4 + 4 + srcLen + 4 + 4 + dstLen + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 12, ++p);\n    packet.utf8Write('direct-tcpip', p += 4, 12);\n    writeUInt32BE(packet, chan, p += 12);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, dstLen, p += 4);\n    packet.utf8Write(cfg.dstIP, p += 4, dstLen);\n    writeUInt32BE(packet, cfg.dstPort, p += dstLen);\n    writeUInt32BE(packet, srcLen, p += 4);\n    packet.utf8Write(cfg.srcIP, p += 4, srcLen);\n    writeUInt32BE(packet, cfg.srcPort, p += srcLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-tcpip)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_directStreamLocal(chan, initWindow, maxPacket, cfg) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const pathLen = Buffer.byteLength(cfg.socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 30 + 4 + 4 + 4 + 4 + pathLen + 4 + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 30, ++p);\n    packet.utf8Write('direct-streamlocal@openssh.com', p += 4, 30);\n    writeUInt32BE(packet, chan, p += 30);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, pathLen, p += 4);\n    packet.utf8Write(cfg.socketPath, p += 4, pathLen);\n\n    // zero-fill reserved fields (string and uint32)\n    bufferFill(packet, 0, p += pathLen, p + 8);\n    if (this._debug) {\n      this._debug('Outbound: Sending CHANNEL_OPEN ' + `(r:${chan}, direct-streamlocal@openssh.com)`);\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_noMoreSessions(wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 28 + 1);\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 28, ++p);\n    packet.utf8Write('no-more-sessions@openssh.com', p += 4, 28);\n    packet[p += 28] = wantReply === undefined || wantReply === true ? 1 : 0;\n    this._debug && this._debug('Outbound: Sending GLOBAL_REQUEST (no-more-sessions@openssh.com)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  session(chan, initWindow, maxPacket) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 7 + 4 + 4 + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 7, ++p);\n    packet.utf8Write('session', p += 4, 7);\n    writeUInt32BE(packet, chan, p += 7);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, session)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  windowChange(chan, rows, cols, height, width) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 13, p += 4);\n    packet.utf8Write('window-change', p += 4, 13);\n    packet[p += 13] = 0;\n    writeUInt32BE(packet, cols, ++p);\n    writeUInt32BE(packet, rows, p += 4);\n    writeUInt32BE(packet, width, p += 4);\n    writeUInt32BE(packet, height, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, window-change)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  pty(chan, rows, cols, height, width, term, modes, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    if (!term || !term.length) term = 'vt100';\n    if (modes && !Buffer.isBuffer(modes) && !Array.isArray(modes) && typeof modes === 'object' && modes !== null) {\n      modes = modesToBytes(modes);\n    }\n    if (!modes || !modes.length) modes = NO_TERMINAL_MODES_BUFFER;\n    const termLen = term.length;\n    const modesLen = modes.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 7 + 1 + 4 + termLen + 4 + 4 + 4 + 4 + 4 + modesLen);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 7, p += 4);\n    packet.utf8Write('pty-req', p += 4, 7);\n    packet[p += 7] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, termLen, ++p);\n    packet.utf8Write(term, p += 4, termLen);\n    writeUInt32BE(packet, cols, p += termLen);\n    writeUInt32BE(packet, rows, p += 4);\n    writeUInt32BE(packet, width, p += 4);\n    writeUInt32BE(packet, height, p += 4);\n    writeUInt32BE(packet, modesLen, p += 4);\n    p += 4;\n    if (Array.isArray(modes)) {\n      for (let i = 0; i < modesLen; ++i) packet[p++] = modes[i];\n    } else if (Buffer.isBuffer(modes)) {\n      packet.set(modes, p);\n    }\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, pty-req)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  shell(chan, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 5 + 1);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 5, p += 4);\n    packet.utf8Write('shell', p += 4, 5);\n    packet[p += 5] = wantReply === undefined || wantReply === true ? 1 : 0;\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, shell)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  exec(chan, cmd, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const isBuf = Buffer.isBuffer(cmd);\n    const cmdLen = isBuf ? cmd.length : Buffer.byteLength(cmd);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 1 + 4 + cmdLen);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 4, p += 4);\n    packet.utf8Write('exec', p += 4, 4);\n    packet[p += 4] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, cmdLen, ++p);\n    if (isBuf) packet.set(cmd, p += 4);else packet.utf8Write(cmd, p += 4, cmdLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, exec: ${cmd})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  signal(chan, signal) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const origSignal = signal;\n    signal = signal.toUpperCase();\n    if (signal.slice(0, 3) === 'SIG') signal = signal.slice(3);\n    if (SIGNALS[signal] !== 1) throw new Error(`Invalid signal: ${origSignal}`);\n    const signalLen = signal.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 6 + 1 + 4 + signalLen);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 6, p += 4);\n    packet.utf8Write('signal', p += 4, 6);\n    packet[p += 6] = 0;\n    writeUInt32BE(packet, signalLen, ++p);\n    packet.utf8Write(signal, p += 4, signalLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, signal: ${signal})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  env(chan, key, val, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const keyLen = Buffer.byteLength(key);\n    const isBuf = Buffer.isBuffer(val);\n    const valLen = isBuf ? val.length : Buffer.byteLength(val);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 3 + 1 + 4 + keyLen + 4 + valLen);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 3, p += 4);\n    packet.utf8Write('env', p += 4, 3);\n    packet[p += 3] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, keyLen, ++p);\n    packet.utf8Write(key, p += 4, keyLen);\n    writeUInt32BE(packet, valLen, p += keyLen);\n    if (isBuf) packet.set(val, p += 4);else packet.utf8Write(val, p += 4, valLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, env: ${key}=${val})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  x11Forward(chan, cfg, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const protocol = cfg.protocol;\n    const cookie = cfg.cookie;\n    const isBufProto = Buffer.isBuffer(protocol);\n    const protoLen = isBufProto ? protocol.length : Buffer.byteLength(protocol);\n    const isBufCookie = Buffer.isBuffer(cookie);\n    const cookieLen = isBufCookie ? cookie.length : Buffer.byteLength(cookie);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 7 + 1 + 1 + 4 + protoLen + 4 + cookieLen + 4);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 7, p += 4);\n    packet.utf8Write('x11-req', p += 4, 7);\n    packet[p += 7] = wantReply === undefined || wantReply === true ? 1 : 0;\n    packet[++p] = cfg.single ? 1 : 0;\n    writeUInt32BE(packet, protoLen, ++p);\n    if (isBufProto) packet.set(protocol, p += 4);else packet.utf8Write(protocol, p += 4, protoLen);\n    writeUInt32BE(packet, cookieLen, p += protoLen);\n    if (isBufCookie) packet.set(cookie, p += 4);else packet.latin1Write(cookie, p += 4, cookieLen);\n    writeUInt32BE(packet, cfg.screen || 0, p += cookieLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, x11-req)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  subsystem(chan, name, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n    const nameLen = Buffer.byteLength(name);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 9 + 1 + 4 + nameLen);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 9, p += 4);\n    packet.utf8Write('subsystem', p += 4, 9);\n    packet[p += 9] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(name, p += 4, nameLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, subsystem: ${name})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_agentForward(chan, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 26 + 1);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 26, p += 4);\n    packet.utf8Write('auth-agent-req@openssh.com', p += 4, 26);\n    packet[p += 26] = wantReply === undefined || wantReply === true ? 1 : 0;\n    if (this._debug) {\n      this._debug('Outbound: Sending CHANNEL_REQUEST ' + `(r:${chan}, auth-agent-req@openssh.com)`);\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_hostKeysProve(keys) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    let keysTotal = 0;\n    const publicKeys = [];\n    for (const key of keys) {\n      const publicKey = key.getPublicSSH();\n      keysTotal += 4 + publicKey.length;\n      publicKeys.push(publicKey);\n    }\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 29 + 1 + keysTotal);\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 29, ++p);\n    packet.utf8Write('hostkeys-prove-00@openssh.com', p += 4, 29);\n    packet[p += 29] = 1; // want reply\n\n    ++p;\n    for (const buf of publicKeys) {\n      writeUInt32BE(packet, buf.length, p);\n      bufferCopy(buf, packet, 0, buf.length, p += 4);\n      p += buf.length;\n    }\n    if (this._debug) {\n      this._debug('Outbound: Sending GLOBAL_REQUEST (hostkeys-prove-00@openssh.com)');\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // ===========================================================================\n  // Server-specific ===========================================================\n  // ===========================================================================\n\n  // Global\n  // ------\n  serviceAccept(svcName) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const svcNameLen = Buffer.byteLength(svcName);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + svcNameLen);\n    packet[p] = MESSAGE.SERVICE_ACCEPT;\n    writeUInt32BE(packet, svcNameLen, ++p);\n    packet.utf8Write(svcName, p += 4, svcNameLen);\n    this._debug && this._debug(`Outbound: Sending SERVICE_ACCEPT (${svcName})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n    if (this._server && this._banner && svcName === 'ssh-userauth') {\n      const banner = this._banner;\n      this._banner = undefined; // Prevent banner from being displayed again\n      const bannerLen = Buffer.byteLength(banner);\n      p = this._packetRW.write.allocStart;\n      const packet = this._packetRW.write.alloc(1 + 4 + bannerLen + 4);\n      packet[p] = MESSAGE.USERAUTH_BANNER;\n      writeUInt32BE(packet, bannerLen, ++p);\n      packet.utf8Write(banner, p += 4, bannerLen);\n      writeUInt32BE(packet, 0, p += bannerLen); // Empty language tag\n\n      this._debug && this._debug('Outbound: Sending USERAUTH_BANNER');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    }\n  }\n  // 'ssh-connection' service-specific\n  forwardedTcpip(chan, initWindow, maxPacket, cfg) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const boundAddrLen = Buffer.byteLength(cfg.boundAddr);\n    const remoteAddrLen = Buffer.byteLength(cfg.remoteAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 15 + 4 + 4 + 4 + 4 + boundAddrLen + 4 + 4 + remoteAddrLen + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 15, ++p);\n    packet.utf8Write('forwarded-tcpip', p += 4, 15);\n    writeUInt32BE(packet, chan, p += 15);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, boundAddrLen, p += 4);\n    packet.utf8Write(cfg.boundAddr, p += 4, boundAddrLen);\n    writeUInt32BE(packet, cfg.boundPort, p += boundAddrLen);\n    writeUInt32BE(packet, remoteAddrLen, p += 4);\n    packet.utf8Write(cfg.remoteAddr, p += 4, remoteAddrLen);\n    writeUInt32BE(packet, cfg.remotePort, p += remoteAddrLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-tcpip)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  x11(chan, initWindow, maxPacket, cfg) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const addrLen = Buffer.byteLength(cfg.originAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 3 + 4 + 4 + 4 + 4 + addrLen + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 3, ++p);\n    packet.utf8Write('x11', p += 4, 3);\n    writeUInt32BE(packet, chan, p += 3);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, addrLen, p += 4);\n    packet.utf8Write(cfg.originAddr, p += 4, addrLen);\n    writeUInt32BE(packet, cfg.originPort, p += addrLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, x11)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_authAgent(chan, initWindow, maxPacket) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 22 + 4 + 4 + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 22, ++p);\n    packet.utf8Write('auth-agent@openssh.com', p += 4, 22);\n    writeUInt32BE(packet, chan, p += 22);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, auth-agent@openssh.com)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_forwardedStreamLocal(chan, initWindow, maxPacket, cfg) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const pathLen = Buffer.byteLength(cfg.socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 33 + 4 + 4 + 4 + 4 + pathLen + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 33, ++p);\n    packet.utf8Write('forwarded-streamlocal@openssh.com', p += 4, 33);\n    writeUInt32BE(packet, chan, p += 33);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, pathLen, p += 4);\n    packet.utf8Write(cfg.socketPath, p += 4, pathLen);\n    writeUInt32BE(packet, 0, p += pathLen);\n    if (this._debug) {\n      this._debug('Outbound: Sending CHANNEL_OPEN ' + `(r:${chan}, forwarded-streamlocal@openssh.com)`);\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  exitStatus(chan, status) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n\n    // Does not consume window space\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 11, p += 4);\n    packet.utf8Write('exit-status', p += 4, 11);\n    packet[p += 11] = 0;\n    writeUInt32BE(packet, status, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-status: ${status})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  exitSignal(chan, name, coreDumped, msg) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n\n    // Does not consume window space\n\n    const origSignal = name;\n    if (typeof origSignal !== 'string' || !origSignal) throw new Error(`Invalid signal: ${origSignal}`);\n    let signal = name.toUpperCase();\n    if (signal.slice(0, 3) === 'SIG') signal = signal.slice(3);\n    if (SIGNALS[signal] !== 1) throw new Error(`Invalid signal: ${origSignal}`);\n    const nameLen = Buffer.byteLength(signal);\n    const msgLen = msg ? Buffer.byteLength(msg) : 0;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4 + nameLen + 1 + 4 + msgLen + 4);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 11, p += 4);\n    packet.utf8Write('exit-signal', p += 4, 11);\n    packet[p += 11] = 0;\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(signal, p += 4, nameLen);\n    packet[p += nameLen] = coreDumped ? 1 : 0;\n    writeUInt32BE(packet, msgLen, ++p);\n    p += 4;\n    if (msgLen) {\n      packet.utf8Write(msg, p, msgLen);\n      p += msgLen;\n    }\n    writeUInt32BE(packet, 0, p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-signal: ${name})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  // 'ssh-userauth' service-specific\n  authFailure(authMethods, isPartial) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    if (this._authsQueue.length === 0) throw new Error('No auth in progress');\n    let methods;\n    if (typeof authMethods === 'boolean') {\n      isPartial = authMethods;\n      authMethods = undefined;\n    }\n    if (authMethods) {\n      methods = [];\n      for (let i = 0; i < authMethods.length; ++i) {\n        if (authMethods[i].toLowerCase() === 'none') continue;\n        methods.push(authMethods[i]);\n      }\n      methods = methods.join(',');\n    } else {\n      methods = '';\n    }\n    const methodsLen = methods.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + methodsLen + 1);\n    packet[p] = MESSAGE.USERAUTH_FAILURE;\n    writeUInt32BE(packet, methodsLen, ++p);\n    packet.utf8Write(methods, p += 4, methodsLen);\n    packet[p += methodsLen] = isPartial === true ? 1 : 0;\n    this._authsQueue.shift();\n    this._debug && this._debug('Outbound: Sending USERAUTH_FAILURE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authSuccess() {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    if (this._authsQueue.length === 0) throw new Error('No auth in progress');\n    const p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1);\n    packet[p] = MESSAGE.USERAUTH_SUCCESS;\n    this._authsQueue.shift();\n    this._authenticated = true;\n    this._debug && this._debug('Outbound: Sending USERAUTH_SUCCESS');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n    if (this._kex.negotiated.cs.compress === 'zlib@openssh.com') this._packetRW.read = new ZlibPacketReader();\n    if (this._kex.negotiated.sc.compress === 'zlib@openssh.com') this._packetRW.write = new ZlibPacketWriter(this);\n  }\n  authPKOK(keyAlgo, key) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    if (this._authsQueue.length === 0 || this._authsQueue[0] !== 'publickey') throw new Error('\"publickey\" auth not in progress');\n\n    // TODO: support parsed key for `key`\n\n    const keyAlgoLen = Buffer.byteLength(keyAlgo);\n    const keyLen = key.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + keyAlgoLen + 4 + keyLen);\n    packet[p] = MESSAGE.USERAUTH_PK_OK;\n    writeUInt32BE(packet, keyAlgoLen, ++p);\n    packet.utf8Write(keyAlgo, p += 4, keyAlgoLen);\n    writeUInt32BE(packet, keyLen, p += keyAlgoLen);\n    packet.set(key, p += 4);\n    this._authsQueue.shift();\n    this._debug && this._debug('Outbound: Sending USERAUTH_PK_OK');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authPasswdChg(prompt) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const promptLen = Buffer.byteLength(prompt);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + promptLen + 4);\n    packet[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ;\n    writeUInt32BE(packet, promptLen, ++p);\n    packet.utf8Write(prompt, p += 4, promptLen);\n    writeUInt32BE(packet, 0, p += promptLen); // Empty language tag\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_PASSWD_CHANGEREQ');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authInfoReq(name, instructions, prompts) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    let promptsLen = 0;\n    const nameLen = name ? Buffer.byteLength(name) : 0;\n    const instrLen = instructions ? Buffer.byteLength(instructions) : 0;\n    for (let i = 0; i < prompts.length; ++i) promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + nameLen + 4 + instrLen + 4 + 4 + promptsLen);\n    packet[p] = MESSAGE.USERAUTH_INFO_REQUEST;\n    writeUInt32BE(packet, nameLen, ++p);\n    p += 4;\n    if (name) {\n      packet.utf8Write(name, p, nameLen);\n      p += nameLen;\n    }\n    writeUInt32BE(packet, instrLen, p);\n    p += 4;\n    if (instructions) {\n      packet.utf8Write(instructions, p, instrLen);\n      p += instrLen;\n    }\n    writeUInt32BE(packet, 0, p);\n    writeUInt32BE(packet, prompts.length, p += 4);\n    p += 4;\n    for (let i = 0; i < prompts.length; ++i) {\n      const prompt = prompts[i];\n      const promptLen = Buffer.byteLength(prompt.prompt);\n      writeUInt32BE(packet, promptLen, p);\n      p += 4;\n      if (promptLen) {\n        packet.utf8Write(prompt.prompt, p, promptLen);\n        p += promptLen;\n      }\n      packet[p++] = prompt.echo ? 1 : 0;\n    }\n    this._debug && this._debug('Outbound: Sending USERAUTH_INFO_REQUEST');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n}\n\n// SSH-protoversion-softwareversion (SP comments) CR LF\nconst RE_IDENT = /^SSH-(2\\.0|1\\.99)-([^ ]+)(?: (.*))?$/;\n\n// TODO: optimize this by starting n bytes from the end of this._buffer instead\n// of the beginning\nfunction parseHeader(chunk, p, len) {\n  let data;\n  let chunkOffset;\n  if (this._buffer) {\n    data = Buffer.allocUnsafe(this._buffer.length + (len - p));\n    data.set(this._buffer, 0);\n    if (p === 0) {\n      data.set(chunk, this._buffer.length);\n    } else {\n      data.set(new Uint8Array(chunk.buffer, chunk.byteOffset + p, len - p), this._buffer.length);\n    }\n    chunkOffset = this._buffer.length;\n    p = 0;\n  } else {\n    data = chunk;\n    chunkOffset = 0;\n  }\n  const op = p;\n  let start = p;\n  let end = p;\n  let needNL = false;\n  let lineLen = 0;\n  let lines = 0;\n  for (; p < data.length; ++p) {\n    const ch = data[p];\n    if (ch === 13 /* '\\r' */) {\n      needNL = true;\n      continue;\n    }\n    if (ch === 10 /* '\\n' */) {\n      if (end > start && end - start > 4 && data[start] === 83 /* 'S' */ && data[start + 1] === 83 /* 'S' */ && data[start + 2] === 72 /* 'H' */ && data[start + 3] === 45 /* '-' */) {\n        const full = data.latin1Slice(op, end + 1);\n        const identRaw = start === op ? full : full.slice(start - op);\n        const m = RE_IDENT.exec(identRaw);\n        if (!m) throw new Error('Invalid identification string');\n        const header = {\n          greeting: start === op ? '' : full.slice(0, start - op),\n          identRaw,\n          versions: {\n            protocol: m[1],\n            software: m[2]\n          },\n          comments: m[3]\n        };\n\n        // Needed during handshake\n        this._remoteIdentRaw = Buffer.from(identRaw);\n        this._debug && this._debug(`Remote ident: ${inspect(identRaw)}`);\n        this._compatFlags = getCompatFlags(header);\n        this._buffer = undefined;\n        this._decipher = new NullDecipher(0, onKEXPayload.bind(this, {\n          firstPacket: true\n        }));\n        this._parse = parsePacket;\n        this._onHeader(header);\n        if (!this._destruct) {\n          // We disconnected inside _onHeader\n          return len;\n        }\n        kexinit(this);\n        return p + 1 - chunkOffset;\n      }\n\n      // Only allow pre-ident greetings when we're a client\n      if (this._server) throw new Error('Greetings from clients not permitted');\n      if (++lines > MAX_LINES) throw new Error('Max greeting lines exceeded');\n      needNL = false;\n      start = p + 1;\n      lineLen = 0;\n    } else if (needNL) {\n      throw new Error('Invalid header: expected newline');\n    } else if (++lineLen >= MAX_LINE_LEN) {\n      throw new Error('Header line too long');\n    }\n    end = p;\n  }\n  if (!this._buffer) this._buffer = bufferSlice(data, op);\n  return p - chunkOffset;\n}\nfunction parsePacket(chunk, p, len) {\n  return this._decipher.decrypt(chunk, p, len);\n}\nfunction onPayload(payload) {\n  // XXX: move this to the Decipher implementations?\n\n  this._onPacket();\n  if (payload.length === 0) {\n    this._debug && this._debug('Inbound: Skipping empty packet payload');\n    return;\n  }\n  payload = this._packetRW.read.read(payload);\n  const type = payload[0];\n  if (type === MESSAGE.USERAUTH_SUCCESS && !this._server && !this._authenticated) {\n    this._authenticated = true;\n    if (this._kex.negotiated.cs.compress === 'zlib@openssh.com') this._packetRW.write = new ZlibPacketWriter(this);\n    if (this._kex.negotiated.sc.compress === 'zlib@openssh.com') this._packetRW.read = new ZlibPacketReader();\n  }\n  const handler = MESSAGE_HANDLERS[type];\n  if (handler === undefined) {\n    this._debug && this._debug(`Inbound: Unsupported message type: ${type}`);\n    return;\n  }\n  return handler(this, payload);\n}\nfunction getCompatFlags(header) {\n  const software = header.versions.software;\n  let flags = 0;\n  for (const rule of COMPAT_CHECKS) {\n    if (typeof rule[0] === 'string') {\n      if (software === rule[0]) flags |= rule[1];\n    } else if (rule[0].test(software)) {\n      flags |= rule[1];\n    }\n  }\n  return flags;\n}\nfunction modesToBytes(modes) {\n  const keys = Object.keys(modes);\n  const bytes = Buffer.allocUnsafe(5 * keys.length + 1);\n  let b = 0;\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (key === 'TTY_OP_END') continue;\n    const opcode = TERMINAL_MODE[key];\n    if (opcode === undefined) continue;\n    const val = modes[key];\n    if (typeof val === 'number' && isFinite(val)) {\n      bytes[b++] = opcode;\n      bytes[b++] = val >>> 24;\n      bytes[b++] = val >>> 16;\n      bytes[b++] = val >>> 8;\n      bytes[b++] = val;\n    }\n  }\n  bytes[b++] = TERMINAL_MODE.TTY_OP_END;\n  if (b < bytes.length) return bufferSlice(bytes, 0, b);\n  return bytes;\n}\nfunction sendExtInfo(proto) {\n  let serverSigAlgs = 'ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521' + 'rsa-sha2-512,rsa-sha2-256,ssh-rsa,ssh-dss';\n  if (eddsaSupported) serverSigAlgs = `ssh-ed25519,${serverSigAlgs}`;\n  const algsLen = Buffer.byteLength(serverSigAlgs);\n  let p = proto._packetRW.write.allocStart;\n  const packet = proto._packetRW.write.alloc(1 + 4 + 4 + 15 + 4 + algsLen);\n  packet[p] = MESSAGE.EXT_INFO;\n  writeUInt32BE(packet, 1, ++p);\n  writeUInt32BE(packet, 15, p += 4);\n  packet.utf8Write('server-sig-algs', p += 4, 15);\n  writeUInt32BE(packet, algsLen, p += 15);\n  packet.utf8Write(serverSigAlgs, p += 4, algsLen);\n  proto._debug && proto._debug('Outbound: Sending EXT_INFO');\n  sendPacket(proto, proto._packetRW.write.finalize(packet));\n}\nmodule.exports = Protocol;","map":{"version":3,"names":["inspect","require","bindingAvailable","NullCipher","NullDecipher","COMPAT_CHECKS","DISCONNECT_REASON","eddsaSupported","MESSAGE","SIGNALS","TERMINAL_MODE","DEFAULT_KEXINIT_CLIENT","DEFAULT_KEXINIT_SERVER","KexInit","kexinit","onKEXPayload","parseKey","MESSAGE_HANDLERS","bufferCopy","bufferFill","bufferSlice","convertSignature","sendPacket","writeUInt32BE","PacketReader","PacketWriter","ZlibPacketReader","ZlibPacketWriter","MODULE_VER","version","VALID_DISCONNECT_REASONS","Map","Object","values","map","n","IDENT_RAW","Buffer","from","IDENT","MAX_LINE_LEN","MAX_LINES","PING_PAYLOAD","GLOBAL_REQUEST","NO_TERMINAL_MODES_BUFFER","TTY_OP_END","noop","Protocol","constructor","config","_this","onWrite","Error","_onWrite","data","onError","_onError","err","debug","_debug","msg","undefined","onHeader","_onHeader","arguments","onPacket","_onPacket","onHandshakeComplete","firstHandshake","_onHandshakeComplete","oldQueue","_queue","length","i","finalized","_packetRW","write","finalize","packet","_cipher","allocPacket","set","_server","_kex","remoteExtInfoEnabled","sendExtInfo","messageHandlers","_handlers","_onPayload","onPayload","bind","server","_banner","greeting","hostKeys","_hostKeys","slice","banner","offer","kex","concat","_kexinit","_offer","_decipher","_skipNextInboundPacket","read","_hostVerifier","hostVerifier","_parse","parseHeader","_buffer","_authsQueue","_authenticated","_remoteIdentRaw","sentIdent","ident","_identRaw","allocUnsafe","isBuffer","fullIdent","latin1Write","_compatFlags","toString","start","_destruct","reason","cleanup","free","parse","chunk","len","disconnect","pktLen","p","allocStartKEX","alloc","end","has","PROTOCOL_ERROR","DISCONNECT","fill","ping","allocStart","rekey","requestSuccess","REQUEST_SUCCESS","requestFailure","REQUEST_FAILURE","channelSuccess","chan","CHANNEL_SUCCESS","channelFailure","CHANNEL_FAILURE","channelEOF","CHANNEL_EOF","channelClose","CHANNEL_CLOSE","channelWindowAdjust","amount","CHANNEL_WINDOW_ADJUST","channelData","dataLen","byteLength","CHANNEL_DATA","utf8Write","channelExtData","type","CHANNEL_EXTENDED_DATA","channelOpenConfirm","remote","local","initWindow","maxPacket","CHANNEL_OPEN_CONFIRMATION","channelOpenFail","desc","descLen","CHANNEL_OPEN_FAILURE","service","name","nameLen","SERVICE_REQUEST","authPassword","username","password","newPassword","userLen","passLen","newPassLen","USERAUTH_REQUEST","push","authPK","pubKey","keyAlgo","cbSign","keyType","getPublicSSH","algoLen","pubKeyLen","sessionID","sesLen","payloadLen","signature","sigLen","authHostbased","hostname","userlocal","hostnameLen","userlocalLen","reqDataLen","authKeyboard","authNone","authInfoRes","responses","responsesTotalLen","responseLens","Array","USERAUTH_INFO_RESPONSE","tcpipForward","bindAddr","bindPort","wantReply","addrLen","cancelTcpipForward","openssh_streamLocalForward","socketPath","socketPathLen","openssh_cancelStreamLocalForward","directTcpip","cfg","srcLen","srcIP","dstLen","dstIP","CHANNEL_OPEN","dstPort","srcPort","openssh_directStreamLocal","pathLen","openssh_noMoreSessions","session","windowChange","rows","cols","height","width","CHANNEL_REQUEST","pty","term","modes","isArray","modesToBytes","termLen","modesLen","shell","exec","cmd","isBuf","cmdLen","signal","origSignal","toUpperCase","signalLen","env","key","val","keyLen","valLen","x11Forward","protocol","cookie","isBufProto","protoLen","isBufCookie","cookieLen","single","screen","subsystem","openssh_agentForward","openssh_hostKeysProve","keys","keysTotal","publicKeys","publicKey","buf","serviceAccept","svcName","svcNameLen","SERVICE_ACCEPT","bannerLen","USERAUTH_BANNER","forwardedTcpip","boundAddrLen","boundAddr","remoteAddrLen","remoteAddr","boundPort","remotePort","x11","originAddr","originPort","openssh_authAgent","openssh_forwardedStreamLocal","exitStatus","status","exitSignal","coreDumped","msgLen","authFailure","authMethods","isPartial","methods","toLowerCase","join","methodsLen","USERAUTH_FAILURE","shift","authSuccess","USERAUTH_SUCCESS","negotiated","cs","compress","sc","authPKOK","keyAlgoLen","USERAUTH_PK_OK","authPasswdChg","prompt","promptLen","USERAUTH_PASSWD_CHANGEREQ","authInfoReq","instructions","prompts","promptsLen","instrLen","USERAUTH_INFO_REQUEST","echo","RE_IDENT","chunkOffset","Uint8Array","buffer","byteOffset","op","needNL","lineLen","lines","ch","full","latin1Slice","identRaw","m","header","versions","software","comments","getCompatFlags","firstPacket","parsePacket","decrypt","payload","handler","flags","rule","test","bytes","b","opcode","isFinite","proto","serverSigAlgs","algsLen","EXT_INFO","module","exports"],"sources":["/home/user/node_modules/ssh2/lib/protocol/Protocol.js"],"sourcesContent":["/*\n  TODO:\n    * Replace `buffer._pos` usage in keyParser.js and elsewhere\n    * Utilize optional \"writev\" support when writing packets from\n      cipher.encrypt()\n    * Built-in support for automatic re-keying, on by default\n    * Revisit receiving unexpected/unknown packets\n      * Error (fatal or otherwise) or ignore or pass on to user (in some or all\n        cases)?\n      * Including server/client check for single directional packet types?\n      * Check packets for validity or bail as early as possible?\n    * Automatic re-key every 2**31 packets after the last key exchange (sent or\n      received), as suggested by RFC4344. OpenSSH currently does this.\n    * Automatic re-key every so many blocks depending on cipher. RFC4344:\n         Because of a birthday property of block ciphers and some modes of\n         operation, implementations must be careful not to encrypt too many\n         blocks with the same encryption key.\n\n         Let L be the block length (in bits) of an SSH encryption method's\n         block cipher (e.g., 128 for AES).  If L is at least 128, then, after\n         rekeying, an SSH implementation SHOULD NOT encrypt more than 2**(L/4)\n         blocks before rekeying again.  If L is at least 128, then SSH\n         implementations should also attempt to force a rekey before receiving\n         more than 2**(L/4) blocks.  If L is less than 128 (which is the case\n         for older ciphers such as 3DES, Blowfish, CAST-128, and IDEA), then,\n         although it may be too expensive to rekey every 2**(L/4) blocks, it\n         is still advisable for SSH implementations to follow the original\n         recommendation in [RFC4253]: rekey at least once for every gigabyte\n         of transmitted data.\n\n         Note that if L is less than or equal to 128, then the recommendation\n         in this subsection supersedes the recommendation in Section 3.1.  If\n         an SSH implementation uses a block cipher with a larger block size\n         (e.g., Rijndael with 256-bit blocks), then the recommendations in\n         Section 3.1 may supersede the recommendations in this subsection\n         (depending on the lengths of the packets).\n*/\n\n'use strict';\n\nconst { inspect } = require('util');\n\nconst { bindingAvailable, NullCipher, NullDecipher } = require('./crypto.js');\nconst {\n  COMPAT_CHECKS,\n  DISCONNECT_REASON,\n  eddsaSupported,\n  MESSAGE,\n  SIGNALS,\n  TERMINAL_MODE,\n} = require('./constants.js');\nconst {\n  DEFAULT_KEXINIT_CLIENT,\n  DEFAULT_KEXINIT_SERVER,\n  KexInit,\n  kexinit,\n  onKEXPayload,\n} = require('./kex.js');\nconst {\n  parseKey,\n} = require('./keyParser.js');\nconst MESSAGE_HANDLERS = require('./handlers.js');\nconst {\n  bufferCopy,\n  bufferFill,\n  bufferSlice,\n  convertSignature,\n  sendPacket,\n  writeUInt32BE,\n} = require('./utils.js');\nconst {\n  PacketReader,\n  PacketWriter,\n  ZlibPacketReader,\n  ZlibPacketWriter,\n} = require('./zlib.js');\n\nconst MODULE_VER = require('../../package.json').version;\n\nconst VALID_DISCONNECT_REASONS = new Map(\n  Object.values(DISCONNECT_REASON).map((n) => [n, 1])\n);\nconst IDENT_RAW = Buffer.from(`SSH-2.0-ssh2js${MODULE_VER}`);\nconst IDENT = Buffer.from(`${IDENT_RAW}\\r\\n`);\nconst MAX_LINE_LEN = 8192;\nconst MAX_LINES = 1024;\nconst PING_PAYLOAD = Buffer.from([\n  MESSAGE.GLOBAL_REQUEST,\n  // \"keepalive@openssh.com\"\n  0, 0, 0, 21,\n    107, 101, 101, 112, 97, 108, 105, 118, 101, 64, 111, 112, 101, 110, 115,\n    115, 104, 46, 99, 111, 109,\n  // Request a reply\n  1,\n]);\nconst NO_TERMINAL_MODES_BUFFER = Buffer.from([ TERMINAL_MODE.TTY_OP_END ]);\n\nfunction noop() {}\n\n/*\n  Inbound:\n    * kexinit payload (needed only until exchange hash is generated)\n    * raw ident\n    * rekey packet queue\n    * expected packet (implemented as separate _parse() function?)\n  Outbound:\n    * kexinit payload (needed only until exchange hash is generated)\n    * rekey packet queue\n    * kex secret (needed only until NEWKEYS)\n    * exchange hash (needed only until NEWKEYS)\n    * session ID (set to exchange hash from initial handshake)\n*/\nclass Protocol {\n  constructor(config) {\n    const onWrite = config.onWrite;\n    if (typeof onWrite !== 'function')\n      throw new Error('Missing onWrite function');\n    this._onWrite = (data) => { onWrite(data); };\n\n    const onError = config.onError;\n    if (typeof onError !== 'function')\n      throw new Error('Missing onError function');\n    this._onError = (err) => { onError(err); };\n\n    const debug = config.debug;\n    this._debug = (typeof debug === 'function'\n                   ? (msg) => { debug(msg); }\n                   : undefined);\n\n    const onHeader = config.onHeader;\n    this._onHeader = (typeof onHeader === 'function'\n                      ? (...args) => { onHeader(...args); }\n                      : noop);\n\n    const onPacket = config.onPacket;\n    this._onPacket = (typeof onPacket === 'function'\n                      ? () => { onPacket(); }\n                      : noop);\n\n    let onHandshakeComplete = config.onHandshakeComplete;\n    if (typeof onHandshakeComplete !== 'function')\n      onHandshakeComplete = noop;\n    let firstHandshake;\n    this._onHandshakeComplete = (...args) => {\n      this._debug && this._debug('Handshake completed');\n      if (firstHandshake === undefined)\n        firstHandshake = true;\n      else\n        firstHandshake = false;\n\n      // Process packets queued during a rekey where necessary\n      const oldQueue = this._queue;\n      if (oldQueue) {\n        this._queue = undefined;\n        this._debug && this._debug(\n          `Draining outbound queue (${oldQueue.length}) ...`\n        );\n        for (let i = 0; i < oldQueue.length; ++i) {\n          const data = oldQueue[i];\n          // data === payload only\n\n          // XXX: hacky\n          let finalized = this._packetRW.write.finalize(data);\n          if (finalized === data) {\n            const packet = this._cipher.allocPacket(data.length);\n            packet.set(data, 5);\n            finalized = packet;\n          }\n\n          sendPacket(this, finalized);\n        }\n        this._debug && this._debug('... finished draining outbound queue');\n      }\n\n      if (firstHandshake && this._server && this._kex.remoteExtInfoEnabled)\n        sendExtInfo(this);\n\n      onHandshakeComplete(...args);\n    };\n    this._queue = undefined;\n\n    const messageHandlers = config.messageHandlers;\n    if (typeof messageHandlers === 'object' && messageHandlers !== null)\n      this._handlers = messageHandlers;\n    else\n      this._handlers = {};\n\n    this._onPayload = onPayload.bind(this);\n\n    this._server = !!config.server;\n    this._banner = undefined;\n    let greeting;\n    if (this._server) {\n      if (typeof config.hostKeys !== 'object' || config.hostKeys === null)\n        throw new Error('Missing server host key(s)');\n      this._hostKeys = config.hostKeys;\n\n      // Greeting displayed before the ssh identification string is sent, this\n      // is usually ignored by most clients\n      if (typeof config.greeting === 'string' && config.greeting.length) {\n        greeting = (config.greeting.slice(-2) === '\\r\\n'\n                    ? config.greeting\n                    : `${config.greeting}\\r\\n`);\n      }\n\n      // Banner shown after the handshake completes, but before user\n      // authentication begins\n      if (typeof config.banner === 'string' && config.banner.length) {\n        this._banner = (config.banner.slice(-2) === '\\r\\n'\n                        ? config.banner\n                        : `${config.banner}\\r\\n`);\n      }\n    } else {\n      this._hostKeys = undefined;\n    }\n\n    let offer = config.offer;\n    if (typeof offer !== 'object' || offer === null) {\n      offer = (this._server ? DEFAULT_KEXINIT_SERVER : DEFAULT_KEXINIT_CLIENT);\n    } else if (offer.constructor !== KexInit) {\n      if (!this._server)\n        offer.kex = offer.kex.concat(['ext-info-c']);\n      offer = new KexInit(offer);\n    }\n    this._kex = undefined;\n    this._kexinit = undefined;\n    this._offer = offer;\n    this._cipher = new NullCipher(0, this._onWrite);\n    this._decipher = undefined;\n    this._skipNextInboundPacket = false;\n    this._packetRW = {\n      read: new PacketReader(),\n      write: new PacketWriter(this),\n    };\n    this._hostVerifier = (!this._server\n                           && typeof config.hostVerifier === 'function'\n                          ? config.hostVerifier\n                          : undefined);\n\n    this._parse = parseHeader;\n    this._buffer = undefined;\n    this._authsQueue = [];\n    this._authenticated = false;\n    this._remoteIdentRaw = undefined;\n    let sentIdent;\n    if (typeof config.ident === 'string') {\n      this._identRaw = Buffer.from(`SSH-2.0-${config.ident}`);\n\n      sentIdent = Buffer.allocUnsafe(this._identRaw.length + 2);\n      sentIdent.set(this._identRaw, 0);\n      sentIdent[sentIdent.length - 2] = 13; // '\\r'\n      sentIdent[sentIdent.length - 1] = 10; // '\\n'\n    } else if (Buffer.isBuffer(config.ident)) {\n      const fullIdent = Buffer.allocUnsafe(8 + config.ident.length);\n      fullIdent.latin1Write('SSH-2.0-', 0, 8);\n      fullIdent.set(config.ident, 8);\n      this._identRaw = fullIdent;\n\n      sentIdent = Buffer.allocUnsafe(fullIdent.length + 2);\n      sentIdent.set(fullIdent, 0);\n      sentIdent[sentIdent.length - 2] = 13; // '\\r'\n      sentIdent[sentIdent.length - 1] = 10; // '\\n'\n    } else {\n      this._identRaw = IDENT_RAW;\n      sentIdent = IDENT;\n    }\n    this._compatFlags = 0;\n\n    if (this._debug) {\n      if (bindingAvailable)\n        this._debug('Custom crypto binding available');\n      else\n        this._debug('Custom crypto binding not available');\n    }\n\n    this._debug && this._debug(\n      `Local ident: ${inspect(this._identRaw.toString())}`\n    );\n    this.start = () => {\n      this.start = undefined;\n      if (greeting)\n        this._onWrite(greeting);\n      this._onWrite(sentIdent);\n    };\n  }\n  _destruct(reason) {\n    this._packetRW.read.cleanup();\n    this._packetRW.write.cleanup();\n    this._cipher && this._cipher.free();\n    this._decipher && this._decipher.free();\n    if (typeof reason !== 'string' || reason.length === 0)\n      reason = 'fatal error';\n    this.parse = () => {\n      throw new Error(`Instance unusable after ${reason}`);\n    };\n    this._onWrite = () => {\n      throw new Error(`Instance unusable after ${reason}`);\n    };\n    this._destruct = undefined;\n  }\n  cleanup() {\n    this._destruct && this._destruct();\n  }\n  parse(chunk, i, len) {\n    while (i < len)\n      i = this._parse(chunk, i, len);\n  }\n\n  // Protocol message API\n\n  // ===========================================================================\n  // Common/Shared =============================================================\n  // ===========================================================================\n\n  // Global\n  // ------\n  disconnect(reason) {\n    const pktLen = 1 + 4 + 4 + 4;\n    // We don't use _packetRW.write.* here because we need to make sure that\n    // we always get a full packet allocated because this message can be sent\n    // at any time -- even during a key exchange\n    let p = this._packetRW.write.allocStartKEX;\n    const packet = this._packetRW.write.alloc(pktLen, true);\n    const end = p + pktLen;\n\n    if (!VALID_DISCONNECT_REASONS.has(reason))\n      reason = DISCONNECT_REASON.PROTOCOL_ERROR;\n\n    packet[p] = MESSAGE.DISCONNECT;\n    writeUInt32BE(packet, reason, ++p);\n    packet.fill(0, p += 4, end);\n\n    this._debug && this._debug(`Outbound: Sending DISCONNECT (${reason})`);\n    sendPacket(this, this._packetRW.write.finalize(packet, true), true);\n  }\n  ping() {\n    const p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(PING_PAYLOAD.length);\n\n    packet.set(PING_PAYLOAD, p);\n\n    this._debug && this._debug(\n      'Outbound: Sending ping (GLOBAL_REQUEST: keepalive@openssh.com)'\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  rekey() {\n    if (this._kexinit === undefined) {\n      this._debug && this._debug('Outbound: Initiated explicit rekey');\n      this._queue = [];\n      kexinit(this);\n    } else {\n      this._debug && this._debug('Outbound: Ignoring rekey during handshake');\n    }\n  }\n\n  // 'ssh-connection' service-specific\n  // ---------------------------------\n  requestSuccess(data) {\n    let p = this._packetRW.write.allocStart;\n    let packet;\n    if (Buffer.isBuffer(data)) {\n      packet = this._packetRW.write.alloc(1 + data.length);\n\n      packet[p] = MESSAGE.REQUEST_SUCCESS;\n\n      packet.set(data, ++p);\n    } else {\n      packet = this._packetRW.write.alloc(1);\n\n      packet[p] = MESSAGE.REQUEST_SUCCESS;\n    }\n\n    this._debug && this._debug('Outbound: Sending REQUEST_SUCCESS');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  requestFailure() {\n    const p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1);\n\n    packet[p] = MESSAGE.REQUEST_FAILURE;\n\n    this._debug && this._debug('Outbound: Sending REQUEST_FAILURE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelSuccess(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_SUCCESS;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    this._debug && this._debug(`Outbound: Sending CHANNEL_SUCCESS (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelFailure(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_FAILURE;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    this._debug && this._debug(`Outbound: Sending CHANNEL_FAILURE (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelEOF(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_EOF;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    this._debug && this._debug(`Outbound: Sending CHANNEL_EOF (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelClose(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_CLOSE;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    this._debug && this._debug(`Outbound: Sending CHANNEL_CLOSE (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelWindowAdjust(chan, amount) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_WINDOW_ADJUST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, amount, p += 4);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_WINDOW_ADJUST (r:${chan}, ${amount})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelData(chan, data) {\n    const isBuffer = Buffer.isBuffer(data);\n    const dataLen = (isBuffer ? data.length : Buffer.byteLength(data));\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + dataLen);\n\n    packet[p] = MESSAGE.CHANNEL_DATA;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, dataLen, p += 4);\n\n    if (isBuffer)\n      packet.set(data, p += 4);\n    else\n      packet.utf8Write(data, p += 4, dataLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_DATA (r:${chan}, ${dataLen})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelExtData(chan, data, type) {\n    const isBuffer = Buffer.isBuffer(data);\n    const dataLen = (isBuffer ? data.length : Buffer.byteLength(data));\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + dataLen);\n\n    packet[p] = MESSAGE.CHANNEL_EXTENDED_DATA;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, type, p += 4);\n\n    writeUInt32BE(packet, dataLen, p += 4);\n\n    if (isBuffer)\n      packet.set(data, p += 4);\n    else\n      packet.utf8Write(data, p += 4, dataLen);\n\n    this._debug\n      && this._debug(`Outbound: Sending CHANNEL_EXTENDED_DATA (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelOpenConfirm(remote, local, initWindow, maxPacket) {\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN_CONFIRMATION;\n\n    writeUInt32BE(packet, remote, ++p);\n\n    writeUInt32BE(packet, local, p += 4);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_OPEN_CONFIRMATION (r:${remote}, l:${local})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelOpenFail(remote, reason, desc) {\n    if (typeof desc !== 'string')\n      desc = '';\n\n    const descLen = Buffer.byteLength(desc);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + descLen + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN_FAILURE;\n\n    writeUInt32BE(packet, remote, ++p);\n\n    writeUInt32BE(packet, reason, p += 4);\n\n    writeUInt32BE(packet, descLen, p += 4);\n\n    p += 4;\n    if (descLen) {\n      packet.utf8Write(desc, p, descLen);\n      p += descLen;\n    }\n\n    writeUInt32BE(packet, 0, p); // Empty language tag\n\n    this._debug\n      && this._debug(`Outbound: Sending CHANNEL_OPEN_FAILURE (r:${remote})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // ===========================================================================\n  // Client-specific ===========================================================\n  // ===========================================================================\n\n  // Global\n  // ------\n  service(name) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const nameLen = Buffer.byteLength(name);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + nameLen);\n\n    packet[p] = MESSAGE.SERVICE_REQUEST;\n\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(name, p += 4, nameLen);\n\n    this._debug && this._debug(`Outbound: Sending SERVICE_REQUEST (${name})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // 'ssh-userauth' service-specific\n  // -------------------------------\n  authPassword(username, password, newPassword) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const userLen = Buffer.byteLength(username);\n    const passLen = Buffer.byteLength(password);\n    const newPassLen = (newPassword ? Buffer.byteLength(newPassword) : 0);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + userLen + 4 + 14 + 4 + 8 + 1 + 4 + passLen\n        + (newPassword ? 4 + newPassLen : 0)\n    );\n\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n\n    writeUInt32BE(packet, 8, p += 14);\n    packet.utf8Write('password', p += 4, 8);\n\n    packet[p += 8] = (newPassword ? 1 : 0);\n\n    writeUInt32BE(packet, passLen, ++p);\n    if (Buffer.isBuffer(password))\n      bufferCopy(password, packet, 0, passLen, p += 4);\n    else\n      packet.utf8Write(password, p += 4, passLen);\n\n    if (newPassword) {\n      writeUInt32BE(packet, newPassLen, p += passLen);\n      if (Buffer.isBuffer(newPassword))\n        bufferCopy(newPassword, packet, 0, newPassLen, p += 4);\n      else\n        packet.utf8Write(newPassword, p += 4, newPassLen);\n      this._debug && this._debug(\n        'Outbound: Sending USERAUTH_REQUEST (changed password)'\n      );\n    } else {\n      this._debug && this._debug(\n        'Outbound: Sending USERAUTH_REQUEST (password)'\n      );\n    }\n\n    this._authsQueue.push('password');\n\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authPK(username, pubKey, keyAlgo, cbSign) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    pubKey = parseKey(pubKey);\n    if (pubKey instanceof Error)\n      throw new Error('Invalid key');\n\n    const keyType = pubKey.type;\n    pubKey = pubKey.getPublicSSH();\n\n    if (typeof keyAlgo === 'function') {\n      cbSign = keyAlgo;\n      keyAlgo = undefined;\n    }\n    if (!keyAlgo)\n      keyAlgo = keyType;\n\n    const userLen = Buffer.byteLength(username);\n    const algoLen = Buffer.byteLength(keyAlgo);\n    const pubKeyLen = pubKey.length;\n    const sessionID = this._kex.sessionID;\n    const sesLen = sessionID.length;\n    const payloadLen =\n      (cbSign ? 4 + sesLen : 0)\n        + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen;\n    let packet;\n    let p;\n    if (cbSign) {\n      packet = Buffer.allocUnsafe(payloadLen);\n      p = 0;\n      writeUInt32BE(packet, sesLen, p);\n      packet.set(sessionID, p += 4);\n      p += sesLen;\n    } else {\n      packet = this._packetRW.write.alloc(payloadLen);\n      p = this._packetRW.write.allocStart;\n    }\n\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n\n    writeUInt32BE(packet, 9, p += 14);\n    packet.utf8Write('publickey', p += 4, 9);\n\n    packet[p += 9] = (cbSign ? 1 : 0);\n\n    writeUInt32BE(packet, algoLen, ++p);\n    packet.utf8Write(keyAlgo, p += 4, algoLen);\n\n    writeUInt32BE(packet, pubKeyLen, p += algoLen);\n    packet.set(pubKey, p += 4);\n\n    if (!cbSign) {\n      this._authsQueue.push('publickey');\n\n      this._debug && this._debug(\n        'Outbound: Sending USERAUTH_REQUEST (publickey -- check)'\n      );\n      sendPacket(this, this._packetRW.write.finalize(packet));\n      return;\n    }\n\n    cbSign(packet, (signature) => {\n      signature = convertSignature(signature, keyType);\n      if (signature === false)\n        throw new Error('Error while converting handshake signature');\n\n      const sigLen = signature.length;\n      p = this._packetRW.write.allocStart;\n      packet = this._packetRW.write.alloc(\n        1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen + 4\n          + 4 + algoLen + 4 + sigLen\n      );\n\n      // TODO: simply copy from original \"packet\" to new `packet` to avoid\n      // having to write each individual field a second time?\n      packet[p] = MESSAGE.USERAUTH_REQUEST;\n\n      writeUInt32BE(packet, userLen, ++p);\n      packet.utf8Write(username, p += 4, userLen);\n\n      writeUInt32BE(packet, 14, p += userLen);\n      packet.utf8Write('ssh-connection', p += 4, 14);\n\n      writeUInt32BE(packet, 9, p += 14);\n      packet.utf8Write('publickey', p += 4, 9);\n\n      packet[p += 9] = 1;\n\n      writeUInt32BE(packet, algoLen, ++p);\n      packet.utf8Write(keyAlgo, p += 4, algoLen);\n\n      writeUInt32BE(packet, pubKeyLen, p += algoLen);\n      packet.set(pubKey, p += 4);\n\n      writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += pubKeyLen);\n\n      writeUInt32BE(packet, algoLen, p += 4);\n      packet.utf8Write(keyAlgo, p += 4, algoLen);\n\n      writeUInt32BE(packet, sigLen, p += algoLen);\n      packet.set(signature, p += 4);\n\n      // Servers shouldn't send packet type 60 in response to signed publickey\n      // attempts, but if they do, interpret as type 60.\n      this._authsQueue.push('publickey');\n\n      this._debug && this._debug(\n        'Outbound: Sending USERAUTH_REQUEST (publickey)'\n      );\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    });\n  }\n  authHostbased(username, pubKey, hostname, userlocal, keyAlgo, cbSign) {\n    // TODO: Make DRY by sharing similar code with authPK()\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    pubKey = parseKey(pubKey);\n    if (pubKey instanceof Error)\n      throw new Error('Invalid key');\n\n    const keyType = pubKey.type;\n    pubKey = pubKey.getPublicSSH();\n\n    if (typeof keyAlgo === 'function') {\n      cbSign = keyAlgo;\n      keyAlgo = undefined;\n    }\n    if (!keyAlgo)\n      keyAlgo = keyType;\n\n    const userLen = Buffer.byteLength(username);\n    const algoLen = Buffer.byteLength(keyAlgo);\n    const pubKeyLen = pubKey.length;\n    const sessionID = this._kex.sessionID;\n    const sesLen = sessionID.length;\n    const hostnameLen = Buffer.byteLength(hostname);\n    const userlocalLen = Buffer.byteLength(userlocal);\n    const data = Buffer.allocUnsafe(\n      4 + sesLen + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 4 + algoLen\n        + 4 + pubKeyLen + 4 + hostnameLen + 4 + userlocalLen\n    );\n    let p = 0;\n\n    writeUInt32BE(data, sesLen, p);\n    data.set(sessionID, p += 4);\n\n    data[p += sesLen] = MESSAGE.USERAUTH_REQUEST;\n\n    writeUInt32BE(data, userLen, ++p);\n    data.utf8Write(username, p += 4, userLen);\n\n    writeUInt32BE(data, 14, p += userLen);\n    data.utf8Write('ssh-connection', p += 4, 14);\n\n    writeUInt32BE(data, 9, p += 14);\n    data.utf8Write('hostbased', p += 4, 9);\n\n    writeUInt32BE(data, algoLen, p += 9);\n    data.utf8Write(keyAlgo, p += 4, algoLen);\n\n    writeUInt32BE(data, pubKeyLen, p += algoLen);\n    data.set(pubKey, p += 4);\n\n    writeUInt32BE(data, hostnameLen, p += pubKeyLen);\n    data.utf8Write(hostname, p += 4, hostnameLen);\n\n    writeUInt32BE(data, userlocalLen, p += hostnameLen);\n    data.utf8Write(userlocal, p += 4, userlocalLen);\n\n    cbSign(data, (signature) => {\n      signature = convertSignature(signature, keyType);\n      if (!signature)\n        throw new Error('Error while converting handshake signature');\n\n      const sigLen = signature.length;\n      const reqDataLen = (data.length - sesLen - 4);\n      p = this._packetRW.write.allocStart;\n      const packet = this._packetRW.write.alloc(\n        reqDataLen + 4 + 4 + algoLen + 4 + sigLen\n      );\n\n      bufferCopy(data, packet, 4 + sesLen, data.length, p);\n\n      writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += reqDataLen);\n      writeUInt32BE(packet, algoLen, p += 4);\n      packet.utf8Write(keyAlgo, p += 4, algoLen);\n      writeUInt32BE(packet, sigLen, p += algoLen);\n      packet.set(signature, p += 4);\n\n      this._authsQueue.push('hostbased');\n\n      this._debug && this._debug(\n        'Outbound: Sending USERAUTH_REQUEST (hostbased)'\n      );\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    });\n  }\n  authKeyboard(username) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const userLen = Buffer.byteLength(username);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + userLen + 4 + 14 + 4 + 20 + 4 + 4\n    );\n\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n\n    writeUInt32BE(packet, 20, p += 14);\n    packet.utf8Write('keyboard-interactive', p += 4, 20);\n\n    writeUInt32BE(packet, 0, p += 20);\n\n    writeUInt32BE(packet, 0, p += 4);\n\n    this._authsQueue.push('keyboard-interactive');\n\n    this._debug && this._debug(\n      'Outbound: Sending USERAUTH_REQUEST (keyboard-interactive)'\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authNone(username) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const userLen = Buffer.byteLength(username);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 4);\n\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n\n    writeUInt32BE(packet, 4, p += 14);\n    packet.utf8Write('none', p += 4, 4);\n\n    this._authsQueue.push('none');\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (none)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authInfoRes(responses) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    let responsesTotalLen = 0;\n    let responseLens;\n\n    if (responses) {\n      responseLens = new Array(responses.length);\n      for (let i = 0; i < responses.length; ++i) {\n        const len = Buffer.byteLength(responses[i]);\n        responseLens[i] = len;\n        responsesTotalLen += 4 + len;\n      }\n    }\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + responsesTotalLen);\n\n    packet[p] = MESSAGE.USERAUTH_INFO_RESPONSE;\n\n    if (responses) {\n      writeUInt32BE(packet, responses.length, ++p);\n      p += 4;\n      for (let i = 0; i < responses.length; ++i) {\n        const len = responseLens[i];\n        writeUInt32BE(packet, len, p);\n        p += 4;\n        if (len) {\n          packet.utf8Write(responses[i], p, len);\n          p += len;\n        }\n      }\n    } else {\n      writeUInt32BE(packet, 0, ++p);\n    }\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_INFO_RESPONSE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // 'ssh-connection' service-specific\n  // ---------------------------------\n  tcpipForward(bindAddr, bindPort, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const addrLen = Buffer.byteLength(bindAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 13 + 1 + 4 + addrLen + 4);\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n\n    writeUInt32BE(packet, 13, ++p);\n    packet.utf8Write('tcpip-forward', p += 4, 13);\n\n    packet[p += 13] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, addrLen, ++p);\n    packet.utf8Write(bindAddr, p += 4, addrLen);\n\n    writeUInt32BE(packet, bindPort, p += addrLen);\n\n    this._debug\n      && this._debug('Outbound: Sending GLOBAL_REQUEST (tcpip-forward)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  cancelTcpipForward(bindAddr, bindPort, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const addrLen = Buffer.byteLength(bindAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 20 + 1 + 4 + addrLen + 4);\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n\n    writeUInt32BE(packet, 20, ++p);\n    packet.utf8Write('cancel-tcpip-forward', p += 4, 20);\n\n    packet[p += 20] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, addrLen, ++p);\n    packet.utf8Write(bindAddr, p += 4, addrLen);\n\n    writeUInt32BE(packet, bindPort, p += addrLen);\n\n    this._debug\n      && this._debug('Outbound: Sending GLOBAL_REQUEST (cancel-tcpip-forward)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_streamLocalForward(socketPath, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const socketPathLen = Buffer.byteLength(socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 31 + 1 + 4 + socketPathLen\n    );\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n\n    writeUInt32BE(packet, 31, ++p);\n    packet.utf8Write('streamlocal-forward@openssh.com', p += 4, 31);\n\n    packet[p += 31] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, socketPathLen, ++p);\n    packet.utf8Write(socketPath, p += 4, socketPathLen);\n\n    this._debug && this._debug(\n      'Outbound: Sending GLOBAL_REQUEST (streamlocal-forward@openssh.com)'\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_cancelStreamLocalForward(socketPath, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const socketPathLen = Buffer.byteLength(socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 38 + 1 + 4 + socketPathLen\n    );\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n\n    writeUInt32BE(packet, 38, ++p);\n    packet.utf8Write('cancel-streamlocal-forward@openssh.com', p += 4, 38);\n\n    packet[p += 38] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, socketPathLen, ++p);\n    packet.utf8Write(socketPath, p += 4, socketPathLen);\n\n    if (this._debug) {\n      this._debug(\n        'Outbound: Sending GLOBAL_REQUEST '\n          + '(cancel-streamlocal-forward@openssh.com)'\n      );\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  directTcpip(chan, initWindow, maxPacket, cfg) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const srcLen = Buffer.byteLength(cfg.srcIP);\n    const dstLen = Buffer.byteLength(cfg.dstIP);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 12 + 4 + 4 + 4 + 4 + srcLen + 4 + 4 + dstLen + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 12, ++p);\n    packet.utf8Write('direct-tcpip', p += 4, 12);\n\n    writeUInt32BE(packet, chan, p += 12);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    writeUInt32BE(packet, dstLen, p += 4);\n    packet.utf8Write(cfg.dstIP, p += 4, dstLen);\n\n    writeUInt32BE(packet, cfg.dstPort, p += dstLen);\n\n    writeUInt32BE(packet, srcLen, p += 4);\n    packet.utf8Write(cfg.srcIP, p += 4, srcLen);\n\n    writeUInt32BE(packet, cfg.srcPort, p += srcLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-tcpip)`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_directStreamLocal(chan, initWindow, maxPacket, cfg) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    const pathLen = Buffer.byteLength(cfg.socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 30 + 4 + 4 + 4 + 4 + pathLen + 4 + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 30, ++p);\n    packet.utf8Write('direct-streamlocal@openssh.com', p += 4, 30);\n\n    writeUInt32BE(packet, chan, p += 30);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    writeUInt32BE(packet, pathLen, p += 4);\n    packet.utf8Write(cfg.socketPath, p += 4, pathLen);\n\n    // zero-fill reserved fields (string and uint32)\n    bufferFill(packet, 0, p += pathLen, p + 8);\n\n    if (this._debug) {\n      this._debug(\n        'Outbound: Sending CHANNEL_OPEN '\n          + `(r:${chan}, direct-streamlocal@openssh.com)`\n      );\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_noMoreSessions(wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 28 + 1);\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n\n    writeUInt32BE(packet, 28, ++p);\n    packet.utf8Write('no-more-sessions@openssh.com', p += 4, 28);\n\n    packet[p += 28] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    this._debug && this._debug(\n      'Outbound: Sending GLOBAL_REQUEST (no-more-sessions@openssh.com)'\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  session(chan, initWindow, maxPacket) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 7 + 4 + 4 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 7, ++p);\n    packet.utf8Write('session', p += 4, 7);\n\n    writeUInt32BE(packet, chan, p += 7);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    this._debug\n      && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, session)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  windowChange(chan, rows, cols, height, width) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 13, p += 4);\n    packet.utf8Write('window-change', p += 4, 13);\n\n    packet[p += 13] = 0;\n\n    writeUInt32BE(packet, cols, ++p);\n\n    writeUInt32BE(packet, rows, p += 4);\n\n    writeUInt32BE(packet, width, p += 4);\n\n    writeUInt32BE(packet, height, p += 4);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, window-change)`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  pty(chan, rows, cols, height, width, term, modes, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    if (!term || !term.length)\n      term = 'vt100';\n    if (modes\n        && !Buffer.isBuffer(modes)\n        && !Array.isArray(modes)\n        && typeof modes === 'object'\n        && modes !== null) {\n      modes = modesToBytes(modes);\n    }\n    if (!modes || !modes.length)\n      modes = NO_TERMINAL_MODES_BUFFER;\n\n    const termLen = term.length;\n    const modesLen = modes.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 4 + 7 + 1 + 4 + termLen + 4 + 4 + 4 + 4 + 4 + modesLen\n    );\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 7, p += 4);\n    packet.utf8Write('pty-req', p += 4, 7);\n\n    packet[p += 7] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, termLen, ++p);\n    packet.utf8Write(term, p += 4, termLen);\n\n    writeUInt32BE(packet, cols, p += termLen);\n\n    writeUInt32BE(packet, rows, p += 4);\n\n    writeUInt32BE(packet, width, p += 4);\n\n    writeUInt32BE(packet, height, p += 4);\n\n    writeUInt32BE(packet, modesLen, p += 4);\n    p += 4;\n    if (Array.isArray(modes)) {\n      for (let i = 0; i < modesLen; ++i)\n        packet[p++] = modes[i];\n    } else if (Buffer.isBuffer(modes)) {\n      packet.set(modes, p);\n    }\n\n    this._debug\n      && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, pty-req)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  shell(chan, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 5 + 1);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 5, p += 4);\n    packet.utf8Write('shell', p += 4, 5);\n\n    packet[p += 5] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    this._debug\n      && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, shell)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  exec(chan, cmd, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const isBuf = Buffer.isBuffer(cmd);\n    const cmdLen = (isBuf ? cmd.length : Buffer.byteLength(cmd));\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 1 + 4 + cmdLen);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 4, p += 4);\n    packet.utf8Write('exec', p += 4, 4);\n\n    packet[p += 4] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, cmdLen, ++p);\n    if (isBuf)\n      packet.set(cmd, p += 4);\n    else\n      packet.utf8Write(cmd, p += 4, cmdLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exec: ${cmd})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  signal(chan, signal) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const origSignal = signal;\n\n    signal = signal.toUpperCase();\n    if (signal.slice(0, 3) === 'SIG')\n      signal = signal.slice(3);\n\n    if (SIGNALS[signal] !== 1)\n      throw new Error(`Invalid signal: ${origSignal}`);\n\n    const signalLen = signal.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 4 + 6 + 1 + 4 + signalLen\n    );\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 6, p += 4);\n    packet.utf8Write('signal', p += 4, 6);\n\n    packet[p += 6] = 0;\n\n    writeUInt32BE(packet, signalLen, ++p);\n    packet.utf8Write(signal, p += 4, signalLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, signal: ${signal})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  env(chan, key, val, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const keyLen = Buffer.byteLength(key);\n    const isBuf = Buffer.isBuffer(val);\n    const valLen = (isBuf ? val.length : Buffer.byteLength(val));\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 4 + 3 + 1 + 4 + keyLen + 4 + valLen\n    );\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 3, p += 4);\n    packet.utf8Write('env', p += 4, 3);\n\n    packet[p += 3] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, keyLen, ++p);\n    packet.utf8Write(key, p += 4, keyLen);\n\n    writeUInt32BE(packet, valLen, p += keyLen);\n    if (isBuf)\n      packet.set(val, p += 4);\n    else\n      packet.utf8Write(val, p += 4, valLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, env: ${key}=${val})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  x11Forward(chan, cfg, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const protocol = cfg.protocol;\n    const cookie = cfg.cookie;\n    const isBufProto = Buffer.isBuffer(protocol);\n    const protoLen = (isBufProto\n                      ? protocol.length\n                      : Buffer.byteLength(protocol));\n    const isBufCookie = Buffer.isBuffer(cookie);\n    const cookieLen = (isBufCookie\n                       ? cookie.length\n                       : Buffer.byteLength(cookie));\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 4 + 7 + 1 + 1 + 4 + protoLen + 4 + cookieLen + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 7, p += 4);\n    packet.utf8Write('x11-req', p += 4, 7);\n\n    packet[p += 7] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    packet[++p] = (cfg.single ? 1 : 0);\n\n    writeUInt32BE(packet, protoLen, ++p);\n    if (isBufProto)\n      packet.set(protocol, p += 4);\n    else\n      packet.utf8Write(protocol, p += 4, protoLen);\n\n    writeUInt32BE(packet, cookieLen, p += protoLen);\n    if (isBufCookie)\n      packet.set(cookie, p += 4);\n    else\n      packet.latin1Write(cookie, p += 4, cookieLen);\n\n    writeUInt32BE(packet, (cfg.screen || 0), p += cookieLen);\n\n    this._debug\n      && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, x11-req)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  subsystem(chan, name, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n    const nameLen = Buffer.byteLength(name);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 9 + 1 + 4 + nameLen);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 9, p += 4);\n    packet.utf8Write('subsystem', p += 4, 9);\n\n    packet[p += 9] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(name, p += 4, nameLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, subsystem: ${name})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_agentForward(chan, wantReply) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 26 + 1);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 26, p += 4);\n    packet.utf8Write('auth-agent-req@openssh.com', p += 4, 26);\n\n    packet[p += 26] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n    if (this._debug) {\n      this._debug(\n        'Outbound: Sending CHANNEL_REQUEST '\n          + `(r:${chan}, auth-agent-req@openssh.com)`\n      );\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_hostKeysProve(keys) {\n    if (this._server)\n      throw new Error('Client-only method called in server mode');\n\n    let keysTotal = 0;\n    const publicKeys = [];\n    for (const key of keys) {\n      const publicKey = key.getPublicSSH();\n      keysTotal += 4 + publicKey.length;\n      publicKeys.push(publicKey);\n    }\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 29 + 1 + keysTotal);\n\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n\n    writeUInt32BE(packet, 29, ++p);\n    packet.utf8Write('hostkeys-prove-00@openssh.com', p += 4, 29);\n\n    packet[p += 29] = 1; // want reply\n\n    ++p;\n    for (const buf of publicKeys) {\n      writeUInt32BE(packet, buf.length, p);\n      bufferCopy(buf, packet, 0, buf.length, p += 4);\n      p += buf.length;\n    }\n\n    if (this._debug) {\n      this._debug(\n        'Outbound: Sending GLOBAL_REQUEST (hostkeys-prove-00@openssh.com)'\n      );\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // ===========================================================================\n  // Server-specific ===========================================================\n  // ===========================================================================\n\n  // Global\n  // ------\n  serviceAccept(svcName) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    const svcNameLen = Buffer.byteLength(svcName);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + svcNameLen);\n\n    packet[p] = MESSAGE.SERVICE_ACCEPT;\n\n    writeUInt32BE(packet, svcNameLen, ++p);\n    packet.utf8Write(svcName, p += 4, svcNameLen);\n\n    this._debug && this._debug(`Outbound: Sending SERVICE_ACCEPT (${svcName})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n\n    if (this._server && this._banner && svcName === 'ssh-userauth') {\n      const banner = this._banner;\n      this._banner = undefined; // Prevent banner from being displayed again\n      const bannerLen = Buffer.byteLength(banner);\n      p = this._packetRW.write.allocStart;\n      const packet = this._packetRW.write.alloc(1 + 4 + bannerLen + 4);\n\n      packet[p] = MESSAGE.USERAUTH_BANNER;\n\n      writeUInt32BE(packet, bannerLen, ++p);\n      packet.utf8Write(banner, p += 4, bannerLen);\n\n      writeUInt32BE(packet, 0, p += bannerLen); // Empty language tag\n\n      this._debug && this._debug('Outbound: Sending USERAUTH_BANNER');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    }\n  }\n  // 'ssh-connection' service-specific\n  forwardedTcpip(chan, initWindow, maxPacket, cfg) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    const boundAddrLen = Buffer.byteLength(cfg.boundAddr);\n    const remoteAddrLen = Buffer.byteLength(cfg.remoteAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 15 + 4 + 4 + 4 + 4 + boundAddrLen + 4 + 4 + remoteAddrLen + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 15, ++p);\n    packet.utf8Write('forwarded-tcpip', p += 4, 15);\n\n    writeUInt32BE(packet, chan, p += 15);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    writeUInt32BE(packet, boundAddrLen, p += 4);\n    packet.utf8Write(cfg.boundAddr, p += 4, boundAddrLen);\n\n    writeUInt32BE(packet, cfg.boundPort, p += boundAddrLen);\n\n    writeUInt32BE(packet, remoteAddrLen, p += 4);\n    packet.utf8Write(cfg.remoteAddr, p += 4, remoteAddrLen);\n\n    writeUInt32BE(packet, cfg.remotePort, p += remoteAddrLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-tcpip)`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  x11(chan, initWindow, maxPacket, cfg) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    const addrLen = Buffer.byteLength(cfg.originAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 3 + 4 + 4 + 4 + 4 + addrLen + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 3, ++p);\n    packet.utf8Write('x11', p += 4, 3);\n\n    writeUInt32BE(packet, chan, p += 3);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    writeUInt32BE(packet, addrLen, p += 4);\n    packet.utf8Write(cfg.originAddr, p += 4, addrLen);\n\n    writeUInt32BE(packet, cfg.originPort, p += addrLen);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_OPEN (r:${chan}, x11)`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_authAgent(chan, initWindow, maxPacket) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 22 + 4 + 4 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 22, ++p);\n    packet.utf8Write('auth-agent@openssh.com', p += 4, 22);\n\n    writeUInt32BE(packet, chan, p += 22);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_OPEN (r:${chan}, auth-agent@openssh.com)`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_forwardedStreamLocal(chan, initWindow, maxPacket, cfg) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    const pathLen = Buffer.byteLength(cfg.socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 33 + 4 + 4 + 4 + 4 + pathLen + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n\n    writeUInt32BE(packet, 33, ++p);\n    packet.utf8Write('forwarded-streamlocal@openssh.com', p += 4, 33);\n\n    writeUInt32BE(packet, chan, p += 33);\n\n    writeUInt32BE(packet, initWindow, p += 4);\n\n    writeUInt32BE(packet, maxPacket, p += 4);\n\n    writeUInt32BE(packet, pathLen, p += 4);\n    packet.utf8Write(cfg.socketPath, p += 4, pathLen);\n\n    writeUInt32BE(packet, 0, p += pathLen);\n\n    if (this._debug) {\n      this._debug(\n        'Outbound: Sending CHANNEL_OPEN '\n          + `(r:${chan}, forwarded-streamlocal@openssh.com)`\n      );\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  exitStatus(chan, status) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    // Does not consume window space\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4);\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 11, p += 4);\n    packet.utf8Write('exit-status', p += 4, 11);\n\n    packet[p += 11] = 0;\n\n    writeUInt32BE(packet, status, ++p);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-status: ${status})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  exitSignal(chan, name, coreDumped, msg) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    // Does not consume window space\n\n    const origSignal = name;\n\n    if (typeof origSignal !== 'string' || !origSignal)\n      throw new Error(`Invalid signal: ${origSignal}`);\n\n    let signal = name.toUpperCase();\n    if (signal.slice(0, 3) === 'SIG')\n      signal = signal.slice(3);\n\n    if (SIGNALS[signal] !== 1)\n      throw new Error(`Invalid signal: ${origSignal}`);\n\n    const nameLen = Buffer.byteLength(signal);\n    const msgLen = (msg ? Buffer.byteLength(msg) : 0);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + 4 + 11 + 1 + 4 + nameLen + 1 + 4 + msgLen + 4\n    );\n\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n\n    writeUInt32BE(packet, chan, ++p);\n\n    writeUInt32BE(packet, 11, p += 4);\n    packet.utf8Write('exit-signal', p += 4, 11);\n\n    packet[p += 11] = 0;\n\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(signal, p += 4, nameLen);\n\n    packet[p += nameLen] = (coreDumped ? 1 : 0);\n\n    writeUInt32BE(packet, msgLen, ++p);\n\n    p += 4;\n    if (msgLen) {\n      packet.utf8Write(msg, p, msgLen);\n      p += msgLen;\n    }\n\n    writeUInt32BE(packet, 0, p);\n\n    this._debug && this._debug(\n      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-signal: ${name})`\n    );\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  // 'ssh-userauth' service-specific\n  authFailure(authMethods, isPartial) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    if (this._authsQueue.length === 0)\n      throw new Error('No auth in progress');\n\n    let methods;\n\n    if (typeof authMethods === 'boolean') {\n      isPartial = authMethods;\n      authMethods = undefined;\n    }\n\n    if (authMethods) {\n      methods = [];\n      for (let i = 0; i < authMethods.length; ++i) {\n        if (authMethods[i].toLowerCase() === 'none')\n          continue;\n        methods.push(authMethods[i]);\n      }\n      methods = methods.join(',');\n    } else {\n      methods = '';\n    }\n\n    const methodsLen = methods.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + methodsLen + 1);\n\n    packet[p] = MESSAGE.USERAUTH_FAILURE;\n\n    writeUInt32BE(packet, methodsLen, ++p);\n    packet.utf8Write(methods, p += 4, methodsLen);\n\n    packet[p += methodsLen] = (isPartial === true ? 1 : 0);\n\n    this._authsQueue.shift();\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_FAILURE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authSuccess() {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    if (this._authsQueue.length === 0)\n      throw new Error('No auth in progress');\n\n    const p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1);\n\n    packet[p] = MESSAGE.USERAUTH_SUCCESS;\n\n    this._authsQueue.shift();\n    this._authenticated = true;\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_SUCCESS');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n\n    if (this._kex.negotiated.cs.compress === 'zlib@openssh.com')\n      this._packetRW.read = new ZlibPacketReader();\n    if (this._kex.negotiated.sc.compress === 'zlib@openssh.com')\n      this._packetRW.write = new ZlibPacketWriter(this);\n  }\n  authPKOK(keyAlgo, key) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    if (this._authsQueue.length === 0 || this._authsQueue[0] !== 'publickey')\n      throw new Error('\"publickey\" auth not in progress');\n\n    // TODO: support parsed key for `key`\n\n    const keyAlgoLen = Buffer.byteLength(keyAlgo);\n    const keyLen = key.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + keyAlgoLen + 4 + keyLen);\n\n    packet[p] = MESSAGE.USERAUTH_PK_OK;\n\n    writeUInt32BE(packet, keyAlgoLen, ++p);\n    packet.utf8Write(keyAlgo, p += 4, keyAlgoLen);\n\n    writeUInt32BE(packet, keyLen, p += keyAlgoLen);\n    packet.set(key, p += 4);\n\n    this._authsQueue.shift();\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_PK_OK');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authPasswdChg(prompt) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    const promptLen = Buffer.byteLength(prompt);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + promptLen + 4);\n\n    packet[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ;\n\n    writeUInt32BE(packet, promptLen, ++p);\n    packet.utf8Write(prompt, p += 4, promptLen);\n\n    writeUInt32BE(packet, 0, p += promptLen); // Empty language tag\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_PASSWD_CHANGEREQ');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authInfoReq(name, instructions, prompts) {\n    if (!this._server)\n      throw new Error('Server-only method called in client mode');\n\n    let promptsLen = 0;\n    const nameLen = name ? Buffer.byteLength(name) : 0;\n    const instrLen = instructions ? Buffer.byteLength(instructions) : 0;\n\n    for (let i = 0; i < prompts.length; ++i)\n      promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(\n      1 + 4 + nameLen + 4 + instrLen + 4 + 4 + promptsLen\n    );\n\n    packet[p] = MESSAGE.USERAUTH_INFO_REQUEST;\n\n    writeUInt32BE(packet, nameLen, ++p);\n    p += 4;\n    if (name) {\n      packet.utf8Write(name, p, nameLen);\n      p += nameLen;\n    }\n\n    writeUInt32BE(packet, instrLen, p);\n    p += 4;\n    if (instructions) {\n      packet.utf8Write(instructions, p, instrLen);\n      p += instrLen;\n    }\n\n    writeUInt32BE(packet, 0, p);\n\n    writeUInt32BE(packet, prompts.length, p += 4);\n    p += 4;\n    for (let i = 0; i < prompts.length; ++i) {\n      const prompt = prompts[i];\n      const promptLen = Buffer.byteLength(prompt.prompt);\n\n      writeUInt32BE(packet, promptLen, p);\n      p += 4;\n      if (promptLen) {\n        packet.utf8Write(prompt.prompt, p, promptLen);\n        p += promptLen;\n      }\n      packet[p++] = (prompt.echo ? 1 : 0);\n    }\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_INFO_REQUEST');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n}\n\n// SSH-protoversion-softwareversion (SP comments) CR LF\nconst RE_IDENT = /^SSH-(2\\.0|1\\.99)-([^ ]+)(?: (.*))?$/;\n\n// TODO: optimize this by starting n bytes from the end of this._buffer instead\n// of the beginning\nfunction parseHeader(chunk, p, len) {\n  let data;\n  let chunkOffset;\n  if (this._buffer) {\n    data = Buffer.allocUnsafe(this._buffer.length + (len - p));\n    data.set(this._buffer, 0);\n    if (p === 0) {\n      data.set(chunk, this._buffer.length);\n    } else {\n      data.set(new Uint8Array(chunk.buffer,\n                              chunk.byteOffset + p,\n                              (len - p)),\n               this._buffer.length);\n    }\n    chunkOffset = this._buffer.length;\n    p = 0;\n  } else {\n    data = chunk;\n    chunkOffset = 0;\n  }\n  const op = p;\n  let start = p;\n  let end = p;\n  let needNL = false;\n  let lineLen = 0;\n  let lines = 0;\n  for (; p < data.length; ++p) {\n    const ch = data[p];\n\n    if (ch === 13 /* '\\r' */) {\n      needNL = true;\n      continue;\n    }\n\n    if (ch === 10 /* '\\n' */) {\n      if (end > start\n          && end - start > 4\n          && data[start] === 83 /* 'S' */\n          && data[start + 1] === 83 /* 'S' */\n          && data[start + 2] === 72 /* 'H' */\n          && data[start + 3] === 45 /* '-' */) {\n\n        const full = data.latin1Slice(op, end + 1);\n        const identRaw = (start === op ? full : full.slice(start - op));\n        const m = RE_IDENT.exec(identRaw);\n        if (!m)\n          throw new Error('Invalid identification string');\n\n        const header = {\n          greeting: (start === op ? '' : full.slice(0, start - op)),\n          identRaw,\n          versions: {\n            protocol: m[1],\n            software: m[2],\n          },\n          comments: m[3]\n        };\n\n        // Needed during handshake\n        this._remoteIdentRaw = Buffer.from(identRaw);\n\n        this._debug && this._debug(`Remote ident: ${inspect(identRaw)}`);\n        this._compatFlags = getCompatFlags(header);\n\n        this._buffer = undefined;\n        this._decipher =\n          new NullDecipher(0, onKEXPayload.bind(this, { firstPacket: true }));\n        this._parse = parsePacket;\n\n        this._onHeader(header);\n        if (!this._destruct) {\n          // We disconnected inside _onHeader\n          return len;\n        }\n\n        kexinit(this);\n\n        return p + 1 - chunkOffset;\n      }\n\n      // Only allow pre-ident greetings when we're a client\n      if (this._server)\n        throw new Error('Greetings from clients not permitted');\n\n      if (++lines > MAX_LINES)\n        throw new Error('Max greeting lines exceeded');\n\n      needNL = false;\n      start = p + 1;\n      lineLen = 0;\n    } else if (needNL) {\n      throw new Error('Invalid header: expected newline');\n    } else if (++lineLen >= MAX_LINE_LEN) {\n      throw new Error('Header line too long');\n    }\n\n    end = p;\n  }\n  if (!this._buffer)\n    this._buffer = bufferSlice(data, op);\n\n  return p - chunkOffset;\n}\n\nfunction parsePacket(chunk, p, len) {\n  return this._decipher.decrypt(chunk, p, len);\n}\n\nfunction onPayload(payload) {\n  // XXX: move this to the Decipher implementations?\n\n  this._onPacket();\n\n  if (payload.length === 0) {\n    this._debug && this._debug('Inbound: Skipping empty packet payload');\n    return;\n  }\n\n  payload = this._packetRW.read.read(payload);\n\n  const type = payload[0];\n  if (type === MESSAGE.USERAUTH_SUCCESS\n      && !this._server\n      && !this._authenticated) {\n    this._authenticated = true;\n    if (this._kex.negotiated.cs.compress === 'zlib@openssh.com')\n      this._packetRW.write = new ZlibPacketWriter(this);\n    if (this._kex.negotiated.sc.compress === 'zlib@openssh.com')\n      this._packetRW.read = new ZlibPacketReader();\n  }\n  const handler = MESSAGE_HANDLERS[type];\n  if (handler === undefined) {\n    this._debug && this._debug(`Inbound: Unsupported message type: ${type}`);\n    return;\n  }\n\n  return handler(this, payload);\n}\n\nfunction getCompatFlags(header) {\n  const software = header.versions.software;\n\n  let flags = 0;\n\n  for (const rule of COMPAT_CHECKS) {\n    if (typeof rule[0] === 'string') {\n      if (software === rule[0])\n        flags |= rule[1];\n    } else if (rule[0].test(software)) {\n      flags |= rule[1];\n    }\n  }\n\n  return flags;\n}\n\nfunction modesToBytes(modes) {\n  const keys = Object.keys(modes);\n  const bytes = Buffer.allocUnsafe((5 * keys.length) + 1);\n  let b = 0;\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (key === 'TTY_OP_END')\n      continue;\n\n    const opcode = TERMINAL_MODE[key];\n    if (opcode === undefined)\n      continue;\n\n    const val = modes[key];\n    if (typeof val === 'number' && isFinite(val)) {\n      bytes[b++] = opcode;\n      bytes[b++] = val >>> 24;\n      bytes[b++] = val >>> 16;\n      bytes[b++] = val >>> 8;\n      bytes[b++] = val;\n    }\n  }\n\n  bytes[b++] = TERMINAL_MODE.TTY_OP_END;\n\n  if (b < bytes.length)\n    return bufferSlice(bytes, 0, b);\n\n  return bytes;\n}\n\nfunction sendExtInfo(proto) {\n  let serverSigAlgs =\n    'ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521'\n      + 'rsa-sha2-512,rsa-sha2-256,ssh-rsa,ssh-dss';\n  if (eddsaSupported)\n    serverSigAlgs = `ssh-ed25519,${serverSigAlgs}`;\n  const algsLen = Buffer.byteLength(serverSigAlgs);\n\n  let p = proto._packetRW.write.allocStart;\n  const packet = proto._packetRW.write.alloc(1 + 4 + 4 + 15 + 4 + algsLen);\n\n  packet[p] = MESSAGE.EXT_INFO;\n\n  writeUInt32BE(packet, 1, ++p);\n\n  writeUInt32BE(packet, 15, p += 4);\n  packet.utf8Write('server-sig-algs', p += 4, 15);\n\n  writeUInt32BE(packet, algsLen, p += 15);\n  packet.utf8Write(serverSigAlgs, p += 4, algsLen);\n\n  proto._debug && proto._debug('Outbound: Sending EXT_INFO');\n  sendPacket(proto, proto._packetRW.write.finalize(packet));\n}\n\nmodule.exports = Protocol;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}